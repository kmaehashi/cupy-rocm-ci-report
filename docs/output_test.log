============================= test session starts ==============================
platform linux -- Python 3.8.7, pytest-6.2.2, py-1.10.0, pluggy-0.13.1
rootdir: /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy, configfile: setup.cfg
plugins: html-3.1.1, metadata-1.11.0
collected 86619 items / 56 deselected / 86563 selected

tests/cupy_tests/test_cublas.py ........................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
...........................F...........F.............................F.. [  2%]
.........F..........                                                     [  2%]
tests/cupy_tests/test_cudnn.py sssssssssssssssssssssssssssssssssssssssss [  2%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  2%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssss                  [  4%]
tests/cupy_tests/test_cusolver.py ssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssss                                               [  5%]
tests/cupy_tests/test_cusparse.py ssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssss.Fsssssssssssssss  [  6%]
tests/cupy_tests/test_cutensor.py ssssssssssssssssssssssssssssssssssssss [  6%]
sssssssssssssssssssssssssssssssssssss                                    [  6%]
tests/cupy_tests/test_init.py ..s.......                                 [  6%]
tests/cupy_tests/test_ndim.py ............                               [  6%]
tests/cupy_tests/test_numpy_interop.py ..x....                           [  6%]
tests/cupy_tests/test_type_routines.py ................................. [  6%]
.                                                                        [  6%]
tests/cupy_tests/binary_tests/test_elementwise.py ......                 [  6%]
tests/cupy_tests/binary_tests/test_packing.py ...                        [  6%]
tests/cupy_tests/core_tests/test_array_function.py .....                 [  6%]
tests/cupy_tests/core_tests/test_carray.py .....                         [  6%]
tests/cupy_tests/core_tests/test_core.py ....                            [  6%]
tests/cupy_tests/core_tests/test_cub_reduction.py ssssssssssssssssssssss [  6%]
sss                                                                      [  6%]
tests/cupy_tests/core_tests/test_dlpack.py ..............                [  7%]
tests/cupy_tests/core_tests/test_elementwise.py ...............          [  7%]
tests/cupy_tests/core_tests/test_flags.py .............................  [  7%]
tests/cupy_tests/core_tests/test_function.py ..                          [  7%]
tests/cupy_tests/core_tests/test_internal.py ........................... [  7%]
...............................................................          [  7%]
tests/cupy_tests/core_tests/test_iter.py ............                    [  7%]
tests/cupy_tests/core_tests/test_ndarray.py ..........................ss [  7%]
ss...................................................................... [  7%]
.......................sss...............                                [  7%]
tests/cupy_tests/core_tests/test_ndarray_adv_indexing.py ............... [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
.............................................                            [  7%]
tests/cupy_tests/core_tests/test_ndarray_complex_ops.py ................ [  7%]
.....                                                                    [  7%]
tests/cupy_tests/core_tests/test_ndarray_contiguity.py .                 [  7%]
tests/cupy_tests/core_tests/test_ndarray_conversion.py .......FF..       [  7%]
tests/cupy_tests/core_tests/test_ndarray_copy_and_view.py ss........s... [  7%]
....ssss.......                                                          [  7%]
tests/cupy_tests/core_tests/test_ndarray_cuda_array_interface.py sssssss [  7%]
ssssssssssssssssssssssssssssssssssssssssssssssss                         [  7%]
tests/cupy_tests/core_tests/test_ndarray_elementwise_op.py ............. [  7%]
........................................................................ [  7%]
.................................................................        [  7%]
tests/cupy_tests/core_tests/test_ndarray_get.py ............             [  7%]
tests/cupy_tests/core_tests/test_ndarray_indexing.py FFFF............... [  8%]
........F..........F.............................                        [  8%]
tests/cupy_tests/core_tests/test_ndarray_math.py ......................s [  8%]
sssssssssss                                                              [  8%]
tests/cupy_tests/core_tests/test_ndarray_owndata.py ...                  [  8%]
tests/cupy_tests/core_tests/test_ndarray_reduction.py .................. [  8%]
........................................................................ [  8%]
........................................................................ [  8%]
................................                                         [  8%]
tests/cupy_tests/core_tests/test_ndarray_scatter.py .................... [  8%]
........................................................................ [  8%]
...............................................................          [  8%]
tests/cupy_tests/core_tests/test_ndarray_ufunc.py .......                [  8%]
tests/cupy_tests/core_tests/test_ndarray_unary_op.py .......F..........s [  8%]
...                                                                      [  8%]
tests/cupy_tests/core_tests/test_raw.py .ss.........sss..s.s.s........ss [  8%]
.........sss..s.s.s........ss.........sss..s.s.s......ssssssssssssssssss [  8%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.s [  8%]
s.......sssss....s.s......sssssssssssssssssssssssssssss                  [  8%]
tests/cupy_tests/core_tests/test_reduction.py .....................      [  8%]
tests/cupy_tests/core_tests/test_scan.py ....                            [  8%]
tests/cupy_tests/core_tests/test_syncdetect.py ....                      [  8%]
tests/cupy_tests/core_tests/test_userkernel.py ....sss.............      [  8%]
tests/cupy_tests/core_tests/fusion_tests/test_array.py ................. [  8%]
........................................................................ [  8%]
....................................................                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_indexing.py .............. [  9%]
.................s                                                       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py ....       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_misc.py .......s.......... [  9%]
........                                                                 [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_optimization.py .......... [  9%]
....                                                                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_reduction.py ............. [  9%]
........................................................................ [  9%]
.........................................................s.s.s.s.s.s.s.s [  9%]
.s.ssssssssssssssssss.sss                                                [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_routines.py .............. [  9%]
........................................................................ [  9%]
..............                                                           [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_ufunc.py ................. [  9%]
......................................................                   [  9%]
tests/cupy_tests/creation_tests/test_basic.py .......................... [  9%]
...........................................................s............ [  9%]
....s.                                                                   [  9%]
tests/cupy_tests/creation_tests/test_from_data.py ssssssssssssssssssssss [  9%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss............. [  9%]
...................................................................      [  9%]
tests/cupy_tests/creation_tests/test_matrix.py ......................... [  9%]
.................................                                        [  9%]
tests/cupy_tests/creation_tests/test_ranges.py ......................... [  9%]
..............................................................           [ 10%]
tests/cupy_tests/cuda_tests/test_compiler.py sssssss........             [ 10%]
tests/cupy_tests/cuda_tests/test_cublas.py .                             [ 10%]
tests/cupy_tests/cuda_tests/test_cudnn.py s                              [ 10%]
tests/cupy_tests/cuda_tests/test_cufft.py FFFFFFFFssssssss.              [ 10%]
tests/cupy_tests/cuda_tests/test_curand.py .....                         [ 10%]
tests/cupy_tests/cuda_tests/test_cusolver.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cusparse.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cutensor.py s                           [ 10%]
tests/cupy_tests/cuda_tests/test_device.py .............F.               [ 10%]
tests/cupy_tests/cuda_tests/test_driver.py ss.                           [ 10%]
tests/cupy_tests/cuda_tests/test_memory.py ....ssssssss..........sssssss [ 10%]
sss.................................................ssssss               [ 10%]
tests/cupy_tests/cuda_tests/test_memory_hook.py .                        [ 10%]
tests/cupy_tests/cuda_tests/test_nccl.py ........                        [ 10%]
tests/cupy_tests/cuda_tests/test_nvrtc.py .                              [ 10%]
tests/cupy_tests/cuda_tests/test_nvtx.py ....                            [ 10%]
tests/cupy_tests/cuda_tests/test_pinned_memory.py ............           [ 10%]
tests/cupy_tests/cuda_tests/test_profile.py ..                           [ 10%]
tests/cupy_tests/cuda_tests/test_runtime.py .                            [ 10%]
tests/cupy_tests/cuda_tests/test_stream.py ..s..s..ssssssss.s            [ 10%]
tests/cupy_tests/cuda_tests/test_texture.py FFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 10%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 10%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 10%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 10%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFssFFssFFFFssssFFFFF      [ 10%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_debug_print.py .     [ 10%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_line_profile.py ..   [ 10%]
tests/cupy_tests/fft_tests/test_cache.py ..sss.....s..                   [ 10%]
tests/cupy_tests/fft_tests/test_callback.py ssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssss                     [ 11%]
tests/cupy_tests/fft_tests/test_fft.py ................................. [ 11%]
........................................................................ [ 11%]
...............................................................sssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
sssssssssssssss......................................................... [ 11%]
................................................s................s...... [ 11%]
..........s..............................ssssssssssssssssssssssss....... [ 11%]
........................................................................ [ 11%]
........................................................................ [ 11%]
.......s..sssssssssssss................................................. [ 12%]
...................................                                      [ 12%]
tests/cupy_tests/functional_tests/test_piecewise.py .............        [ 12%]
tests/cupy_tests/functional_tests/test_vectorize.py .................... [ 12%]
...............                                                          [ 12%]
tests/cupy_tests/indexing_tests/test_generate.py .......F............... [ 12%]
...............                                                          [ 12%]
tests/cupy_tests/indexing_tests/test_indexing.py ....................... [ 12%]
..........................                                               [ 12%]
tests/cupy_tests/indexing_tests/test_insert.py ......................... [ 12%]
........................................................................ [ 12%]
........................................................................ [ 12%]
.........................................................                [ 12%]
tests/cupy_tests/indexing_tests/test_iterate.py ........................ [ 12%]
...............................................                          [ 12%]
tests/cupy_tests/io_tests/test_base_n.py ............................    [ 12%]
tests/cupy_tests/io_tests/test_formatting.py ..                          [ 12%]
tests/cupy_tests/io_tests/test_npz.py .......                            [ 12%]
tests/cupy_tests/lib_tests/test_polynomial.py .......ss.......ssssssssss [ 12%]
sssssss........ssssssssssssssssssssssssssssssssssssFFFFFFFFFFFFFFFFFFFF. [ 12%]
..ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 12%]
ssssssssssssssssssssssssss....FFFFFFFFFFFFFFFFFFFFFFFFFF................ [ 12%]
........................................................................ [ 13%]
........FFFFFFFF........FFFFFFFF........................................ [ 13%]
...........FFFFFF............................F.......................... [ 13%]
..                                                                       [ 13%]
tests/cupy_tests/lib_tests/test_shape_base.py ......................     [ 13%]
tests/cupy_tests/lib_tests/test_strided_tricks.py ..                     [ 13%]
tests/cupy_tests/linalg_tests/test_decomposition.py .................... [ 13%]
.                                                                        [ 13%]
tests/cupy_tests/linalg_tests/test_eigenvalue.py FFFFFFFF                [ 13%]
tests/cupy_tests/linalg_tests/test_einsum.py ........................... [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 14%]
........................................................................ [ 14%]
..........                                                               [ 14%]
tests/cupy_tests/linalg_tests/test_norms.py ............................ [ 14%]
........................................................................ [ 14%]
........................................................................ [ 14%]
.................................................................        [ 14%]
tests/cupy_tests/linalg_tests/test_product.py .......................... [ 14%]
........................................................................ [ 14%]
........................................................................ [ 14%]
..........................................                               [ 14%]
tests/cupy_tests/linalg_tests/test_solve.py ............................ [ 14%]
..                                                                       [ 14%]
tests/cupy_tests/logic_tests/test_comparison.py ........................ [ 14%]
.....                                                                    [ 14%]
tests/cupy_tests/logic_tests/test_content.py ...                         [ 14%]
tests/cupy_tests/logic_tests/test_ops.py ....                            [ 14%]
tests/cupy_tests/logic_tests/test_truth.py ............................. [ 14%]
........................................................................ [ 14%]
........................................................................ [ 14%]
........................................................................ [ 14%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
...........................................                              [ 15%]
tests/cupy_tests/logic_tests/test_type_test.py ......................... [ 15%]
.......                                                                  [ 15%]
tests/cupy_tests/manipulation_tests/test_add_remove.py ................. [ 15%]
.........................                                                [ 15%]
tests/cupy_tests/manipulation_tests/test_basic.py ...................... [ 15%]
.......................................................                  [ 15%]
tests/cupy_tests/manipulation_tests/test_dims.py .....F.F............... [ 15%]
................................................                         [ 15%]
tests/cupy_tests/manipulation_tests/test_join.py ....................... [ 15%]
...........................                                              [ 15%]
tests/cupy_tests/manipulation_tests/test_kind.py ...........             [ 15%]
tests/cupy_tests/manipulation_tests/test_rearrange.py .................. [ 15%]
.................................                                        [ 15%]
tests/cupy_tests/manipulation_tests/test_shape.py ...................... [ 15%]
....................................                                     [ 15%]
tests/cupy_tests/manipulation_tests/test_split.py ..................     [ 16%]
tests/cupy_tests/manipulation_tests/test_tiling.py ..................... [ 16%]
...........                                                              [ 16%]
tests/cupy_tests/manipulation_tests/test_transpose.py .................. [ 16%]
..........                                                               [ 16%]
tests/cupy_tests/math_tests/test_arithmetic.py ......................... [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
...........................                                              [ 25%]
tests/cupy_tests/math_tests/test_explog.py .........                     [ 25%]
tests/cupy_tests/math_tests/test_floating.py .......                     [ 25%]
tests/cupy_tests/math_tests/test_hyperbolic.py ......                    [ 25%]
tests/cupy_tests/math_tests/test_matmul.py ............................. [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
......................................                                   [ 25%]
tests/cupy_tests/math_tests/test_misc.py ............................... [ 25%]
............................................F..F..F..................... [ 25%]
............................                                             [ 25%]
tests/cupy_tests/math_tests/test_rational.py ..F.                        [ 25%]
tests/cupy_tests/math_tests/test_rounding.py ........................... [ 26%]
..........................................                               [ 26%]
tests/cupy_tests/math_tests/test_special.py ...                          [ 26%]
tests/cupy_tests/math_tests/test_sumprod.py ............................ [ 26%]
....................................................ssssssssssssssss.... [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
..............................................................           [ 26%]
tests/cupy_tests/math_tests/test_trigonometric.py ...............        [ 26%]
tests/cupy_tests/math_tests/test_window.py ............................. [ 26%]
.....                                                                    [ 26%]
tests/cupy_tests/misc_tests/test_memory_ranges.py ................       [ 26%]
tests/cupy_tests/misc_tests/test_who.py ......                           [ 26%]
tests/cupy_tests/padding_tests/test_pad.py ............................. [ 27%]
..............................................                           [ 27%]
tests/cupy_tests/polynomial_tests/test_polynomial.py ................... [ 27%]
                                                                         [ 27%]
tests/cupy_tests/polynomial_tests/test_polyutils.py .................... [ 27%]
................                                                         [ 27%]
tests/cupy_tests/prof_tests/test_range.py ........                       [ 27%]
tests/cupy_tests/random_tests/test_bit_generator.py ssssssssssss         [ 27%]
tests/cupy_tests/random_tests/test_distributions.py .................... [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
................................                                         [ 28%]
tests/cupy_tests/random_tests/test_generator.py ........................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
.................................................................F...... [ 28%]
......................F...............................                   [ 28%]
tests/cupy_tests/random_tests/test_generator_api.py sssssssssssssssss    [ 28%]
tests/cupy_tests/random_tests/test_init.py .                             [ 28%]
tests/cupy_tests/random_tests/test_permutations.py ...x...x............. [ 28%]
........................................................................ [ 28%]
........................................................................ [ 29%]
.............                                                            [ 29%]
tests/cupy_tests/random_tests/test_random.py .                           [ 29%]
tests/cupy_tests/random_tests/test_sample.py ...............F........F.. [ 29%]
............                                                             [ 29%]
tests/cupy_tests/sorting_tests/test_count.py ....                        [ 29%]
tests/cupy_tests/sorting_tests/test_search.py ssssssss........ssssssss.. [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
....................................................................     [ 29%]
tests/cupy_tests/sorting_tests/test_sort.py ............................ [ 29%]
........................................................................ [ 29%]
..........................................................x......X....   [ 29%]
tests/cupy_tests/statistics_tests/test_correlation.py .................. [ 29%]
..............................F..F.FF...................                 [ 29%]
tests/cupy_tests/statistics_tests/test_histogram.py .................... [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................                 [ 30%]
tests/cupy_tests/statistics_tests/test_meanvar.py ...................... [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
..                                                                       [ 30%]
tests/cupy_tests/statistics_tests/test_order.py ........................ [ 30%]
....................                                                     [ 30%]
tests/cupy_tests/testing_tests/test_array.py ........................... [ 30%]
...............................................                          [ 30%]
tests/cupy_tests/testing_tests/test_condition.py ................        [ 30%]
tests/cupy_tests/testing_tests/test_helper.py .......................... [ 30%]
........................................................................ [ 30%]
.....sssss..sssssss..ssxxxxxxxx................x..x.................     [ 30%]
tests/cupy_tests/testing_tests/test_parameterized.py ............s.s.s.s [ 30%]
....ssss......                                                           [ 30%]
tests/cupyx_tests/test_cupyx.py ..                                       [ 30%]
tests/cupyx_tests/test_lapack.py .s.s.s.s.....s.s.s.s.....s.s.s.s.....s. [ 30%]
s.s.s.............sssssssssssss                                          [ 30%]
tests/cupyx_tests/test_optimize.py sssssssss                             [ 30%]
tests/cupyx_tests/test_rsqrt.py .                                        [ 30%]
tests/cupyx_tests/test_runtime.py s.                                     [ 30%]
tests/cupyx_tests/test_scatter.py ...                                    [ 30%]
tests/cupyx_tests/test_time.py .........                                 [ 30%]
tests/cupyx_tests/fallback_mode_tests/test_fallback.py ................. [ 30%]
........................................................................ [ 30%]
.........                                                                [ 30%]
tests/cupyx_tests/fallback_mode_tests/test_notifications.py .........    [ 30%]
tests/cupyx_tests/linalg_tests/test_solve.py FFFFFFFFFFFFFFFF....ssss    [ 30%]
tests/cupyx_tests/linalg_tests/sparse_tests/test_solve.py ssssssss       [ 30%]
tests/cupyx_tests/scipy_tests/test_get_array_module.py ss                [ 30%]
tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py .ss.....ss.....ss... [ 30%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 31%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 31%]
.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.. [ 31%]
...ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.... [ 31%]
.ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....s [ 31%]
s.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss. [ 31%]
....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss... [ 31%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 31%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 31%]
.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.. [ 31%]
...ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.... [ 31%]
.ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....s [ 31%]
s.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss. [ 32%]
....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss... [ 32%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 32%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 32%]
.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.. [ 32%]
...ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.... [ 32%]
.ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....s [ 32%]
s.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss. [ 32%]
....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss... [ 32%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 32%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 32%]
.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.. [ 32%]
...ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.... [ 33%]
.ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....s [ 33%]
s.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss. [ 33%]
....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss... [ 33%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 33%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 33%]
.....ss.....ss.....ss.....ss.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.s [ 34%]
ss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.s [ 34%]
ss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.s [ 34%]
ss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.s [ 34%]
ss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s...s...s...s.. [ 34%]
.s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s.. [ 34%]
.s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s.. [ 34%]
.s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s.. [ 35%]
.s...s...s...s...s...s..........                                         [ 35%]
tests/cupyx_tests/scipy_tests/fft_tests/test_helper.py .                 [ 35%]
tests/cupyx_tests/scipy_tests/fftpack_tests/test_fftpack.py ssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
sssssssssssssssssss......                                                [ 36%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py sssssssssss [ 36%]
sssssssssssssssssssssssssssssssssssssssssssssssssss                      [ 36%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_solve_triangular.py ssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss     [ 36%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_special_matrices.py ssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
sssssssssssssssssssssssssssssssssssssssssssssssss                        [ 36%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py ssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssss                                     [ 44%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_fourier.py ssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssss                                 [ 45%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py ssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssss........................................................ [ 59%]
........................................................................ [ 59%]
........................................................................ [ 59%]
........................................ssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
sssssssssssssssssssssssssssssssssssssssss............................... [ 59%]
.........sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss              [ 60%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py sssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
sss                                                                      [ 64%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_morphology.py sssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
                                                                         [ 73%]
tests/cupyx_tests/scipy_tests/signal_tests/test_bsplines.py ssssssssssss [ 73%]
                                                                         [ 73%]
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py sssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
sssssssssssssss...............ssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssss                                     [ 74%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_base.py sssssss          [ 74%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py sssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
sssssFFF.FFF.FFFFFFFFFFFFFFFFFFFsFFFFFFFsFF..FF.sFFFFFFFsFFFFFFFsFF..FF. [ 74%]
sFFsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssss                                               [ 77%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py ....s.FsFs.....sF [ 77%]
....s.FsFs.....sF....s.FsFs.....sF....s.FsFs.....sFsssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
sssssssssssssssssss..                                                    [ 79%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py ....s...sFsFFFsFF [ 79%]
..F.sF....s...sFsFFFsFF..F.sF....s...sFsFFFsFF..F.sF....s...sFsFFFsFF..F [ 79%]
.sFsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
sssssssssssssssssssssssssssssss..                                        [ 81%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py ....s...sFsFFFsFF [ 82%]
..F.sF....s...sFsFFFsFF..F.sF....s...sFsFFFsFF..F.sF....s...sFsFFFsFF..F [ 82%]
.sFsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss..        [ 89%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py ..........sF..... [ 89%]
.....sF..........sF..........sFsssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
sssssssssssssssssssssssssss..                                            [ 89%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_extract.py sssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
sssssssssssssssssssssss                                                  [ 90%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_index.py sssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
sssssssssssssssssssss                                                    [ 96%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_linalg.py ssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssss                                   [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_bessel.py ssssssssssss  [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_convex_analysis.py ssss [ 99%]
s                                                                        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_digamma.py sssss        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_erf.py ssssssssssss     [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gamma.py ssss           [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gammaln.py ssss         [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_polygamma.py ssss       [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_statistics.py ss        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_zeta.py ssss            [ 99%]
tests/cupyx_tests/scipy_tests/stats_tests/test_distributions.py ssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss........ [ 99%]
                                                                         [ 99%]
tests/cupyx_tests/tools_tests/test_install_library.py ..                 [ 99%]
tests/example_tests/test_finance.py .FF                                  [ 99%]
tests/example_tests/test_gemm.py .                                       [ 99%]
tests/example_tests/test_gmm.py ss                                       [ 99%]
tests/example_tests/test_kmeans.py sss                                   [ 99%]
tests/install_tests/test_build.py FF                                     [ 99%]
tests/install_tests/test_utils.py ..                                     [100%]

=================================== FAILURES ===================================
_ TestDgmm_param_5_{ordera='C', orderc='F', shape=(9, 10), side='R'}.test_dgmm_incx_minus_one _

self = <<cupy_tests.test_cublas.TestDgmm_param_5_{ordera='C', orderc='F', shape=(9, 10), side='R'} testMethod=test_dgmm_incx_minus_one>  parameter: {'ordera': 'C', 'orderc': 'F', 'shape': (9, 10), 'side': 'R'}>
dtype = <class 'numpy.float32'>

    @testing.for_dtypes('fdFD')
    def test_dgmm_incx_minus_one(self, dtype):
        if self.orderc != 'F':
            raise unittest.SkipTest()
        self._setup(dtype)
        if self.side == 'L':
            ref = cupy.diag(self.x[::-1]) @ self.a
        elif self.side == 'R':
            ref = self.a @ cupy.diag(self.x[::-1])
        c = cublas.dgmm(self.side, self.a, self.x, incx=-1)
>       cupy.testing.assert_allclose(c, ref, rtol=self.tol, atol=self.tol)

tests/cupy_tests/test_cublas.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 0.5288711 ,  0.6377865 ,  0.26376152,  0.35193685,  0.17948338,
         0.35193685,  0.26376152,  0.6377865 ....44726366,  0.24004342,
         0.14460628,  0.31539476,  0.06718525,  0.31608725, -0.34620836]],
      dtype=float32)
desired = array([[0.21043788, 0.6892013 , 0.5375281 , 0.23843391, 0.27363613,
        0.27363613, 0.23843391, 0.5375281 , 0.6892...5  , 0.30301693, 0.36596453,
        0.11243354, 0.28510907, 0.0566239 , 0.4119108 , 0.5100103 ]],
      dtype=float32)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 90 / 90 (100%)
E       Max absolute difference: 0.8562187
E       Max relative difference: 1.6788263
E        x: array([[ 0.528871,  0.637787,  0.263762,  0.351937,  0.179483,  0.351937,
E                0.263762,  0.637787,  0.528871, -0.142851],
E              [ 0.762956,  0.471654,  0.248569,  0.597837,  0.030095,  0.047475,...
E        y: array([[0.210438, 0.689201, 0.537528, 0.238434, 0.273636, 0.273636,
E               0.238434, 0.537528, 0.689201, 0.210438],
E              [0.30358 , 0.509676, 0.506567, 0.405029, 0.045882, 0.036913,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is f
_ TestDgmm_param_7_{ordera='C', orderc='F', shape=(10, 9), side='R'}.test_dgmm_incx_minus_one _

self = <<cupy_tests.test_cublas.TestDgmm_param_7_{ordera='C', orderc='F', shape=(10, 9), side='R'} testMethod=test_dgmm_incx_minus_one>  parameter: {'ordera': 'C', 'orderc': 'F', 'shape': (10, 9), 'side': 'R'}>
dtype = <class 'numpy.float32'>

    @testing.for_dtypes('fdFD')
    def test_dgmm_incx_minus_one(self, dtype):
        if self.orderc != 'F':
            raise unittest.SkipTest()
        self._setup(dtype)
        if self.side == 'L':
            ref = cupy.diag(self.x[::-1]) @ self.a
        elif self.side == 'R':
            ref = self.a @ cupy.diag(self.x[::-1])
        c = cublas.dgmm(self.side, self.a, self.x, incx=-1)
>       cupy.testing.assert_allclose(c, ref, rtol=self.tol, atol=self.tol)

tests/cupy_tests/test_cublas.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0.11549115, 0.6892013 , 0.5375281 , 0.23843391, 0.27363613,
        0.27363613, 0.23843391, 0.5375281 , 0.6892....06181655, 0.6175279 , 0.24793755, 0.17141351,
        0.22167656, 0.05118661, 0.34715945, 0.6646227 ]], dtype=float32)
desired = array([[0.5288711 , 0.6377865 , 0.26376152, 0.35193685, 0.17948338,
        0.35193685, 0.26376152, 0.6377865 , 0.5288....057205  , 0.30301693, 0.36596453, 0.11243354,
        0.28510907, 0.0566239 , 0.4119108 , 0.5100103 ]], dtype=float32)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 90 / 90 (100%)
E       Max absolute difference: 0.73572075
E       Max relative difference: 1.0379322
E        x: array([[0.115491, 0.689201, 0.537528, 0.238434, 0.273636, 0.273636,
E               0.238434, 0.537528, 0.689201],
E              [0.080691, 0.762956, 0.471654, 0.248569, 0.597837, 0.030095,...
E        y: array([[0.528871, 0.637787, 0.263762, 0.351937, 0.179483, 0.351937,
E               0.263762, 0.637787, 0.528871],
E              [0.369508, 0.706039, 0.231438, 0.366897, 0.392133, 0.038706,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is f
_ TestDgmm_param_12_{ordera='F', orderc='F', shape=(9, 10), side='L'}.test_dgmm_incx_minus_one _

self = <<cupy_tests.test_cublas.TestDgmm_param_12_{ordera='F', orderc='F', shape=(9, 10), side='L'} testMethod=test_dgmm_incx_minus_one>  parameter: {'ordera': 'F', 'orderc': 'F', 'shape': (9, 10), 'side': 'L'}>
dtype = <class 'numpy.float32'>

    @testing.for_dtypes('fdFD')
    def test_dgmm_incx_minus_one(self, dtype):
        if self.orderc != 'F':
            raise unittest.SkipTest()
        self._setup(dtype)
        if self.side == 'L':
            ref = cupy.diag(self.x[::-1]) @ self.a
        elif self.side == 'R':
            ref = self.a @ cupy.diag(self.x[::-1])
        c = cublas.dgmm(self.side, self.a, self.x, incx=-1)
>       cupy.testing.assert_allclose(c, ref, rtol=self.tol, atol=self.tol)

tests/cupy_tests/test_cublas.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0.9201937 , 1.1991554 , 1.0106511 , 0.9136037 , 0.7103405 ,
        1.0829684 , 0.7337009 , 1.4952326 , 1.6157...761, 0.49524868, 0.40522733,
        0.18980375, 0.37422144, 0.06718525, 0.4119108 , 0.6646227 ]],
      dtype=float32)
desired = array([[0.5288711 , 0.6892013 , 0.5808606 , 0.52508366, 0.40826035,
        0.62242407, 0.42168647, 0.8593684 , 0.9286...501, 0.38003805, 0.31095853,
        0.14564934, 0.2871656 , 0.05155582, 0.31608725, 0.5100103 ]],
      dtype=float32)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 90 / 90 (100%)
E       Max absolute difference: 0.68712395
E       Max relative difference: 1.0379322
E        x: array([[0.920194, 1.199155, 1.010651, 0.913604, 0.71034 , 1.082968,
E               0.733701, 1.495233, 1.61577 , 0.642915],
E              [0.762956, 0.509676, 0.547403, 0.891963, 0.068455, 0.083963,...
E        y: array([[0.528871, 0.689201, 0.580861, 0.525084, 0.40826 , 0.622424,
E               0.421686, 0.859368, 0.928646, 0.369508],
E              [0.706039, 0.471654, 0.506567, 0.825422, 0.063348, 0.0777  ,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is f
_ TestDgmm_param_14_{ordera='F', orderc='F', shape=(10, 9), side='L'}.test_dgmm_incx_minus_one _

self = <<cupy_tests.test_cublas.TestDgmm_param_14_{ordera='F', orderc='F', shape=(10, 9), side='L'} testMethod=test_dgmm_incx_minus_one>  parameter: {'ordera': 'F', 'orderc': 'F', 'shape': (10, 9), 'side': 'L'}>
dtype = <class 'numpy.float32'>

    @testing.for_dtypes('fdFD')
    def test_dgmm_incx_minus_one(self, dtype):
        if self.orderc != 'F':
            raise unittest.SkipTest()
        self._setup(dtype)
        if self.side == 'L':
            ref = cupy.diag(self.x[::-1]) @ self.a
        elif self.side == 'R':
            ref = self.a @ cupy.diag(self.x[::-1])
        c = cublas.dgmm(self.side, self.a, self.x, incx=-1)
>       cupy.testing.assert_allclose(c, ref, rtol=self.tol, atol=self.tol)

tests/cupy_tests/test_cublas.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0.5288711 , 0.6892013 , 0.5808606 , 0.52508366, 0.40826035,
        0.62242407, 0.42168647, 0.8593684 , 0.9286....12011283, 1.2966179 , 1.0609316 , 0.49692798,
        0.9797547 , 0.1758987 , 1.0784297 , 1.7400585 ]], dtype=float32)
desired = array([[0.21043788, 0.27423328, 0.23112449, 0.20893084, 0.16244683,
        0.24766262, 0.1677891 , 0.3419428 , 0.3695....03520501, 0.38003805, 0.31095853, 0.14564934,
        0.2871656 , 0.05155582, 0.31608725, 0.5100103 ]], dtype=float32)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 90 / 90 (100%)
E       Max absolute difference: 1.2300482
E       Max relative difference: 2.4118106
E        x: array([[0.528871, 0.689201, 0.580861, 0.525084, 0.40826 , 0.622424,
E               0.421686, 0.859368, 0.928646],
E              [0.341943, 0.706039, 0.471654, 0.506567, 0.825422, 0.063348,...
E        y: array([[0.210438, 0.274233, 0.231124, 0.208931, 0.162447, 0.247663,
E               0.167789, 0.341943, 0.369508],
E              [0.369508, 0.762956, 0.509676, 0.547403, 0.891963, 0.068455,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is f
________________________ TestMatDescriptor.test_pickle _________________________

self = <cupy_tests.test_cusparse.TestMatDescriptor testMethod=test_pickle>

    def test_pickle(self):
        md = cusparse.MatDescriptor.create()
        md2 = pickle.loads(pickle.dumps(md))
        assert isinstance(md2.descriptor, int)
>       assert md.descriptor != md2.descriptor
E       AssertionError: assert 94701680515216 != 94701680515216
E        +  where 94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff14208a5b0>.descriptor
E        +  and   94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff14202fc70>.descriptor

tests/cupy_tests/test_cusparse.py:27: AssertionError
______________ TestNdarrayToBytes_param_1_{shape=(1,)}.test_item _______________
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <<cupy_tests.core_tests.test_ndarray_conversion.TestNdarrayToBytes_param_1_{shape=(1,)} testMethod=test_item>  parameter: {'shape': (1,)}>
args = (), kw = {'dtype': <class 'numpy.int16'>}, cupy_result = b'\x00\x00'
cupy_error = None, numpy_result = b'\x01\x00', numpy_error = None
message = "Results are not equal:\ncupy: b'\\x00\\x00'\nnumpy: b'\\x01\\x00'"

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
    
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(
                        cupy_error, numpy_error,
                        accept_error=False)
                    return
    
                if cupy_result != numpy_result:
                    message = '''Results are not equal:
    cupy: %s
    numpy: %s''' % (str(cupy_result), str(numpy_result))
>                   raise AssertionError(message)
E                   AssertionError: Results are not equal:
E                   cupy: b'\x00\x00'
E                   numpy: b'\x01\x00'

cupy/testing/helper.py:758: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int16'>
_____________ TestNdarrayToBytes_param_2_{shape=(2, 3)}.test_item ______________
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <<cupy_tests.core_tests.test_ndarray_conversion.TestNdarrayToBytes_param_2_{shape=(2, 3)} testMethod=test_item>  parameter: {'shape': (2, 3)}>
args = (), kw = {'dtype': <class 'numpy.float64'>}
cupy_result = b'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x00\x18@'
cupy_error = None
numpy_result = b'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x00\x18@'
numpy_error = None
message = "Results are not equal:\ncupy: b'\\x00\\x00\\x80?\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x...x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@\\x00\\x00\\x00\\x00\\x00\\x00\\x14@\\x00\\x00\\x00\\x00\\x00\\x00\\x18@'"

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
    
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(
                        cupy_error, numpy_error,
                        accept_error=False)
                    return
    
                if cupy_result != numpy_result:
                    message = '''Results are not equal:
    cupy: %s
    numpy: %s''' % (str(cupy_result), str(numpy_result))
>                   raise AssertionError(message)
E                   AssertionError: Results are not equal:
E                   cupy: b'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x00\x18@'
E                   numpy: b'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x00\x18@'

cupy/testing/helper.py:758: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestArrayIndexingParameterized_param_0_{indexes=(1, 0, 2), shape=(2, 3, 4), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array(15., dtype=float16), y = 15.0, err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 15.
E       Max relative difference: 1.
E        x: array(0., dtype=float16)
E        y: array(15., dtype=float16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float16'>
_ TestArrayIndexingParameterized_param_1_{indexes=(-1, 0, -2), shape=(2, 3, 4), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array(15, dtype=int16), y = 15, err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 15
E       Max relative difference: 1.
E        x: array(0, dtype=int16)
E        y: array(15, dtype=int16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int16'>
_ TestArrayIndexingParameterized_param_2_{indexes=(1, 0, 2), shape=(2, 3, 4), transpose=(2, 0, 1)}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array(10, dtype=int8), y = 10, err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 10
E       Max relative difference: 1.
E        x: array(0, dtype=int8)
E        y: array(10, dtype=int8)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestArrayIndexingParameterized_param_3_{indexes=(-1, 0, -2), shape=(2, 3, 4), transpose=(2, 0, 1)}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array(8., dtype=float16), y = 8.0, err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 6.
E       Max relative difference: 0.75
E        x: array(2., dtype=float16)
E        y: array(8., dtype=float16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float16'>
_ TestArrayIndexingParameterized_param_27_{indexes=(slice(-4, -5, -1),), shape=(10,), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([7.], dtype=float32), y = array([7.], dtype=float32), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 7.
E       Max relative difference: 1.
E        x: array([0.], dtype=float32)
E        y: array([7.], dtype=float32)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float32'>
_ TestArrayIndexingParameterized_param_38_{indexes=(slice(-5, -6, -1),), shape=(10,), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([6.], dtype=float16), y = array([6.], dtype=float16), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 6.
E       Max relative difference: 1.
E        x: array([0.], dtype=float16)
E        y: array([6.], dtype=float16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float16'>
____________________ TestArrayBoolOp.test_bool_one_element _____________________

self = <cupy_tests.core_tests.test_ndarray_unary_op.TestArrayBoolOp testMethod=test_bool_one_element>
dtype = <class 'numpy.int16'>

    @testing.for_all_dtypes()
    def test_bool_one_element(self, dtype):
>       assert bool(cupy.array([1], dtype=dtype))
E       AssertionError: assert False
E        +  where False = bool(array([1], dtype=int16))
E        +    where array([1], dtype=int16) = <function array at 0x7ff177b45670>([1], dtype=<class 'numpy.int16'>)
E        +      where <function array at 0x7ff177b45670> = cupy.array

tests/cupy_tests/core_tests/test_ndarray_unary_op.py:34: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int16'>
____________ TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)}.test_fft ____________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)} testMethod=test_fft>  parameter: {'shape': (64,)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_fft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)}.test_ifft ____________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)} testMethod=test_ifft>  parameter: {'shape': (64,)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_ifft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)}.test_fft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)} testMethod=test_fft>  parameter: {'shape': (4, 16)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_fft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
__________ TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)}.test_ifft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)} testMethod=test_ifft>  parameter: {'shape': (4, 16)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_ifft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)}.test_fft ____________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)} testMethod=test_fft>  parameter: {'shape': (128,)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_fft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)}.test_ifft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)} testMethod=test_ifft>  parameter: {'shape': (128,)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_ifft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)}.test_fft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)} testMethod=test_fft>  parameter: {'shape': (8, 32)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_fft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
__________ TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)}.test_ifft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)} testMethod=test_ifft>  parameter: {'shape': (8, 32)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_ifft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
____________________ TestDeviceHandles.test_cusparse_handle ____________________

self = <cupy_tests.cuda_tests.test_device.TestDeviceHandles testMethod=test_cusparse_handle>

    def test_cusparse_handle(self):
>       self._check_handle(cuda.device.get_cusparse_handle)

tests/cupy_tests/cuda_tests/test_device.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy_tests.cuda_tests.test_device.TestDeviceHandles testMethod=test_cusparse_handle>
func = <built-in function get_cusparse_handle>

    def _check_handle(self, func):
        handles = [func(), None, None]
    
        def _subthread():
            handles[1] = func()
            handles[2] = func()
    
        t = threading.Thread(target=_subthread)
        t.start()
        t.join()
        assert handles[0] is not None
>       assert handles[0] != handles[1]
E       AssertionError: assert 140676145564960 != 140676145564960

tests/cupy_tests/cuda_tests/test_device.py:136: AssertionError
_ TestCUDAarray_param_0_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_0_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_1_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_1_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_2_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_2_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_3_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_3_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_4_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_4_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_5_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_5_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_6_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_6_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_7_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_7_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_8_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_8_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_9_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_9_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_10_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_10_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, strea...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_11_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_11_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_12_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_12_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_13_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_13_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, strea...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_14_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_14_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, strea...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_15_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_15_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_16_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_16_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_17_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_17_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, strea...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_18_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_18_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, strea...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_19_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_19_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_20_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_20_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_21_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_21_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, strea...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_22_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_22_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, strea...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_23_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_23_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_24_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_24_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=T...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_25_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_25_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=T...>  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_26_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_26_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=F... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_27_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_27_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=F...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_28_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_28_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=T...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_29_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_29_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=T...>  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_30_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_30_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=F... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_31_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_31_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=F...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_32_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_32_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=T...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_33_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_33_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=T...>  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_34_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_34_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=F... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_35_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_35_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=F...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_36_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_36_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_37_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_37_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_38_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_38_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_39_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_39_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_40_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_40_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_41_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_41_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_42_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_42_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_43_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_43_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_44_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_44_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_45_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_45_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_46_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_46_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_47_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_47_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_48_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_48_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_49_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_49_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_50_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_50_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_51_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_51_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_52_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_52_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_53_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_53_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_54_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_54_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_55_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_55_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_56_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_56_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_57_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_57_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_58_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_58_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_59_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_59_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_60_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_60_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_61_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_61_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_62_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_62_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_63_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_63_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_64_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_64_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_65_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_65_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_66_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_66_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_67_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_67_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_68_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_68_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_69_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_69_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_70_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_70_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_71_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_71_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_72_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_72_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_73_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_73_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_74_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_74_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_75_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_75_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_76_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_76_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_77_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_77_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_78_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_78_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_79_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_79_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_80_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_80_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_81_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_81_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_82_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_82_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_83_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_83_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_84_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_84_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_85_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_85_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_86_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_86_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_87_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_87_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_88_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_88_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_89_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_89_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_90_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_90_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_91_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_91_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_92_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_92_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_93_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_93_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_94_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_94_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_95_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_95_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_96_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_96_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_97_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_97_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_98_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_98_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stre...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_99_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_99_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_100_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_100_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_101_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_101_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_102_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_102_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_103_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_103_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_104_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_104_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_105_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_105_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_106_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_106_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_107_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_107_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_108_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_108_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_109_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_109_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_110_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_110_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_111_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_111_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_112_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_112_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_113_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_113_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_114_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_114_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_115_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_115_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_116_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_116_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_117_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_117_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_118_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_118_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_119_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_119_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_120_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_120_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_121_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_121_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream...  parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_122_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_122_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_123_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_123_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_124_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_124_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_125_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_125_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream...  parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_126_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_126_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_127_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_127_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_128_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_128_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_129_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_129_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream...  parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_130_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_130_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_131_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_131_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_132_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_132_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_133_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_133_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_134_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_134_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_135_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_135_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_136_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_136_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_137_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_137_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_138_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_138_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_139_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_139_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_140_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_140_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_141_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_141_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_142_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_142_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_143_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_143_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_144_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_144_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_145_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_145_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_146_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_146_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_147_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_147_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_148_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_148_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_149_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_149_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_150_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_150_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_151_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_151_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_152_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_152_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_153_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_153_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_154_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_154_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_155_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_155_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_156_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_156_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_157_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_157_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_158_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_158_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_159_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_159_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_160_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_160_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_161_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_161_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_162_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_162_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_163_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_163_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_164_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_164_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_165_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_165_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_166_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_166_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_167_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_167_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_168_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_168_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_169_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_169_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_170_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_170_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_171_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_171_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_172_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_172_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_173_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_173_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_174_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_174_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_175_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_175_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_176_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_176_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_177_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_177_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_178_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_178_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_179_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_179_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_180_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_180_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_181_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_181_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_182_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_182_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_183_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_183_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_184_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_184_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_185_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_185_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_186_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_186_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_187_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_187_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_188_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_188_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_189_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_189_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_190_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_190_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_191_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_191_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_192_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_192_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_193_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_193_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_194_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_194_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_195_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_195_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_196_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_196_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_197_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_197_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_198_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_198_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_199_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_199_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_200_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_200_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_201_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_201_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_202_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_202_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_203_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_203_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_204_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_204_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_205_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_205_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_206_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_206_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_207_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_207_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_208_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_208_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_209_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_209_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_210_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_210_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_211_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_211_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_212_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_212_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_213_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_213_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_214_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_214_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_215_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_215_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_216_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_216_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_217_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_217_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, strea... parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_218_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_218_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, strea...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_219_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_219_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_220_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_220_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_221_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_221_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, strea... parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_222_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_222_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, strea...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_223_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_223_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_224_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_224_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_225_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_225_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, strea... parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_226_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_226_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, strea...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_227_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_227_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_228_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_228_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_229_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_229_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_230_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_230_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_231_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_231_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_232_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_232_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_233_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_233_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_234_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_234_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_235_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_235_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_236_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_236_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_237_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_237_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_238_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_238_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_239_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_239_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_240_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_240_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_241_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_241_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_242_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_242_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_243_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_243_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_244_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_244_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_245_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_245_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_246_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_246_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_247_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_247_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_248_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_248_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_249_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_249_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_250_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_250_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_251_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_251_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_252_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_252_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_253_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_253_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_254_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_254_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_255_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_255_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_256_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_256_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_257_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_257_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_258_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_258_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_259_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_259_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_260_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_260_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_261_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_261_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_262_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_262_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_263_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_263_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_264_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_264_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_265_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_265_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_266_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_266_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_267_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_267_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_268_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_268_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_269_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_269_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_270_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_270_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_271_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_271_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_272_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_272_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_273_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_273_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_274_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_274_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_275_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_275_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_276_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_276_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_277_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_277_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_278_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_278_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_279_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_279_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_280_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_280_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_281_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_281_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_282_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_282_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_283_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_283_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_284_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_284_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_285_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_285_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_286_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_286_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_287_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_287_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_0_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='object'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_0_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='object'...stMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 0, 0), 'mem_type': 'CUDAarray', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_1_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='reference'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_1_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='referen...ethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 0, 0), 'mem_type': 'CUDAarray', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_2_{dimensions=(64, 0, 0), mem_type='linear', target='object'}.test_fetch_float_texture _

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7ff31052d130>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
>           nvrtc.compileProgram(self.ptr, options)

cupy/cuda/compiler.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   cpdef compileProgram(intptr_t prog, options):

cupy_backends/cuda/libs/nvrtc.pyx:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   check_status(status)

cupy_backends/cuda/libs/nvrtc.pyx:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise NVRTCError(status)
E   cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

cupy_backends/cuda/libs/nvrtc.pyx:62: NVRTCError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_2_{dimensions=(64, 0, 0), mem_type='linear', target='object'} testMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 0, 0), 'mem_type': 'linear', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
            arr = CUDAarray(ch, width, height, depth)
            expected_output = cupy.zeros_like(tex_data)
            assert expected_output.flags['C_CONTIGUOUS']
            # test bidirectional copy
            arr.copy_from(tex_data)
            arr.copy_to(expected_output)
        else:  # linear are pitch2D are backed by ndarray
            arr = tex_data
            expected_output = tex_data
    
        # create resource and texture descriptors
        if self.mem_type == 'CUDAarray':
            res = ResourceDescriptor(runtime.cudaResourceTypeArray, cuArr=arr)
        elif self.mem_type == 'linear':
            res = ResourceDescriptor(runtime.cudaResourceTypeLinear,
                                     arr=arr,
                                     chDesc=ch,
                                     sizeInBytes=arr.size*arr.dtype.itemsize)
        else:  # pitch2D
            # In this case, we rely on the fact that the hand-picked array
            # shape meets the alignment requirement. This is CUDA's limitation,
            # see CUDA Runtime API reference guide. "TexturePitchAlignment" is
            # assumed to be 32, which should be applicable for most devices.
            res = ResourceDescriptor(runtime.cudaResourceTypePitch2D,
                                     arr=arr,
                                     chDesc=ch,
                                     width=width,
                                     height=height,
                                     pitchInBytes=width*arr.dtype.itemsize)
        address_mode = (runtime.cudaAddressModeClamp,
                        runtime.cudaAddressModeClamp)
        tex = TextureDescriptor(address_mode, runtime.cudaFilterModePoint,
                                runtime.cudaReadModeElementType)
    
        if self.target == 'object':
            # create a texture object
            texobj = TextureObject(res, tex)
            mod = cupy.RawModule(code=source_texobj)
        else:  # self.target == 'reference'
            mod = cupy.RawModule(code=source_texref)
            texref_name = 'texref'
            texref_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
            texrefPtr = mod.get_texref(texref_name)
            # bind texture ref to resource
            texref = TextureReference(texrefPtr, res, tex)  # noqa
    
        # get and launch the kernel
        ker_name = 'copyKernel'
        ker_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
        ker_name += 'fetch' if self.mem_type == 'linear' else ''
>       ker = mod.get_function(ker_name)

tests/cupy_tests/cuda_tests/test_texture.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/raw.pyx:485: in cupy.core.raw.RawModule.get_function
    func = ker.kernel  # noqa
cupy/core/raw.pyx:96: in cupy.core.raw.RawKernel.kernel.__get__
    return self._kernel()
cupy/core/raw.pyx:113: in cupy.core.raw.RawKernel._kernel
    mod = _get_raw_module(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/raw.pyx:547: in cupy.core.raw._get_raw_module
    mod = cupy.core.core.compile_with_cache(
cupy/core/core.pyx:1956: in cupy.core.core.compile_with_cache
    cpdef function.Module compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7ff31052d130>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           cupy.cuda.compiler.CompileException: /tmp/comgr-c34539/input/CompileSource:5357:35: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                             cudaTextureObject_t texObj,
E                                             ^~~~~~~~~~~~~~~~~~~
E                                             hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-c34539/input/CompileSource:5368:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-c34539/input/CompileSource:5380:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-c34539/input/CompileSource:5394:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-c34539/input/CompileSource:5413:34: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                            cudaTextureObject_t texObj,
E                                            ^~~~~~~~~~~~~~~~~~~
E                                            hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           5 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: CompileException
_ TestTexture_param_3_{dimensions=(64, 0, 0), mem_type='linear', target='reference'}.test_fetch_float_texture _

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7fe8e87fa7c0>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
>           nvrtc.compileProgram(self.ptr, options)

cupy/cuda/compiler.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   cpdef compileProgram(intptr_t prog, options):

cupy_backends/cuda/libs/nvrtc.pyx:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   check_status(status)

cupy_backends/cuda/libs/nvrtc.pyx:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise NVRTCError(status)
E   cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

cupy_backends/cuda/libs/nvrtc.pyx:62: NVRTCError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_3_{dimensions=(64, 0, 0), mem_type='linear', target='reference'...stMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 0, 0), 'mem_type': 'linear', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
            arr = CUDAarray(ch, width, height, depth)
            expected_output = cupy.zeros_like(tex_data)
            assert expected_output.flags['C_CONTIGUOUS']
            # test bidirectional copy
            arr.copy_from(tex_data)
            arr.copy_to(expected_output)
        else:  # linear are pitch2D are backed by ndarray
            arr = tex_data
            expected_output = tex_data
    
        # create resource and texture descriptors
        if self.mem_type == 'CUDAarray':
            res = ResourceDescriptor(runtime.cudaResourceTypeArray, cuArr=arr)
        elif self.mem_type == 'linear':
            res = ResourceDescriptor(runtime.cudaResourceTypeLinear,
                                     arr=arr,
                                     chDesc=ch,
                                     sizeInBytes=arr.size*arr.dtype.itemsize)
        else:  # pitch2D
            # In this case, we rely on the fact that the hand-picked array
            # shape meets the alignment requirement. This is CUDA's limitation,
            # see CUDA Runtime API reference guide. "TexturePitchAlignment" is
            # assumed to be 32, which should be applicable for most devices.
            res = ResourceDescriptor(runtime.cudaResourceTypePitch2D,
                                     arr=arr,
                                     chDesc=ch,
                                     width=width,
                                     height=height,
                                     pitchInBytes=width*arr.dtype.itemsize)
        address_mode = (runtime.cudaAddressModeClamp,
                        runtime.cudaAddressModeClamp)
        tex = TextureDescriptor(address_mode, runtime.cudaFilterModePoint,
                                runtime.cudaReadModeElementType)
    
        if self.target == 'object':
            # create a texture object
            texobj = TextureObject(res, tex)
            mod = cupy.RawModule(code=source_texobj)
        else:  # self.target == 'reference'
            mod = cupy.RawModule(code=source_texref)
            texref_name = 'texref'
            texref_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
>           texrefPtr = mod.get_texref(texref_name)

tests/cupy_tests/cuda_tests/test_texture.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/raw.pyx:497: in cupy.core.raw.RawModule.get_texref
    return self.module.get_texref(name)
cupy/core/raw.pyx:394: in cupy.core.raw.RawModule.module.__get__
    return self._module()
cupy/core/raw.pyx:402: in cupy.core.raw.RawModule._module
    mod = _get_raw_module(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/raw.pyx:547: in cupy.core.raw._get_raw_module
    mod = cupy.core.core.compile_with_cache(
cupy/core/core.pyx:1956: in cupy.core.core.compile_with_cache
    cpdef function.Module compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7fe8e87fa7c0>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           cupy.cuda.compiler.CompileException: /tmp/comgr-c985dc/input/CompileSource:5356:16: error: use of undeclared identifier 'cudaTextureType1D'
E           texture<float, cudaTextureType1D, cudaReadModeElementType> texref1D;
E                          ^
E           /tmp/comgr-c985dc/input/CompileSource:5357:16: error: use of undeclared identifier 'cudaTextureType2D'
E           texture<float, cudaTextureType2D, cudaReadModeElementType> texref2D;
E                          ^
E           /tmp/comgr-c985dc/input/CompileSource:5358:16: error: use of undeclared identifier 'cudaTextureType3D'
E           texture<float, cudaTextureType3D, cudaReadModeElementType> texref3D;
E                          ^
E           /tmp/comgr-c985dc/input/CompileSource:5359:17: error: use of undeclared identifier 'cudaTextureType3D'
E           texture<float4, cudaTextureType3D, cudaReadModeElementType> texref3Df4;
E                           ^
E           4 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: CompileException
_ TestTexture_param_6_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='object'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_6_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='object...tMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 0), 'mem_type': 'CUDAarray', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_7_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='reference'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_7_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='refere...thod=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 0), 'mem_type': 'CUDAarray', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_10_{dimensions=(64, 32, 0), mem_type='pitch2D', target='object'}.test_fetch_float_texture _

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7fe8e66c5880>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
>           nvrtc.compileProgram(self.ptr, options)

cupy/cuda/compiler.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   cpdef compileProgram(intptr_t prog, options):

cupy_backends/cuda/libs/nvrtc.pyx:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   check_status(status)

cupy_backends/cuda/libs/nvrtc.pyx:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise NVRTCError(status)
E   cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

cupy_backends/cuda/libs/nvrtc.pyx:62: NVRTCError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_10_{dimensions=(64, 32, 0), mem_type='pitch2D', target='object'} testMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 0), 'mem_type': 'pitch2D', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
            arr = CUDAarray(ch, width, height, depth)
            expected_output = cupy.zeros_like(tex_data)
            assert expected_output.flags['C_CONTIGUOUS']
            # test bidirectional copy
            arr.copy_from(tex_data)
            arr.copy_to(expected_output)
        else:  # linear are pitch2D are backed by ndarray
            arr = tex_data
            expected_output = tex_data
    
        # create resource and texture descriptors
        if self.mem_type == 'CUDAarray':
            res = ResourceDescriptor(runtime.cudaResourceTypeArray, cuArr=arr)
        elif self.mem_type == 'linear':
            res = ResourceDescriptor(runtime.cudaResourceTypeLinear,
                                     arr=arr,
                                     chDesc=ch,
                                     sizeInBytes=arr.size*arr.dtype.itemsize)
        else:  # pitch2D
            # In this case, we rely on the fact that the hand-picked array
            # shape meets the alignment requirement. This is CUDA's limitation,
            # see CUDA Runtime API reference guide. "TexturePitchAlignment" is
            # assumed to be 32, which should be applicable for most devices.
            res = ResourceDescriptor(runtime.cudaResourceTypePitch2D,
                                     arr=arr,
                                     chDesc=ch,
                                     width=width,
                                     height=height,
                                     pitchInBytes=width*arr.dtype.itemsize)
        address_mode = (runtime.cudaAddressModeClamp,
                        runtime.cudaAddressModeClamp)
        tex = TextureDescriptor(address_mode, runtime.cudaFilterModePoint,
                                runtime.cudaReadModeElementType)
    
        if self.target == 'object':
            # create a texture object
            texobj = TextureObject(res, tex)
            mod = cupy.RawModule(code=source_texobj)
        else:  # self.target == 'reference'
            mod = cupy.RawModule(code=source_texref)
            texref_name = 'texref'
            texref_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
            texrefPtr = mod.get_texref(texref_name)
            # bind texture ref to resource
            texref = TextureReference(texrefPtr, res, tex)  # noqa
    
        # get and launch the kernel
        ker_name = 'copyKernel'
        ker_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
        ker_name += 'fetch' if self.mem_type == 'linear' else ''
>       ker = mod.get_function(ker_name)

tests/cupy_tests/cuda_tests/test_texture.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/raw.pyx:485: in cupy.core.raw.RawModule.get_function
    func = ker.kernel  # noqa
cupy/core/raw.pyx:96: in cupy.core.raw.RawKernel.kernel.__get__
    return self._kernel()
cupy/core/raw.pyx:113: in cupy.core.raw.RawKernel._kernel
    mod = _get_raw_module(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/raw.pyx:547: in cupy.core.raw._get_raw_module
    mod = cupy.core.core.compile_with_cache(
cupy/core/core.pyx:1956: in cupy.core.core.compile_with_cache
    cpdef function.Module compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7fe8e66c5880>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           cupy.cuda.compiler.CompileException: /tmp/comgr-af763b/input/CompileSource:5357:35: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                             cudaTextureObject_t texObj,
E                                             ^~~~~~~~~~~~~~~~~~~
E                                             hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-af763b/input/CompileSource:5368:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-af763b/input/CompileSource:5380:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-af763b/input/CompileSource:5394:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-af763b/input/CompileSource:5413:34: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                            cudaTextureObject_t texObj,
E                                            ^~~~~~~~~~~~~~~~~~~
E                                            hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           5 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: CompileException
_ TestTexture_param_11_{dimensions=(64, 32, 0), mem_type='pitch2D', target='reference'}.test_fetch_float_texture _

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7fe8e61fc040>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
>           nvrtc.compileProgram(self.ptr, options)

cupy/cuda/compiler.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   cpdef compileProgram(intptr_t prog, options):

cupy_backends/cuda/libs/nvrtc.pyx:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   check_status(status)

cupy_backends/cuda/libs/nvrtc.pyx:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise NVRTCError(status)
E   cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

cupy_backends/cuda/libs/nvrtc.pyx:62: NVRTCError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_11_{dimensions=(64, 32, 0), mem_type='pitch2D', target='referen...Method=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 0), 'mem_type': 'pitch2D', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
            arr = CUDAarray(ch, width, height, depth)
            expected_output = cupy.zeros_like(tex_data)
            assert expected_output.flags['C_CONTIGUOUS']
            # test bidirectional copy
            arr.copy_from(tex_data)
            arr.copy_to(expected_output)
        else:  # linear are pitch2D are backed by ndarray
            arr = tex_data
            expected_output = tex_data
    
        # create resource and texture descriptors
        if self.mem_type == 'CUDAarray':
            res = ResourceDescriptor(runtime.cudaResourceTypeArray, cuArr=arr)
        elif self.mem_type == 'linear':
            res = ResourceDescriptor(runtime.cudaResourceTypeLinear,
                                     arr=arr,
                                     chDesc=ch,
                                     sizeInBytes=arr.size*arr.dtype.itemsize)
        else:  # pitch2D
            # In this case, we rely on the fact that the hand-picked array
            # shape meets the alignment requirement. This is CUDA's limitation,
            # see CUDA Runtime API reference guide. "TexturePitchAlignment" is
            # assumed to be 32, which should be applicable for most devices.
            res = ResourceDescriptor(runtime.cudaResourceTypePitch2D,
                                     arr=arr,
                                     chDesc=ch,
                                     width=width,
                                     height=height,
                                     pitchInBytes=width*arr.dtype.itemsize)
        address_mode = (runtime.cudaAddressModeClamp,
                        runtime.cudaAddressModeClamp)
        tex = TextureDescriptor(address_mode, runtime.cudaFilterModePoint,
                                runtime.cudaReadModeElementType)
    
        if self.target == 'object':
            # create a texture object
            texobj = TextureObject(res, tex)
            mod = cupy.RawModule(code=source_texobj)
        else:  # self.target == 'reference'
            mod = cupy.RawModule(code=source_texref)
            texref_name = 'texref'
            texref_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
>           texrefPtr = mod.get_texref(texref_name)

tests/cupy_tests/cuda_tests/test_texture.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/raw.pyx:497: in cupy.core.raw.RawModule.get_texref
    return self.module.get_texref(name)
cupy/core/raw.pyx:394: in cupy.core.raw.RawModule.module.__get__
    return self._module()
cupy/core/raw.pyx:402: in cupy.core.raw.RawModule._module
    mod = _get_raw_module(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/raw.pyx:547: in cupy.core.raw._get_raw_module
    mod = cupy.core.core.compile_with_cache(
cupy/core/core.pyx:1956: in cupy.core.core.compile_with_cache
    cpdef function.Module compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7fe8e61fc040>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           cupy.cuda.compiler.CompileException: /tmp/comgr-a256bd/input/CompileSource:5356:16: error: use of undeclared identifier 'cudaTextureType1D'
E           texture<float, cudaTextureType1D, cudaReadModeElementType> texref1D;
E                          ^
E           /tmp/comgr-a256bd/input/CompileSource:5357:16: error: use of undeclared identifier 'cudaTextureType2D'
E           texture<float, cudaTextureType2D, cudaReadModeElementType> texref2D;
E                          ^
E           /tmp/comgr-a256bd/input/CompileSource:5358:16: error: use of undeclared identifier 'cudaTextureType3D'
E           texture<float, cudaTextureType3D, cudaReadModeElementType> texref3D;
E                          ^
E           /tmp/comgr-a256bd/input/CompileSource:5359:17: error: use of undeclared identifier 'cudaTextureType3D'
E           texture<float4, cudaTextureType3D, cudaReadModeElementType> texref3Df4;
E                           ^
E           4 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: CompileException
_ TestTexture_param_12_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='object'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_12_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='obje...Method=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 19), 'mem_type': 'CUDAarray', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_13_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='reference'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_13_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='refe...hod=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 19), 'mem_type': 'CUDAarray', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
__ TestTextureVectorType_param_0_{target='object'}.test_fetch_float4_texture ___

self = <<cupy_tests.cuda_tests.test_texture.TestTextureVectorType_param_0_{target='object'} testMethod=test_fetch_float4_texture>  parameter: {'target': 'object'}>

    def test_fetch_float4_texture(self):
        width = 47
        height = 39
        depth = 11
        n_channel = 4
    
        # generate input data and allocate output buffer
        in_shape = (depth, height, n_channel*width)
        out_shape = (depth, height, width)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(in_shape, dtype=cupy.float32)
        real_output_x = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_y = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_z = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_w = cupy.zeros(out_shape, dtype=cupy.float32)
        ch = ChannelFormatDescriptor(32, 32, 32, 32,
                                     runtime.cudaChannelFormatKindFloat)
>       arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:366: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTextureVectorType_param_1_{target='reference'}.test_fetch_float4_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTextureVectorType_param_1_{target='reference'} testMethod=test_fetch_float4_texture>  parameter: {'target': 'reference'}>

    def test_fetch_float4_texture(self):
        width = 47
        height = 39
        depth = 11
        n_channel = 4
    
        # generate input data and allocate output buffer
        in_shape = (depth, height, n_channel*width)
        out_shape = (depth, height, width)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(in_shape, dtype=cupy.float32)
        real_output_x = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_y = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_z = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_w = cupy.zeros(out_shape, dtype=cupy.float32)
        ch = ChannelFormatDescriptor(32, 32, 32, 32,
                                     runtime.cudaChannelFormatKindFloat)
>       arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:366: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_____ TestSurface_param_0_{dimensions=(64, 0, 0)}.test_write_float_surface _____

self = <<cupy_tests.cuda_tests.test_texture.TestSurface_param_0_{dimensions=(64, 0, 0)} testMethod=test_write_float_surface>  parameter: {'dimensions': (64, 0, 0)}>

    def test_write_float_surface(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and surface memory
        real_output = cupy.zeros(shape, dtype=cupy.float32)
        assert real_output.flags['C_CONTIGUOUS']
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        expected_output = cupy.arange(numpy.prod(shape), dtype=cupy.float32)
        expected_output = expected_output.reshape(shape) * 3.0
        assert expected_output.flags['C_CONTIGUOUS']
    
        # create resource descriptor
        # note that surface memory only support CUDA array
>       arr = CUDAarray(ch, width, height, depth,
                        runtime.cudaArraySurfaceLoadStore)

tests/cupy_tests/cuda_tests/test_texture.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
____ TestSurface_param_1_{dimensions=(64, 32, 0)}.test_write_float_surface _____

self = <<cupy_tests.cuda_tests.test_texture.TestSurface_param_1_{dimensions=(64, 32, 0)} testMethod=test_write_float_surface>  parameter: {'dimensions': (64, 32, 0)}>

    def test_write_float_surface(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and surface memory
        real_output = cupy.zeros(shape, dtype=cupy.float32)
        assert real_output.flags['C_CONTIGUOUS']
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        expected_output = cupy.arange(numpy.prod(shape), dtype=cupy.float32)
        expected_output = expected_output.reshape(shape) * 3.0
        assert expected_output.flags['C_CONTIGUOUS']
    
        # create resource descriptor
        # note that surface memory only support CUDA array
>       arr = CUDAarray(ch, width, height, depth,
                        runtime.cudaArraySurfaceLoadStore)

tests/cupy_tests/cuda_tests/test_texture.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
____ TestSurface_param_2_{dimensions=(64, 32, 32)}.test_write_float_surface ____

self = <<cupy_tests.cuda_tests.test_texture.TestSurface_param_2_{dimensions=(64, 32, 32)} testMethod=test_write_float_surface>  parameter: {'dimensions': (64, 32, 32)}>

    def test_write_float_surface(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and surface memory
        real_output = cupy.zeros(shape, dtype=cupy.float32)
        assert real_output.flags['C_CONTIGUOUS']
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        expected_output = cupy.arange(numpy.prod(shape), dtype=cupy.float32)
        expected_output = expected_output.reshape(shape) * 3.0
        assert expected_output.flags['C_CONTIGUOUS']
    
        # create resource descriptor
        # note that surface memory only support CUDA array
>       arr = CUDAarray(ch, width, height, depth,
                        runtime.cudaArraySurfaceLoadStore)

tests/cupy_tests/cuda_tests/test_texture.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
___________________________ TestIX_.test_ix_ndarray ____________________________
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[2, 3]], dtype=int32), y = array([[2, 3]], dtype=int32), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 1065353213
E       Max relative difference: 3.55117738e+08
E        x: array([[         0, 1065353216]], dtype=int32)
E        y: array([[2, 3]], dtype=int32)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int32'>
_ TestPoly1dMathArithmetic_param_0_{fname='add', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_0_{fname='add', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'add', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_1_{fname='add', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_1_{fname='add', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'add', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_2_{fname='add', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_2_{fname='add', type_l='python_scalar', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'add', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_3_{fname='add', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_3_{fname='add', type_l='numpy_scalar', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'add', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_4_{fname='subtract', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_4_{fname='subtract', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'subtract', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_5_{fname='subtract', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_5_{fname='subtract', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'subtract', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_6_{fname='subtract', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_6_{fname='subtract', type_l='python_scalar', typ...'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'subtract', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_7_{fname='subtract', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_7_{fname='subtract', type_l='numpy_scalar', type...d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'subtract', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_8_{fname='multiply', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_8_{fname='multiply', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'multiply', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_9_{fname='multiply', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_9_{fname='multiply', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'multiply', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_10_{fname='multiply', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_10_{fname='multiply', type_l='python_scalar', ty...'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'multiply', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_11_{fname='multiply', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_11_{fname='multiply', type_l='numpy_scalar', typ...d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'multiply', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_12_{fname='divide', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_12_{fname='divide', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'divide', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_13_{fname='divide', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_13_{fname='divide', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'divide', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_14_{fname='divide', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_14_{fname='divide', type_l='python_scalar', type...1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'divide', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_15_{fname='divide', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_15_{fname='divide', type_l='numpy_scalar', type_...y1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'divide', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_16_{fname='power', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_16_{fname='power', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'power', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_17_{fname='power', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_17_{fname='power', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'power', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_18_{fname='power', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_18_{fname='power', type_l='python_scalar', type_...y1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'power', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_19_{fname='power', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_19_{fname='power', type_l='numpy_scalar', type_r...ly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'power', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyArithmeticDiffTypes_param_2_{fname='polymul'}.test_polyroutine_diff_types_array _
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([ 1.74386169e-05  +1.999987j, -8.70033273e-06  +8.000005j,
        3.22509732e-05 +20.j      , -1.31668885e-05 +...,  1.34253614e-05+211.99995j ,
        1.82537897e-05+169.99998j ,  7.00168357e-06 +99.99997j ],
      dtype=complex64)
desired = array([0.  +2.j, 0.  +8.j, 0. +20.j, 0. +40.j, 0. +70.j, 0.+100.j,
       0.+130.j, 0.+160.j, 0.+190.j, 0.+220.j, 0.+228.j, 0.+212.j,
       0.+170.j, 0.+100.j], dtype=complex64)
rtol = 1e-05, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 14 (7.14%)
E       Max absolute difference: 6.121e-05
E       Max relative difference: 1.0873644e-05
E        x: array([ 1.743862e-05  +1.999987j, -8.700333e-06  +8.000005j,
E               3.225097e-05 +20.j      , -1.316689e-05 +40.00001j ,
E               1.074560e-05 +69.999985j,  5.520945e-07 +99.99997j ,...
E        y: array([0.  +2.j, 0.  +8.j, 0. +20.j, 0. +40.j, 0. +70.j, 0.+100.j,
E              0.+130.j, 0.+160.j, 0.+190.j, 0.+220.j, 0.+228.j, 0.+212.j,
E              0.+170.j, 0.+100.j], dtype=complex64)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.complex64'>, 'dtype2': <class 'numpy.complex64'>}
_ TestPolyArithmeticDiffTypes_param_2_{fname='polymul'}.test_polyroutine_diff_types_poly1d _
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([ 1.74386169e-05  +1.999987j, -8.70033273e-06  +8.000005j,
        3.22509732e-05 +20.j      , -1.31668885e-05 +...,  1.34253614e-05+211.99995j ,
        1.82537897e-05+169.99998j ,  7.00168357e-06 +99.99997j ],
      dtype=complex64)
desired = array([0.  +2.j, 0.  +8.j, 0. +20.j, 0. +40.j, 0. +70.j, 0.+100.j,
       0.+130.j, 0.+160.j, 0.+190.j, 0.+220.j, 0.+228.j, 0.+212.j,
       0.+170.j, 0.+100.j], dtype=complex64)
rtol = 1e-05, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 14 (7.14%)
E       Max absolute difference: 6.121e-05
E       Max relative difference: 1.0873644e-05
E        x: array([ 1.743862e-05  +1.999987j, -8.700333e-06  +8.000005j,
E               3.225097e-05 +20.j      , -1.316689e-05 +40.00001j ,
E               1.074560e-05 +69.999985j,  5.520945e-07 +99.99997j ,...
E        y: array([0.  +2.j, 0.  +8.j, 0. +20.j, 0. +40.j, 0. +70.j, 0.+100.j,
E              0.+130.j, 0.+160.j, 0.+190.j, 0.+220.j, 0.+228.j, 0.+212.j,
E              0.+170.j, 0.+100.j], dtype=complex64)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.complex64'>, 'dtype2': <class 'numpy.complex64'>}
_ TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shap... testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': None, 'shape1': (3,), 'shape2': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shap...testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': None, 'shape1': (3,), 'shape2': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shap...estMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': None, 'shape1': (3,), 'shape2': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shap...stMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': None, 'shape1': (3,), 'shape2': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape...} testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 0.5, 'shape1': (3,), 'shape2': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape... testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 0.5, 'shape1': (3,), 'shape2': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape...testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 0.5, 'shape1': (3,), 'shape2': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape...estMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 0.5, 'shape1': (3,), 'shape2': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), sha...testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 1e-15, 'shape1': (3,), 'shape2': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), sha...estMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 1e-15, 'shape1': (3,), 'shape2': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), sh...stMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 1e-15, 'shape1': (3,), 'shape2': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), sh...tMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 1e-15, 'shape1': (3,), 'shape2': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_0_{cov='unscaled', deg=0, rcond=None, shape=(3,), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_0_{cov='unscaled', deg=0, rcond=None, shape=(3,), weig...testMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': None, 'shape': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.41388175]), desired = array([2.41388175]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.8277635
E       Max relative difference: 2.
E        x: array([-2.413882])
E        y: array([2.413882])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_1_{cov='unscaled', deg=0, rcond=None, shape=(3,), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_1_{cov='unscaled', deg=0, rcond=None, shape=(3,), weig...estMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': None, 'shape': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_2_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_2_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), we...stMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': None, 'shape': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3.8277635, -4.8277635]])
desired = array([[3.8277635, 4.8277635]]), rtol = 1e-05, atol = 0, err_msg = ''
verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 9.65552699
E       Max relative difference: 2.
E        x: array([[-3.827763, -4.827763]])
E        y: array([[3.827763, 4.827763]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_3_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_3_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), we...tMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': None, 'shape': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_4_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_4_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), wei...estMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': 1e-15, 'shape': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.41388175]), desired = array([2.41388175]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.8277635
E       Max relative difference: 2.
E        x: array([-2.413882])
E        y: array([2.413882])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_5_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_5_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), wei...stMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': 1e-15, 'shape': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_6_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_6_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), w...tMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': 1e-15, 'shape': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3.8277635, -4.8277635]])
desired = array([[3.8277635, 4.8277635]]), rtol = 1e-05, atol = 0, err_msg = ''
verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 9.65552699
E       Max relative difference: 2.
E        x: array([[-3.827763, -4.827763]])
E        y: array([[3.827763, 4.827763]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_7_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_7_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), w...Method=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': 1e-15, 'shape': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_16_{cov=True, deg=0, rcond=None, shape=(3,), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_16_{cov=True, deg=0, rcond=None, shape=(3,), weighted=True} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': None, 'shape': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.41388175]), desired = array([2.41388175]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.8277635
E       Max relative difference: 2.
E        x: array([-2.413882])
E        y: array([2.413882])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_17_{cov=True, deg=0, rcond=None, shape=(3,), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_17_{cov=True, deg=0, rcond=None, shape=(3,), weighted=False} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': None, 'shape': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_18_{cov=True, deg=0, rcond=None, shape=(3, 2), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_18_{cov=True, deg=0, rcond=None, shape=(3, 2), weighte...ue} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': None, 'shape': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3.8277635, -4.8277635]])
desired = array([[3.8277635, 4.8277635]]), rtol = 1e-05, atol = 0, err_msg = ''
verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 9.65552699
E       Max relative difference: 2.
E        x: array([[-3.827763, -4.827763]])
E        y: array([[3.827763, 4.827763]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_19_{cov=True, deg=0, rcond=None, shape=(3, 2), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_19_{cov=True, deg=0, rcond=None, shape=(3, 2), weighte...e} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': None, 'shape': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_20_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_20_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=True} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': 1e-15, 'shape': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.41388175]), desired = array([2.41388175]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.8277635
E       Max relative difference: 2.
E        x: array([-2.413882])
E        y: array([2.413882])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_21_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_21_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted...se} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': 1e-15, 'shape': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_22_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_22_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weight...e} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': 1e-15, 'shape': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3.8277635, -4.8277635]])
desired = array([[3.8277635, 4.8277635]]), rtol = 1e-05, atol = 0, err_msg = ''
verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 9.65552699
E       Max relative difference: 2.
E        x: array([[-3.827763, -4.827763]])
E        y: array([[3.827763, 4.827763]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_23_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_23_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weight...} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': 1e-15, 'shape': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
__________ TestRootsReal_param_0_{input=[2, -1, -2]}.test_roots_array __________

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsReal_param_0_{input=[2, -1, -2]} testMethod=test_roots_array>  parameter: {'input': [2, -1, -2]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_array(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(a)

tests/cupy_tests/lib_tests/test_polynomial.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3085: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3094: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 764, in test_roots_array
E       out = xp.roots(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3085, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3094, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________ TestRootsReal_param_0_{input=[2, -1, -2]}.test_roots_poly1d __________

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsReal_param_0_{input=[2, -1, -2]} testMethod=test_roots_poly1d>  parameter: {'input': [2, -1, -2]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_poly1d(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(xp.poly1d(a))

tests/cupy_tests/lib_tests/test_polynomial.py:771: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3085: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3094: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 771, in test_roots_poly1d
E       out = xp.roots(xp.poly1d(a))
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3085, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3094, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
__________ TestRootsReal_param_1_{input=[-4, 10, 4]}.test_roots_array __________

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsReal_param_1_{input=[-4, 10, 4]} testMethod=test_roots_array>  parameter: {'input': [-4, 10, 4]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_array(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(a)

tests/cupy_tests/lib_tests/test_polynomial.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3085: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3094: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 764, in test_roots_array
E       out = xp.roots(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3085, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3094, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________ TestRootsReal_param_1_{input=[-4, 10, 4]}.test_roots_poly1d __________

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsReal_param_1_{input=[-4, 10, 4]} testMethod=test_roots_poly1d>  parameter: {'input': [-4, 10, 4]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_poly1d(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(xp.poly1d(a))

tests/cupy_tests/lib_tests/test_polynomial.py:771: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3085: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3094: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 771, in test_roots_poly1d
E       out = xp.roots(xp.poly1d(a))
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3085, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3094, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
____ TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]}.test_roots_array _____

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]} testMethod=test_roots_array>  parameter: {'input': [3j, 1.5j, (-0-3j)]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_complex_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_array(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(a)

tests/cupy_tests/lib_tests/test_polynomial.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3097: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3106: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 785, in test_roots_array
E       out = xp.roots(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3097, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3106, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
____ TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]}.test_roots_poly1d ____

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]} testMethod=test_roots_poly1d>  parameter: {'input': [3j, 1.5j, (-0-3j)]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_complex_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_poly1d(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(xp.poly1d(a))

tests/cupy_tests/lib_tests/test_polynomial.py:792: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3097: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3106: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 792, in test_roots_poly1d
E       out = xp.roots(xp.poly1d(a))
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3097, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3106, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
_________________________ TestPoly1d.test_poly1d_roots _________________________

self = <cupy_tests.lib_tests.test_polynomial.TestPoly1d testMethod=test_poly1d_roots>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_poly1d_roots(self, xp, dtype):
        a = xp.array([-3, -2.5, 3], dtype)
>       out = xp.poly1d(a).roots

tests/cupy_tests/lib_tests/test_polynomial.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_polynomial.pyx:63: in cupy.lib._polynomial.poly1d.roots.__get__
    return _routines_poly.roots(self._coeffs)
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3085: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3094: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 133, in test_poly1d_roots
E       out = xp.poly1d(a).roots
E     File "cupy/lib/_polynomial.pyx", line 63, in cupy.lib._polynomial.poly1d.roots.__get__
E       return _routines_poly.roots(self._coeffs)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3085, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3094, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________________ TestEigenvalue_param_0_{UPLO='U'}.test_eigh __________________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_0_{UPLO='U'} testMethod=test_eigh>  parameter: {'UPLO': 'U'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True, no_complex=True)
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigh(self, xp, dtype):
        a = xp.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], dtype)
>       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3085: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3094: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 19, in test_eigh
E       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 133, in eigh
E       return _syevd(a, UPLO, True)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3085, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3094, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_____________ TestEigenvalue_param_0_{UPLO='U'}.test_eigh_complex ______________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_0_{UPLO='U'} testMethod=test_eigh_complex>  parameter: {'UPLO': 'U'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_dtypes('FD')
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigh_complex(self, xp, dtype):
        a = xp.array([[1, 2j, 3], [4j, 5, 6j], [7, 8j, 9]], dtype)
>       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3097: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3106: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 46, in test_eigh_complex
E       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 133, in eigh
E       return _syevd(a, UPLO, True)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3097, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3106, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is F
_____________ TestEigenvalue_param_0_{UPLO='U'}.test_eigh_float16 ______________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_0_{UPLO='U'} testMethod=test_eigh_float16>  parameter: {'UPLO': 'U'}>

    def test_eigh_float16(self):
        # NumPy's eigh deos not support float16
        a = cupy.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], 'e')
>       w, v = cupy.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3073: in cupy_backends.cuda.libs.cusolver.ssyevd_bufferSize
    cpdef int ssyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3082: in cupy_backends.cuda.libs.cusolver.ssyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: CUSOLVERError
_______________ TestEigenvalue_param_0_{UPLO='U'}.test_eigvalsh ________________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_0_{UPLO='U'} testMethod=test_eigvalsh>  parameter: {'UPLO': 'U'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True, no_complex=True)
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigvalsh(self, xp, dtype):
        a = xp.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], dtype)
>       w = xp.linalg.eigvalsh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3085: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3094: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 59, in test_eigvalsh
E       w = xp.linalg.eigvalsh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3085, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3094, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_________________ TestEigenvalue_param_1_{UPLO='L'}.test_eigh __________________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_1_{UPLO='L'} testMethod=test_eigh>  parameter: {'UPLO': 'L'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True, no_complex=True)
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigh(self, xp, dtype):
        a = xp.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], dtype)
>       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3085: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3094: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 19, in test_eigh
E       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 133, in eigh
E       return _syevd(a, UPLO, True)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3085, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3094, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_____________ TestEigenvalue_param_1_{UPLO='L'}.test_eigh_complex ______________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_1_{UPLO='L'} testMethod=test_eigh_complex>  parameter: {'UPLO': 'L'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_dtypes('FD')
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigh_complex(self, xp, dtype):
        a = xp.array([[1, 2j, 3], [4j, 5, 6j], [7, 8j, 9]], dtype)
>       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3097: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3106: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 46, in test_eigh_complex
E       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 133, in eigh
E       return _syevd(a, UPLO, True)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3097, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3106, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is F
_____________ TestEigenvalue_param_1_{UPLO='L'}.test_eigh_float16 ______________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_1_{UPLO='L'} testMethod=test_eigh_float16>  parameter: {'UPLO': 'L'}>

    def test_eigh_float16(self):
        # NumPy's eigh deos not support float16
        a = cupy.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], 'e')
>       w, v = cupy.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3073: in cupy_backends.cuda.libs.cusolver.ssyevd_bufferSize
    cpdef int ssyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3082: in cupy_backends.cuda.libs.cusolver.ssyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: CUSOLVERError
_______________ TestEigenvalue_param_1_{UPLO='L'}.test_eigvalsh ________________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_1_{UPLO='L'} testMethod=test_eigvalsh>  parameter: {'UPLO': 'L'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True, no_complex=True)
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigvalsh(self, xp, dtype):
        a = xp.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], dtype)
>       w = xp.linalg.eigvalsh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3085: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3094: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 59, in test_eigvalsh
E       w = xp.linalg.eigvalsh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3085, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3094, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
______ TestBroadcast_param_2_{shapes=[(1,), (1,)]}.test_broadcast_arrays _______
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([1], dtype=int32), y = array([1], dtype=int32), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 1
E       Max relative difference: 1.
E        x: array([0], dtype=int32)
E        y: array([1], dtype=int32)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int32'>
______ TestBroadcast_param_3_{shapes=[(2,), (2,)]}.test_broadcast_arrays _______
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([1, 2], dtype=int32), y = array([1, 2], dtype=int32), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 1073741822
E       Max relative difference: 1.06535322e+09
E        x: array([1065353216, 1073741824], dtype=int32)
E        y: array([1, 2], dtype=int32)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int32'>
_________ TestConvolve_param_0_{mode='valid'}.test_convolve_diff_types _________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([1045,  867, 1025,  808,  989, 1042,  917, 1103, 1068, 1295, 1296,
       1352, 1270, 1202, 1091, 1106,  910, 11... 1291, 1280,
       1286, 1284, 1311, 1245, 1263, 1260, 1205, 1202, 1305, 1124, 1140,
       1117, 1081], dtype=uint16)
desired = array([1712, 1595, 1954, 1583, 1842, 1710, 1580, 1848, 1666, 1882, 1782,
       1942, 1900, 1759, 1665, 1742, 1656, 18... 1953, 2078,
       2088, 1992, 2065, 1919, 2018, 1950, 1988, 2033, 2120, 2024, 1898,
       1863, 1881], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 101 / 101 (100%)
E       Max absolute difference: 65050
E       Max relative difference: 41.05886076
E        x: array([1045,  867, 1025,  808,  989, 1042,  917, 1103, 1068, 1295, 1296,
E              1352, 1270, 1202, 1091, 1106,  910, 1102,  924, 1085,  979, 1132,
E              1031, 1250, 1172, 1272, 1243, 1302, 1165, 1182, 1138, 1243,  973,...
E        y: array([1712, 1595, 1954, 1583, 1842, 1710, 1580, 1848, 1666, 1882, 1782,
E              1942, 1900, 1759, 1665, 1742, 1656, 1899, 1655, 1886, 1717, 1834,
E              1810, 1965, 1786, 1984, 1836, 1857, 1729, 1906, 1814, 1875, 1770,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
_________ TestConvolve_param_1_{mode='same'}.test_convolve_diff_types __________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([ 725,  700,  567,  719,  629,  666,  695,  750,  769,  896,  944,
        878,  755,  799,  766,  734,  792,  6...  686,  724,
        704,  628,  570,  453,  523,  387,  476,  279,  436,  434,  509,
        432,  436], dtype=uint16)
desired = array([1186, 1250, 1116, 1291, 1128, 1205, 1250, 1297, 1302, 1412, 1310,
       1248, 1164, 1305, 1302, 1266, 1254, 11... 1155, 1070,
       1184, 1005, 1062,  886,  978,  810,  859,  788,  874,  807,  865,
        799,  738], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 200 / 200 (100%)
E       Max absolute difference: 65234
E       Max relative difference: 88.39295393
E        x: array([ 725,  700,  567,  719,  629,  666,  695,  750,  769,  896,  944,
E               878,  755,  799,  766,  734,  792,  674,  645,  618,  815,  730,
E               829,  931, 1056, 1006, 1144, 1060, 1098, 1025, 1079,  940,  976,...
E        y: array([1186, 1250, 1116, 1291, 1128, 1205, 1250, 1297, 1302, 1412, 1310,
E              1248, 1164, 1305, 1302, 1266, 1254, 1179, 1226, 1226, 1478, 1354,
E              1412, 1416, 1612, 1478, 1652, 1487, 1546, 1446, 1618, 1433, 1540,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
_________ TestConvolve_param_2_{mode='full'}.test_convolve_diff_types __________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([  25,   70,  109,  134,  146,  176,  197,  248,  326,  340,  368,
        386,  393,  406,  371,  371,  310,  3...  129,  102,
         48,   38,   48,   12,   24,    0,    0,    0,    0,    0,    0,
          0,    0], dtype=uint16)
desired = array([  25,   70,  109,  134,  146,  176,  197,  248,  326,  340,  368,
        386,  418,  486,  464,  450,  375,  4...  228,  180,
        193,  144,  130,  104,   89,  102,   96,   50,   20,   36,    0,
         32,    0], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 285 / 299 (95.3%)
E       Max absolute difference: 65516
E       Max relative difference: 3275.8
E        x: array([  25,   70,  109,  134,  146,  176,  197,  248,  326,  340,  368,
E               386,  393,  406,  371,  371,  310,  312,  380,  345,  424,  477,
E               449,  494,  483,  522,  515,  639,  734,  624,  638,  584,  564,...
E        y: array([  25,   70,  109,  134,  146,  176,  197,  248,  326,  340,  368,
E               386,  418,  486,  464,  450,  375,  418,  545,  558,  679,  688,
E               627,  688,  693,  772,  747,  788,  872,  850,  960,  888,  874,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
__________________ TestRational.test_lcm_check_boundary_cases __________________

self = <cupy_tests.math_tests.test_rational.TestRational testMethod=test_lcm_check_boundary_cases>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_int_dtypes(no_bool=True)
    @testing.numpy_cupy_array_equal()
    def test_lcm_check_boundary_cases(self, xp, dtype):
        a = xp.array([0, -10, -5, 10, 410, 1, 6, 33])
        b = xp.array([0, 5, -10, -5, 20, 51, 6, 42])
>       return xp.lcm(a, b)

tests/cupy_tests/math_tests/test_rational.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1103: in cupy.core._kernel.ufunc.__call__
    kern = self._get_ufunc_kernel(dev_id, op, arginfos)
cupy/core/_kernel.pyx:1126: in cupy.core._kernel.ufunc._get_ufunc_kernel
    kern = _get_ufunc_kernel(
cupy/core/_kernel.pyx:900: in cupy.core._kernel._get_ufunc_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7fe92f69fb50>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           AssertionError: Only cupy raises error
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 601, in compile
E               nvrtc.compileProgram(self.ptr, options)
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 116, in cupy_backends.cuda.libs.nvrtc.compileProgram
E               cpdef compileProgram(intptr_t prog, options):
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 128, in cupy_backends.cuda.libs.nvrtc.compileProgram
E               check_status(status)
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 62, in cupy_backends.cuda.libs.nvrtc.check_status
E               raise NVRTCError(status)
E           cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)
E           
E           During handling of the above exception, another exception occurred:
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E               result = impl(self, *args, **kw)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/math_tests/test_rational.py", line 38, in test_lcm_check_boundary_cases
E               return xp.lcm(a, b)
E             File "cupy/core/_kernel.pyx", line 1103, in cupy.core._kernel.ufunc.__call__
E               kern = self._get_ufunc_kernel(dev_id, op, arginfos)
E             File "cupy/core/_kernel.pyx", line 1126, in cupy.core._kernel.ufunc._get_ufunc_kernel
E               kern = _get_ufunc_kernel(
E             File "cupy/core/_kernel.pyx", line 900, in cupy.core._kernel._get_ufunc_kernel
E               return _get_simple_elementwise_kernel(
E             File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
E               module = compile_with_cache(module_code, options)
E             File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
E               return cuda.compile_with_cache(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
E               return _compile_with_cache_hip(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 787, in _compile_with_cache_hip
E               binary, mapping = compile_using_nvrtc(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 249, in compile_using_nvrtc
E               return _compile(source, options, cu_path,
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 233, in _compile
E               ptx, mapping = prog.compile(options, log_stream)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 613, in compile
E               raise CompileException(log, self.src, self.name, options,
E           cupy.cuda.compiler.CompileException: /tmp/comgr-b1aa7f/input/CompileSource:5361:9: error: call to function 'gcd' that is neither visible in the template definition nor found by argument-dependent lookup
E             T r = gcd(in0, in1);
E                   ^
E           /tmp/comgr-b1aa7f/input/CompileSource:5389:8: note: in instantiation of function template specialization 'lcm<long long>' requested here
E           out0 = lcm(in0, in1);
E                  ^
E           /tmp/comgr-b1aa7f/input/CompileSource:5370:43: note: 'gcd' should be declared prior to the call site
E           template <typename T> inline __device__ T gcd(T in0, T in1) {
E                                                     ^
E           1 error generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________________________ TestRandomState.test_methods _________________________

self = <cupy_tests.random_tests.test_generator.TestRandomState testMethod=test_methods>

    def test_methods(self):
        methods = [
            cuda.curand.CURAND_RNG_PSEUDO_DEFAULT,
            cuda.curand.CURAND_RNG_PSEUDO_MRG32K3A,
            cupy.cuda.curand.CURAND_RNG_PSEUDO_MT19937,
            cupy.cuda.curand.CURAND_RNG_PSEUDO_PHILOX4_32_10,
            cupy.cuda.curand.CURAND_RNG_PSEUDO_MTGP32,
            cupy.cuda.curand.CURAND_RNG_PSEUDO_XORWOW
        ]
    
        for method in methods:
>           rs = cupy.random.RandomState(method=method)

tests/cupy_tests/random_tests/test_generator.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/random/_generator.py:57: in __init__
    self._generator = curand.createGenerator(method)
cupy_backends/cuda/libs/curand.pyx:93: in cupy_backends.cuda.libs.curand.createGenerator
    cpdef size_t createGenerator(int rng_type) except? 0:
cupy_backends/cuda/libs/curand.pyx:97: in cupy_backends.cuda.libs.curand.createGenerator
    check_status(status)
cupy_backends/cuda/libs/curand.pyx:86: in cupy_backends.cuda.libs.curand.check_status
    raise CURANDError(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   super(CURANDError, self).__init__(STATUS[status])
E   KeyError: 1000

cupy_backends/cuda/libs/curand.pyx:77: KeyError
_____________________ TestChoiceChi.test_goodness_of_fit_2 _____________________
cupy/testing/condition.py:79: in wrapper
    fail()
cupy/testing/condition.py:50: in fail
    instance.fail(msg)
E   AssertionError: 
E   Fail: 1, Success: 4
E   
E   The first error message:
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/condition.py", line 59, in <lambda>
E       lambda: f(ins, *args[1:], **kwargs),
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/random_tests/test_generator.py", line 1080, in test_goodness_of_fit_2
E       assert hypothesis.chi_square_test(counts, expected)
E   AssertionError: assert False
E    +  where False = <function chi_square_test at 0x7fe92f233dc0>(array([17, 33, 50]), array([30, 30, 40]))
E    +    where <function chi_square_test at 0x7fe92f233dc0> = hypothesis.chi_square_test
_____________________ TestRandint2.test_goodness_of_fit_2 ______________________
cupy/testing/condition.py:79: in wrapper
    fail()
cupy/testing/condition.py:50: in fail
    instance.fail(msg)
E   AssertionError: 
E   Fail: 1, Success: 3
E   
E   The first error message:
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/condition.py", line 59, in <lambda>
E       lambda: f(ins, *args[1:], **kwargs),
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/random_tests/test_sample.py", line 106, in test_goodness_of_fit_2
E       assert hypothesis.chi_square_test(counts, expected)
E   AssertionError: assert False
E    +  where False = <function chi_square_test at 0x7fe92f233dc0>(array([21, 21, 11, 30, 17]), array([20., 20., 20., 20., 20.]))
E    +    where <function chi_square_test at 0x7fe92f233dc0> = hypothesis.chi_square_test
__________________ TestRandomIntegers2.test_goodness_of_fit_2 __________________
cupy/testing/condition.py:79: in wrapper
    fail()
cupy/testing/condition.py:50: in fail
    instance.fail(msg)
E   AssertionError: 
E   Fail: 1, Success: 3
E   
E   The first error message:
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/condition.py", line 59, in <lambda>
E       lambda: f(ins, *args[1:], **kwargs),
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/random_tests/test_sample.py", line 201, in test_goodness_of_fit_2
E       assert hypothesis.chi_square_test(counts, expected)
E   AssertionError: assert False
E    +  where False = <function chi_square_test at 0x7fe92f233dc0>(array([21, 21, 11, 30, 17]), array([20., 20., 20., 20., 20.]))
E    +    where <function chi_square_test at 0x7fe92f233dc0> = hypothesis.chi_square_test
________ TestCorrelate_param_0_{mode='valid'}.test_correlate_diff_types ________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([1191,  651,  779,  562,  751,  745,  693,  862,  864,  936, 1027,
        988,  962,  827,  937,  817,  832,  8...  888,  891,
        942, 1035, 1029, 1037, 1013, 1027,  923, 1029,  944,  889,  908,
        874,  863], dtype=uint16)
desired = array([2592, 1718, 1987, 1649, 1849, 1731, 1795, 1760, 1768, 1660, 1897,
       1677, 1809, 1717, 1837, 1735, 1847, 18... 1964, 1901,
       1937, 2021, 2012, 2070, 2067, 2075, 1921, 2122, 1994, 2076, 2045,
       2048, 1965], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 101 / 101 (100%)
E       Max absolute difference: 64847
E       Max relative difference: 42.19661458
E        x: array([1191,  651,  779,  562,  751,  745,  693,  862,  864,  936, 1027,
E               988,  962,  827,  937,  817,  832,  837,  814,  740,  794,  842,
E               771,  822,  895,  956,  943,  996,  946,  983,  890,  912,  824,...
E        y: array([2592, 1718, 1987, 1649, 1849, 1731, 1795, 1760, 1768, 1660, 1897,
E              1677, 1809, 1717, 1837, 1735, 1847, 1829, 1986, 1817, 1897, 1825,
E              1697, 1752, 1698, 1794, 1725, 1754, 1791, 1757, 1813, 1836, 1871,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
________ TestCorrelate_param_1_{mode='full'}.test_correlate_diff_types _________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([   0,   40,   56,   73,   80,   79,  128,  123,  187,  204,  215,
        299,  242,  279,  284,  208,  256,  1...  150,  135,
         76,   44,   46,   12,   36,    0,    0,    0,    0,    0,    0,
          0,    0], dtype=uint16)
desired = array([   0,   40,   56,   73,   80,   79,  128,  123,  187,  204,  215,
        299,  242,  304,  329,  277,  358,  3...  326,  352,
        289,  246,  209,  168,  178,  182,  152,  109,   62,   44,   34,
         28,   20], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 286 / 299 (95.7%)
E       Max absolute difference: 65516
E       Max relative difference: 3275.8
E        x: array([   0,   40,   56,   73,   80,   79,  128,  123,  187,  204,  215,
E               299,  242,  279,  284,  208,  256,  198,  294,  247,  241,  281,
E               241,  295,  252,  230,  347,  386,  508,  431,  419,  397,  372,...
E        y: array([   0,   40,   56,   73,   80,   79,  128,  123,  187,  204,  215,
E               299,  242,  304,  329,  277,  358,  300,  413,  372,  388,  436,
E               369,  465,  394,  362,  529,  498,  640,  599,  581,  613,  610,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
______ TestCorrelate_param_1_{mode='full'}.test_correlate_non_contiguous _______
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([   81., 16290.,  2210.], dtype=float16)
desired = array([   81., 16290.,  2212.], dtype=float16), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 3 (33.3%)
E       Max absolute difference: 2.
E       Max relative difference: 0.000904
E        x: array([   81., 16290.,  2210.], dtype=float16)
E        y: array([   81., 16290.,  2212.], dtype=float16)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float16'>
________ TestCorrelate_param_2_{mode='same'}.test_correlate_diff_types _________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([ 433,  490,  366,  409,  436,  493,  492,  480,  470,  565,  534,
        624,  543,  675,  595,  583,  563,  5...  630,  677,
        696,  535,  532,  515,  451,  370,  561,  359,  416,  370,  467,
        401,  460], dtype=uint16)
desired = array([ 830,  945,  881,  917,  878, 1017,  923,  963,  887, 1009,  869,
       1113,  956, 1121, 1006, 1164, 1110, 11... 1371, 1450,
       1441, 1328, 1307, 1264, 1253, 1280, 1404, 1213, 1263, 1154, 1182,
       1070, 1101], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 200 / 200 (100%)
E       Max absolute difference: 65201
E       Max relative difference: 78.48072289
E        x: array([ 433,  490,  366,  409,  436,  493,  492,  480,  470,  565,  534,
E               624,  543,  675,  595,  583,  563,  521,  511,  502,  507,  487,
E               611,  663,  662,  740,  800,  852,  778,  827,  800,  709,  739,...
E        y: array([ 830,  945,  881,  917,  878, 1017,  923,  963,  887, 1009,  869,
E              1113,  956, 1121, 1006, 1164, 1110, 1166, 1208, 1237, 1192, 1168,
E              1257, 1258, 1229, 1331, 1295, 1301, 1283, 1427, 1478, 1466, 1603,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
______________ TestInvh_param_0_{dtype=float32, size=5}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_0_{dtype=float32, size=5} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float32'>, 'size': 5}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1229: in cupy_backends.cuda.libs.cusolver.spotrs
    cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1237: in cupy_backends.cuda.libs.cusolver.spotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1229, in cupy_backends.cuda.libs.cusolver.spotrs
E       cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1237, in cupy_backends.cuda.libs.cusolver.spotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
______________ TestInvh_param_1_{dtype=float32, size=9}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_1_{dtype=float32, size=9} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float32'>, 'size': 9}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1229: in cupy_backends.cuda.libs.cusolver.spotrs
    cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1237: in cupy_backends.cuda.libs.cusolver.spotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1229, in cupy_backends.cuda.libs.cusolver.spotrs
E       cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1237, in cupy_backends.cuda.libs.cusolver.spotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_2_{dtype=float32, size=17}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_2_{dtype=float32, size=17} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float32'>, 'size': 17}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1229: in cupy_backends.cuda.libs.cusolver.spotrs
    cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1237: in cupy_backends.cuda.libs.cusolver.spotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1229, in cupy_backends.cuda.libs.cusolver.spotrs
E       cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1237, in cupy_backends.cuda.libs.cusolver.spotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_3_{dtype=float32, size=33}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_3_{dtype=float32, size=33} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float32'>, 'size': 33}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1229: in cupy_backends.cuda.libs.cusolver.spotrs
    cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1237: in cupy_backends.cuda.libs.cusolver.spotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1229, in cupy_backends.cuda.libs.cusolver.spotrs
E       cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1237, in cupy_backends.cuda.libs.cusolver.spotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
______________ TestInvh_param_4_{dtype=float64, size=5}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_4_{dtype=float64, size=5} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float64'>, 'size': 5}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1239: in cupy_backends.cuda.libs.cusolver.dpotrs
    cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1247: in cupy_backends.cuda.libs.cusolver.dpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1239, in cupy_backends.cuda.libs.cusolver.dpotrs
E       cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1247, in cupy_backends.cuda.libs.cusolver.dpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
______________ TestInvh_param_5_{dtype=float64, size=9}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_5_{dtype=float64, size=9} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float64'>, 'size': 9}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1239: in cupy_backends.cuda.libs.cusolver.dpotrs
    cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1247: in cupy_backends.cuda.libs.cusolver.dpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1239, in cupy_backends.cuda.libs.cusolver.dpotrs
E       cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1247, in cupy_backends.cuda.libs.cusolver.dpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_6_{dtype=float64, size=17}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_6_{dtype=float64, size=17} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float64'>, 'size': 17}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1239: in cupy_backends.cuda.libs.cusolver.dpotrs
    cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1247: in cupy_backends.cuda.libs.cusolver.dpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1239, in cupy_backends.cuda.libs.cusolver.dpotrs
E       cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1247, in cupy_backends.cuda.libs.cusolver.dpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_7_{dtype=float64, size=33}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_7_{dtype=float64, size=33} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float64'>, 'size': 33}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1239: in cupy_backends.cuda.libs.cusolver.dpotrs
    cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1247: in cupy_backends.cuda.libs.cusolver.dpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1239, in cupy_backends.cuda.libs.cusolver.dpotrs
E       cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1247, in cupy_backends.cuda.libs.cusolver.dpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_8_{dtype=complex64, size=5}.test_invh _____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_8_{dtype=complex64, size=5} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex64'>, 'size': 5}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1249: in cupy_backends.cuda.libs.cusolver.cpotrs
    cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1257: in cupy_backends.cuda.libs.cusolver.cpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1249, in cupy_backends.cuda.libs.cusolver.cpotrs
E       cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1257, in cupy_backends.cuda.libs.cusolver.cpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_9_{dtype=complex64, size=9}.test_invh _____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_9_{dtype=complex64, size=9} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex64'>, 'size': 9}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1249: in cupy_backends.cuda.libs.cusolver.cpotrs
    cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1257: in cupy_backends.cuda.libs.cusolver.cpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1249, in cupy_backends.cuda.libs.cusolver.cpotrs
E       cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1257, in cupy_backends.cuda.libs.cusolver.cpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
____________ TestInvh_param_10_{dtype=complex64, size=17}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_10_{dtype=complex64, size=17} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex64'>, 'size': 17}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1249: in cupy_backends.cuda.libs.cusolver.cpotrs
    cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1257: in cupy_backends.cuda.libs.cusolver.cpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1249, in cupy_backends.cuda.libs.cusolver.cpotrs
E       cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1257, in cupy_backends.cuda.libs.cusolver.cpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
____________ TestInvh_param_11_{dtype=complex64, size=33}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_11_{dtype=complex64, size=33} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex64'>, 'size': 33}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1249: in cupy_backends.cuda.libs.cusolver.cpotrs
    cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1257: in cupy_backends.cuda.libs.cusolver.cpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1249, in cupy_backends.cuda.libs.cusolver.cpotrs
E       cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1257, in cupy_backends.cuda.libs.cusolver.cpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
____________ TestInvh_param_12_{dtype=complex128, size=5}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_12_{dtype=complex128, size=5} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex128'>, 'size': 5}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1259: in cupy_backends.cuda.libs.cusolver.zpotrs
    cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1267: in cupy_backends.cuda.libs.cusolver.zpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1259, in cupy_backends.cuda.libs.cusolver.zpotrs
E       cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1267, in cupy_backends.cuda.libs.cusolver.zpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
____________ TestInvh_param_13_{dtype=complex128, size=9}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_13_{dtype=complex128, size=9} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex128'>, 'size': 9}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1259: in cupy_backends.cuda.libs.cusolver.zpotrs
    cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1267: in cupy_backends.cuda.libs.cusolver.zpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1259, in cupy_backends.cuda.libs.cusolver.zpotrs
E       cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1267, in cupy_backends.cuda.libs.cusolver.zpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
___________ TestInvh_param_14_{dtype=complex128, size=17}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_14_{dtype=complex128, size=17} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex128'>, 'size': 17}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1259: in cupy_backends.cuda.libs.cusolver.zpotrs
    cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1267: in cupy_backends.cuda.libs.cusolver.zpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1259, in cupy_backends.cuda.libs.cusolver.zpotrs
E       cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1267, in cupy_backends.cuda.libs.cusolver.zpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
___________ TestInvh_param_15_{dtype=complex128, size=33}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_15_{dtype=complex128, size=33} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex128'>, 'size': 33}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1259: in cupy_backends.cuda.libs.cusolver.zpotrs
    cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1267: in cupy_backends.cuda.libs.cusolver.zpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1259, in cupy_backends.cuda.libs.cusolver.zpotrs
E       cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1267, in cupy_backends.cuda.libs.cusolver.zpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestVstack_param_0_{dtype=float32}.test_basic_vstack _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_0_{dtype=float32} testMethod=test_basic_vstack>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_basic_vstack(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A, B]).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/base.py:524: in todense
    return self.toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 128,521,216 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________________ TestVstack_param_0_{dtype=float32}.test_csr __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_0_{dtype=float32} testMethod=test_csr>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_csr(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A.tocsr(), B.tocsr()]).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,507,328 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
____________ TestVstack_param_0_{dtype=float32}.test_csr_with_dtype ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_0_{dtype=float32} testMethod=test_csr_with_dtype>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_csr_with_dtype(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A.tocsr(), B.tocsr()],
                                  dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_____________ TestVstack_param_1_{dtype=float64}.test_basic_vstack _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_1_{dtype=float64} testMethod=test_basic_vstack>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_basic_vstack(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A, B]).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/base.py:524: in todense
    return self.toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________________ TestVstack_param_1_{dtype=float64}.test_csr __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_1_{dtype=float64} testMethod=test_csr>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_csr(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A.tocsr(), B.tocsr()]).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
____________ TestVstack_param_1_{dtype=float64}.test_csr_with_dtype ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_1_{dtype=float64} testMethod=test_csr_with_dtype>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_csr_with_dtype(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A.tocsr(), B.tocsr()],
                                  dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_____________ TestHstack_param_0_{dtype=float32}.test_basic_hstack _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_0_{dtype=float32} testMethod=test_basic_hstack>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_basic_hstack(self):
    
        A, B = self.data()
>       actual = construct.hstack([A, B], dtype=self.dtype).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/base.py:524: in todense
    return self.toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________________ TestHstack_param_0_{dtype=float32}.test_csc __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_0_{dtype=float32} testMethod=test_csc>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_csc(self):
        A, B = self.data()
>       actual = construct.hstack([A.tocsc(), B.tocsc()],
                                  dtype=self.dtype).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
____________ TestHstack_param_0_{dtype=float32}.test_csc_with_dtype ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_0_{dtype=float32} testMethod=test_csc_with_dtype>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_csc_with_dtype(self):
    
        A, B = self.data()
    
>       actual = construct.hstack([A.tocsc(), B.tocsc()],
                                  dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_____________ TestHstack_param_1_{dtype=float64}.test_basic_hstack _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_1_{dtype=float64} testMethod=test_basic_hstack>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_basic_hstack(self):
    
        A, B = self.data()
>       actual = construct.hstack([A, B], dtype=self.dtype).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/base.py:524: in todense
    return self.toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________________ TestHstack_param_1_{dtype=float64}.test_csc __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_1_{dtype=float64} testMethod=test_csc>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_csc(self):
        A, B = self.data()
>       actual = construct.hstack([A.tocsc(), B.tocsc()],
                                  dtype=self.dtype).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
____________ TestHstack_param_1_{dtype=float64}.test_csc_with_dtype ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_1_{dtype=float64} testMethod=test_csc_with_dtype>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_csc_with_dtype(self):
    
        A, B = self.data()
    
>       actual = construct.hstack([A.tocsc(), B.tocsc()],
                                  dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,503,744 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
______________ TestBmat_param_0_{dtype=float32}.test_basic_inputs ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_0_{dtype=float32} testMethod=test_basic_inputs>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_basic_inputs(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:174: in data
    B = sparse.csr_matrix(cupy.asarray([[5], [6]],
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7ff32e24e3d0>
arg1 = (array([-0.372549, -0.372549, -0.372549, ..., -0.372549, -0.372549,
       -0.372549], dtype=float32), (array([-109479...nt32), array([-1094795586, -1094795586, -1094795586, ..., -1094795586,
       -1094795586, -1094795586], dtype=int32)))
shape = (2, 1), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
                raise ValueError('column index exceeds matrix dimensions')
            if row.min() < 0:
>               raise ValueError('negative row index found')
E               ValueError: negative row index found

cupyx/scipy/sparse/coo.py:161: ValueError
_______________ TestBmat_param_0_{dtype=float32}.test_edge_cases _______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_0_{dtype=float32} testMethod=test_edge_cases>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_edge_cases(self):
        """Catch-all for small edge cases"""
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:174: in data
    B = sparse.csr_matrix(cupy.asarray([[5], [6]],
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7ff32e0cb6d0>
arg1 = (array([-0.372549, -0.372549, -0.372549, ..., -0.372549, -0.372549,
       -0.372549], dtype=float32), (array([-109479...nt32), array([-1094795586, -1094795586, -1094795586, ..., -1094795586,
       -1094795586, -1094795586], dtype=int32)))
shape = (2, 1), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
                raise ValueError('column index exceeds matrix dimensions')
            if row.min() < 0:
>               raise ValueError('negative row index found')
E               ValueError: negative row index found

cupyx/scipy/sparse/coo.py:161: ValueError
_________________ TestBmat_param_0_{dtype=float32}.test_empty __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_0_{dtype=float32} testMethod=test_empty>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_empty(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:174: in data
    B = sparse.csr_matrix(cupy.asarray([[5], [6]],
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7fe92420d8e0>
arg1 = (array([-0.372549, -0.372549, -0.372549, ..., -0.372549, -0.372549,
       -0.372549], dtype=float32), (array([-109479...nt32), array([-1094795586, -1094795586, -1094795586, ..., -1094795586,
       -1094795586, -1094795586], dtype=int32)))
shape = (2, 1), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
>               raise ValueError('column index exceeds matrix dimensions')
E               ValueError: column index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:159: ValueError
_____________ TestBmat_param_0_{dtype=float32}.test_failure_cases ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_0_{dtype=float32} testMethod=test_failure_cases>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_failure_cases(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:174: in data
    B = sparse.csr_matrix(cupy.asarray([[5], [6]],
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7ff32dfafb80>
arg1 = (array([-0.372549, -0.372549, -0.372549, ..., -0.372549, -0.372549,
       -0.372549], dtype=float32), (array([-109479...nt32), array([-1094795586, -1094795586, -1094795586, ..., -1094795586,
       -1094795586, -1094795586], dtype=int32)))
shape = (2, 1), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
                raise ValueError('column index exceeds matrix dimensions')
            if row.min() < 0:
>               raise ValueError('negative row index found')
E               ValueError: negative row index found

cupyx/scipy/sparse/coo.py:161: ValueError
______________ TestBmat_param_1_{dtype=float64}.test_basic_inputs ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_1_{dtype=float64} testMethod=test_basic_inputs>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_basic_inputs(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:172: in data
    A = sparse.csr_matrix(cupy.asarray([[1, 2], [3, 4]],
cupyx/scipy/sparse/compressed.py:389: in __init__
    data, indices, indptr = self._convert_dense(arg1)
cupyx/scipy/sparse/csr.py:76: in _convert_dense
    m = dense2csr(x)
cupyx/scipy/sparse/csr.py:1117: in dense2csr
    return cusparse.dense2csr(a)
cupy/cusparse.py:1132: in dense2csr
    data = _cupy.empty(nnz, x.dtype)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise ValueError('Negative dimensions are not allowed')
E   ValueError: Negative dimensions are not allowed

cupy/core/core.pyx:142: ValueError
_______________ TestBmat_param_1_{dtype=float64}.test_edge_cases _______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_1_{dtype=float64} testMethod=test_edge_cases>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_edge_cases(self):
        """Catch-all for small edge cases"""
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:172: in data
    A = sparse.csr_matrix(cupy.asarray([[1, 2], [3, 4]],
cupyx/scipy/sparse/compressed.py:389: in __init__
    data, indices, indptr = self._convert_dense(arg1)
cupyx/scipy/sparse/csr.py:76: in _convert_dense
    m = dense2csr(x)
cupyx/scipy/sparse/csr.py:1117: in dense2csr
    return cusparse.dense2csr(a)
cupy/cusparse.py:1132: in dense2csr
    data = _cupy.empty(nnz, x.dtype)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise ValueError('Negative dimensions are not allowed')
E   ValueError: Negative dimensions are not allowed

cupy/core/core.pyx:142: ValueError
_________________ TestBmat_param_1_{dtype=float64}.test_empty __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_1_{dtype=float64} testMethod=test_empty>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_empty(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:172: in data
    A = sparse.csr_matrix(cupy.asarray([[1, 2], [3, 4]],
cupyx/scipy/sparse/compressed.py:389: in __init__
    data, indices, indptr = self._convert_dense(arg1)
cupyx/scipy/sparse/csr.py:76: in _convert_dense
    m = dense2csr(x)
cupyx/scipy/sparse/csr.py:1117: in dense2csr
    return cusparse.dense2csr(a)
cupy/cusparse.py:1132: in dense2csr
    data = _cupy.empty(nnz, x.dtype)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise ValueError('Negative dimensions are not allowed')
E   ValueError: Negative dimensions are not allowed

cupy/core/core.pyx:142: ValueError
_____________ TestBmat_param_1_{dtype=float64}.test_failure_cases ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_1_{dtype=float64} testMethod=test_failure_cases>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_failure_cases(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:172: in data
    A = sparse.csr_matrix(cupy.asarray([[1, 2], [3, 4]],
cupyx/scipy/sparse/compressed.py:389: in __init__
    data, indices, indptr = self._convert_dense(arg1)
cupyx/scipy/sparse/csr.py:76: in _convert_dense
    m = dense2csr(x)
cupyx/scipy/sparse/csr.py:1117: in dense2csr
    return cusparse.dense2csr(a)
cupy/cusparse.py:1132: in dense2csr
    data = _cupy.empty(nnz, x.dtype)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise ValueError('Negative dimensions are not allowed')
E   ValueError: Negative dimensions are not allowed

cupy/core/core.pyx:142: ValueError
_ TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_0_{dtype=float32, format='csr', random_method='...m'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 25,577,980,928 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}.test_random_with_data_rvs _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_0_{dtype=float32, format='csr', random_method='...=test_random_with_data_rvs>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_data_rvs(self):
        if self.random_method == 'rand':
            pytest.skip('cupyx.scipy.sparse.rand does not support data_rvs')
        data_rvs = mock.MagicMock(side_effect=cupy.zeros)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1, data_rvs=data_rvs,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_0_{dtype=float32, format='csr', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_0_{dtype=float32, format='csr', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_1_{dtype=float32, format='csr', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_1_{dtype=float32, format='csr', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_2_{dtype=float32, format='csc', random_method='...m'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}.test_random_with_data_rvs _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_2_{dtype=float32, format='csc', random_method='...=test_random_with_data_rvs>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_data_rvs(self):
        if self.random_method == 'rand':
            pytest.skip('cupyx.scipy.sparse.rand does not support data_rvs')
        data_rvs = mock.MagicMock(side_effect=cupy.zeros)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1, data_rvs=data_rvs,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_2_{dtype=float32, format='csc', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_2_{dtype=float32, format='csc', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_3_{dtype=float32, format='csc', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_3_{dtype=float32, format='csc', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_4_{dtype=float32, format='coo', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_4_{dtype=float32, format='coo', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'coo', 'random_method': 'random'}>

    def test_random_with_seed(self):
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_4_{dtype=float32, format='coo', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_4_{dtype=float32, format='coo', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'coo', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        state2 = cupy.random.RandomState(1)
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state2)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_5_{dtype=float32, format='coo', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_5_{dtype=float32, format='coo', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'coo', 'random_method': 'rand'}>

    def test_random_with_seed(self):
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_5_{dtype=float32, format='coo', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_5_{dtype=float32, format='coo', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'coo', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        state2 = cupy.random.RandomState(1)
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state2)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_6_{dtype=float64, format='csr', random_method='...m'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}.test_random_with_data_rvs _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_6_{dtype=float64, format='csr', random_method='...=test_random_with_data_rvs>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_data_rvs(self):
        if self.random_method == 'rand':
            pytest.skip('cupyx.scipy.sparse.rand does not support data_rvs')
        data_rvs = mock.MagicMock(side_effect=cupy.zeros)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1, data_rvs=data_rvs,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_6_{dtype=float64, format='csr', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_6_{dtype=float64, format='csr', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_7_{dtype=float64, format='csr', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_7_{dtype=float64, format='csr', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_8_{dtype=float64, format='csc', random_method='...m'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}.test_random_with_data_rvs _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_8_{dtype=float64, format='csc', random_method='...=test_random_with_data_rvs>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_data_rvs(self):
        if self.random_method == 'rand':
            pytest.skip('cupyx.scipy.sparse.rand does not support data_rvs')
        data_rvs = mock.MagicMock(side_effect=cupy.zeros)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1, data_rvs=data_rvs,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_8_{dtype=float64, format='csc', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_8_{dtype=float64, format='csc', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_9_{dtype=float64, format='csc', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_9_{dtype=float64, format='csc', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_10_{dtype=float64, format='coo', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_10_{dtype=float64, format='coo', random_method=...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'coo', 'random_method': 'random'}>

    def test_random_with_seed(self):
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_10_{dtype=float64, format='coo', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_10_{dtype=float64, format='coo', random_method=...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'coo', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        state2 = cupy.random.RandomState(1)
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state2)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_11_{dtype=float64, format='coo', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_11_{dtype=float64, format='coo', random_method=...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'coo', 'random_method': 'rand'}>

    def test_random_with_seed(self):
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_ TestRandom_param_11_{dtype=float64, format='coo', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_11_{dtype=float64, format='coo', random_method=...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'coo', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        state2 = cupy.random.RandomState(1)
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state2)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_____________ TestCooMatrix_param_0_{dtype=float32}.test_init_copy _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_0_{dtype=float32} testMethod=test_init_copy>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_copy(self):
        n = sparse.coo_matrix(self.m)
        assert n is not self.m
>       cupy.testing.assert_array_equal(n.toarray(), self.m.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
______ TestCooMatrix_param_0_{dtype=float32}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_0_{dtype=float32} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.coo_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
______________ TestCooMatrix_param_0_{dtype=float32}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_0_{dtype=float32} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_____________ TestCooMatrix_param_1_{dtype=float64}.test_init_copy _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_1_{dtype=float64} testMethod=test_init_copy>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_copy(self):
        n = sparse.coo_matrix(self.m)
        assert n is not self.m
>       cupy.testing.assert_array_equal(n.toarray(), self.m.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
______ TestCooMatrix_param_1_{dtype=float64}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_1_{dtype=float64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.coo_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
______________ TestCooMatrix_param_1_{dtype=float64}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_1_{dtype=float64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
____________ TestCooMatrix_param_2_{dtype=complex64}.test_init_copy ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_2_{dtype=complex64} testMethod=test_init_copy>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_copy(self):
        n = sparse.coo_matrix(self.m)
        assert n is not self.m
>       cupy.testing.assert_array_equal(n.toarray(), self.m.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_____ TestCooMatrix_param_2_{dtype=complex64}.test_init_copy_other_sparse ______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_2_{dtype=complex64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.coo_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_____________ TestCooMatrix_param_2_{dtype=complex64}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_2_{dtype=complex64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
___________ TestCooMatrix_param_3_{dtype=complex128}.test_init_copy ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_3_{dtype=complex128} testMethod=test_init_copy>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_copy(self):
        n = sparse.coo_matrix(self.m)
        assert n is not self.m
>       cupy.testing.assert_array_equal(n.toarray(), self.m.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_____ TestCooMatrix_param_3_{dtype=complex128}.test_init_copy_other_sparse _____

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_3_{dtype=complex128} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.coo_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
____________ TestCooMatrix_param_3_{dtype=complex128}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_3_{dtype=complex128} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
______ TestCscMatrix_param_0_{dtype=float32}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csc_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:267: in tocsr
    return csc2csr(self)
cupy/cusparse.py:1054: in csc2csrEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 140,685,334,315,008 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________ TestCscMatrix_param_0_{dtype=float32}.test_init_data_row_col _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_data_row_col(self):
        o = self.m.tocoo()
>       n = sparse.csc_matrix((o.data, (o.row, o.col)))

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/compressed.py:366: in __init__
    sp_compressed = sp_coo.asformat(self.format)
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
____________ TestCscMatrix_param_0_{dtype=float32}.test_init_dense _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 0, 3]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7fe8e65a06d0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:158: AssertionError
_________ TestCscMatrix_param_0_{dtype=float32}.test_init_dense_empty __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 1, 1, 1, 0], dtype=int32), y = [0, 0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 5 (60%)
E       Max absolute difference: 1
E       Max relative difference: inf
E        x: array([0, 1, 1, 1, 0], dtype=int32)
E        y: array([0, 0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
________ TestCscMatrix_param_0_{dtype=float32}.test_init_dense_one_dim _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7fe9236806d0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:178: AssertionError
________ TestCscMatrix_param_0_{dtype=float32}.test_init_dense_zero_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 1065353216 == 1
E        +  where 1065353216 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32e16a730>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:187: AssertionError
_________ TestCscMatrix_param_0_{dtype=float32}.test_pickle_roundtrip __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94701680515216 != 94701680515216
E        +  where 94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7fe923587850>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7fe923587850> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7fe923587cd0>._descr
E        +  and   94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7fe924276670>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7fe924276670> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7fe92a1331c0>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:272: AssertionError
______________ TestCscMatrix_param_0_{dtype=float32}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csc.py:229: in tocoo
    return cusparse.csc2coo(self, data, indices)
cupy/cusparse.py:1005: in csc2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7fe9233ed490>
arg1 = (array([0., 1., 3., 2.], dtype=float32), (array([0, 0, 2, 1], dtype=int32), array([1167853568, 1167855616, 1167857664, 1167859712], dtype=int32)))
shape = (3, 4), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
>               raise ValueError('column index exceeds matrix dimensions')
E               ValueError: column index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:159: ValueError
______ TestCscMatrix_param_1_{dtype=float64}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csc_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:267: in tocsr
    return csc2csr(self)
cupy/cusparse.py:1054: in csc2csrEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 140,685,334,315,008 bytes (allocated so far: 8,532,326,912 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________ TestCscMatrix_param_1_{dtype=float64}.test_init_data_row_col _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_data_row_col(self):
        o = self.m.tocoo()
>       n = sparse.csc_matrix((o.data, (o.row, o.col)))

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/compressed.py:366: in __init__
    sp_compressed = sp_coo.asformat(self.format)
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
____________ TestCscMatrix_param_1_{dtype=float64}.test_init_dense _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 0, 3]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 3
        assert n.shape == (3, 4)
>       cupy.testing.assert_array_equal(n.data, [1, 2, 3])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0.0078125 , 2.00000048, 0.        ]), y = [1, 2, 3], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 3 (100%)
E       Max absolute difference: 3.
E       Max relative difference: 1.
E        x: array([0.007813, 2.      , 0.      ])
E        y: array([1, 2, 3])

cupy/testing/array.py:91: AssertionError
_________ TestCscMatrix_param_1_{dtype=float64}.test_init_dense_empty __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 0
E       AssertionError: assert 3 == 0
E        +  where 3 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32e348dc0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:169: AssertionError
________ TestCscMatrix_param_1_{dtype=float64}.test_init_dense_one_dim _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 3 == 2
E        +  where 3 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32e056a60>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:178: AssertionError
________ TestCscMatrix_param_1_{dtype=float64}.test_init_dense_zero_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 3 == 1
E        +  where 3 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32e368790>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:187: AssertionError
_________ TestCscMatrix_param_1_{dtype=float64}.test_pickle_roundtrip __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94701680515216 != 94701680515216
E        +  where 94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff32d463880>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7ff32d463880> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32d463280>._descr
E        +  and   94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff32d463700>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7ff32d463700> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32d4637f0>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:272: AssertionError
______________ TestCscMatrix_param_1_{dtype=float64}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csc.py:229: in tocoo
    return cusparse.csc2coo(self, data, indices)
cupy/cusparse.py:1005: in csc2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7ff32d754c10>
arg1 = (array([0., 1., 3., 2.]), (array([0, 0, 2, 1], dtype=int32), array([1132494848, 1132494848, 1132527616, 1132527616], dtype=int32)))
shape = (3, 4), dtype = dtype('float64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
>               raise ValueError('column index exceeds matrix dimensions')
E               ValueError: column index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:159: ValueError
_____ TestCscMatrix_param_2_{dtype=complex64}.test_init_copy_other_sparse ______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csc_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:267: in tocsr
    return csc2csr(self)
cupy/cusparse.py:1054: in csc2csrEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 140,685,334,315,008 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
________ TestCscMatrix_param_2_{dtype=complex64}.test_init_data_row_col ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_data_row_col(self):
        o = self.m.tocoo()
>       n = sparse.csc_matrix((o.data, (o.row, o.col)))

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/compressed.py:366: in __init__
    sp_compressed = sp_coo.asformat(self.format)
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
___________ TestCscMatrix_param_2_{dtype=complex64}.test_init_dense ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 0, 3]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 3
        assert n.shape == (3, 4)
>       cupy.testing.assert_array_equal(n.data, [1, 2, 3])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([1.e-45+1.j, 3.e+00+2.j, 0.e+00+0.j], dtype=complex64), y = [1, 2, 3]
err_msg = '', verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 3 (100%)
E       Max absolute difference: 3.
E       Max relative difference: 1.41421356
E        x: array([1.e-45+1.j, 3.e+00+2.j, 0.e+00+0.j], dtype=complex64)
E        y: array([1, 2, 3])

cupy/testing/array.py:91: AssertionError
________ TestCscMatrix_param_2_{dtype=complex64}.test_init_dense_empty _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([         0, 1065353216,          0, 1073741824, 1158172672],
      dtype=int32)
y = [0, 0, 0, 0, 0], err_msg = '', verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 5 (60%)
E       Max absolute difference: 1158172672
E       Max relative difference: inf
E        x: array([         0, 1065353216,          0, 1073741824, 1158172672],
E             dtype=int32)
E        y: array([0, 0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
_______ TestCscMatrix_param_2_{dtype=complex64}.test_init_dense_one_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32ddc5d60>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:178: AssertionError
_______ TestCscMatrix_param_2_{dtype=complex64}.test_init_dense_zero_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7fe8e64ce460>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:187: AssertionError
________ TestCscMatrix_param_2_{dtype=complex64}.test_pickle_roundtrip _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94701680515216 != 94701680515216
E        +  where 94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff32e3e5dc0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7ff32e3e5dc0> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32e3e5550>._descr
E        +  and   94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff32e3e5130>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7ff32e3e5130> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32e3e5430>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:272: AssertionError
_____________ TestCscMatrix_param_2_{dtype=complex64}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csc.py:229: in tocoo
    return cusparse.csc2coo(self, data, indices)
cupy/cusparse.py:1005: in csc2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7ff32e1d69a0>
arg1 = (array([0.+0.j, 1.+0.j, 3.+0.j, 2.+0.j], dtype=complex64), (array([0, 0, 2, 1], dtype=int32), array([         0,          0,          0, 1072693248], dtype=int32)))
shape = (3, 4), dtype = dtype('complex64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
>               raise ValueError('column index exceeds matrix dimensions')
E               ValueError: column index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:159: ValueError
_____ TestCscMatrix_param_3_{dtype=complex128}.test_init_copy_other_sparse _____

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csc_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:267: in tocsr
    return csc2csr(self)
cupy/cusparse.py:1054: in csc2csrEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 140,685,334,315,008 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_______ TestCscMatrix_param_3_{dtype=complex128}.test_init_data_row_col ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_data_row_col(self):
        o = self.m.tocoo()
>       n = sparse.csc_matrix((o.data, (o.row, o.col)))

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/compressed.py:366: in __init__
    sp_compressed = sp_coo.asformat(self.format)
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
___________ TestCscMatrix_param_3_{dtype=complex128}.test_init_dense ___________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 0, 3]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 3
        assert n.shape == (3, 4)
>       cupy.testing.assert_array_equal(n.data, [1, 2, 3])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([2.12199579e-314+2.12199579e-314j, 3.00000000e+000+2.00000000e+000j,
       0.00000000e+000+0.00000000e+000j])
y = [1, 2, 3], err_msg = '', verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 3 (100%)
E       Max absolute difference: 3.
E       Max relative difference: 1.11803399
E        x: array([2.121996e-314+2.121996e-314j, 3.000000e+000+2.000000e+000j,
E              0.000000e+000+0.000000e+000j])
E        y: array([1, 2, 3])

cupy/testing/array.py:91: AssertionError
________ TestCscMatrix_param_3_{dtype=complex128}.test_init_dense_empty ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 0
E       AssertionError: assert 3 == 0
E        +  where 3 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32d5510a0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:169: AssertionError
_______ TestCscMatrix_param_3_{dtype=complex128}.test_init_dense_one_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 3 == 2
E        +  where 3 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32d685190>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:178: AssertionError
______ TestCscMatrix_param_3_{dtype=complex128}.test_init_dense_zero_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 3 == 1
E        +  where 3 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7fe9231def40>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:187: AssertionError
________ TestCscMatrix_param_3_{dtype=complex128}.test_pickle_roundtrip ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94701680515216 != 94701680515216
E        +  where 94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff32e134df0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7ff32e134df0> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32e134160>._descr
E        +  and   94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff32e1343a0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7ff32e1343a0> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7ff32e134490>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:272: AssertionError
____________ TestCscMatrix_param_3_{dtype=complex128}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
______ TestCsrMatrix_param_0_{dtype=float32}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csr_matrix(self.m.tocsc())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:447: in tocsc
    return csr2csc(self)
cupy/cusparse.py:976: in csr2cscEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 140,685,334,315,008 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________ TestCsrMatrix_param_0_{dtype=float32}.test_init_data_row_col _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_data_row_col(self):
>       o = self.m.tocoo()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7fe8004a1e80>
arg1 = (array([0., 1., 2., 3.], dtype=float32), (array([0, 1, 2, 3], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
____________ TestCsrMatrix_param_0_{dtype=float32}.test_init_dense _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 3, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe80052a970>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:202: AssertionError
_________ TestCsrMatrix_param_0_{dtype=float32}.test_init_dense_empty __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 0, 2, 1], dtype=int32), y = [0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 4 (50%)
E       Max absolute difference: 2
E       Max relative difference: inf
E        x: array([0, 0, 2, 1], dtype=int32)
E        y: array([0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
________ TestCsrMatrix_param_0_{dtype=float32}.test_init_dense_one_dim _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe922d0a490>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:222: AssertionError
________ TestCsrMatrix_param_0_{dtype=float32}.test_init_dense_zero_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 1065353216 == 1
E        +  where 1065353216 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7ff32d7cc970>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:231: AssertionError
_________ TestCsrMatrix_param_0_{dtype=float32}.test_pickle_roundtrip __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
    
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94701680515216 != 94701680515216
E        +  where 94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff32dd58790>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7ff32dd58790> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe9233e3b80>._descr
E        +  and   94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7fe923677190>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7fe923677190> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7ff32dd58700>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:317: AssertionError
______________ TestCsrMatrix_param_0_{dtype=float32}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:393: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7ff32d53b7c0>
arg1 = (array([0., 1., 2., 3.], dtype=float32), (array([         0,          0, 1065353216,          0], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
______ TestCsrMatrix_param_1_{dtype=float64}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csr_matrix(self.m.tocsc())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:447: in tocsc
    return csr2csc(self)
cupy/cusparse.py:976: in csr2cscEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 140,685,334,315,008 bytes (allocated so far: 8,532,326,912 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________ TestCsrMatrix_param_1_{dtype=float64}.test_init_data_row_col _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_data_row_col(self):
>       o = self.m.tocoo()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7fe8e6406ca0>
arg1 = (array([0., 1., 2., 3.]), (array([0, 1, 3, 2], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('float64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
____________ TestCsrMatrix_param_1_{dtype=float64}.test_init_dense _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 3, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe800183a60>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:202: AssertionError
_________ TestCsrMatrix_param_1_{dtype=float64}.test_init_dense_empty __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 0, 2, 1], dtype=int32), y = [0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 4 (50%)
E       Max absolute difference: 2
E       Max relative difference: inf
E        x: array([0, 0, 2, 1], dtype=int32)
E        y: array([0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
________ TestCsrMatrix_param_1_{dtype=float64}.test_init_dense_one_dim _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe922d9f0d0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:222: AssertionError
________ TestCsrMatrix_param_1_{dtype=float64}.test_init_dense_zero_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe924900d00>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:231: AssertionError
_________ TestCsrMatrix_param_1_{dtype=float64}.test_pickle_roundtrip __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
    
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94701680515216 != 94701680515216
E        +  where 94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7fe9237c8e50>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7fe9237c8e50> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe922e6f280>._descr
E        +  and   94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7fe92cc6ba30>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7fe92cc6ba30> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe9237c8790>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:317: AssertionError
______________ TestCsrMatrix_param_1_{dtype=float64}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:393: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7ff32e06af40>
arg1 = (array([0., 1., 2., 3.]), (array([         0,          0, 1065353216,          0], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('float64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
_____ TestCsrMatrix_param_2_{dtype=complex64}.test_init_copy_other_sparse ______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csr_matrix(self.m.tocsc())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:447: in tocsc
    return csr2csc(self)
cupy/cusparse.py:976: in csr2cscEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 140,685,334,315,008 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
________ TestCsrMatrix_param_2_{dtype=complex64}.test_init_data_row_col ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_data_row_col(self):
>       o = self.m.tocoo()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7fe80032fbb0>
arg1 = (array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j], dtype=complex64), (array([0, 1, 3, 2], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('complex64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
___________ TestCsrMatrix_param_2_{dtype=complex64}.test_init_dense ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 3, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe8e654c7f0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:202: AssertionError
________ TestCsrMatrix_param_2_{dtype=complex64}.test_init_dense_empty _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 1, 3, 2], dtype=int32), y = [0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 4 (75%)
E       Max absolute difference: 3
E       Max relative difference: inf
E        x: array([0, 1, 3, 2], dtype=int32)
E        y: array([0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
_______ TestCsrMatrix_param_2_{dtype=complex64}.test_init_dense_one_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7ff32e3e7c70>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:222: AssertionError
_______ TestCsrMatrix_param_2_{dtype=complex64}.test_init_dense_zero_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe8e640b190>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:231: AssertionError
________ TestCsrMatrix_param_2_{dtype=complex64}.test_pickle_roundtrip _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
    
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94701680515216 != 94701680515216
E        +  where 94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7fe8e62d9640>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7fe8e62d9640> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe8e62d9a00>._descr
E        +  and   94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7fe8e62d9e80>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7fe8e62d9e80> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe8e62d9f10>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:317: AssertionError
_____________ TestCsrMatrix_param_2_{dtype=complex64}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:393: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7fe80033ff10>
arg1 = (array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j], dtype=complex64), (array([         0,          0,          0, 1072693248], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('complex64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
_____ TestCsrMatrix_param_3_{dtype=complex128}.test_init_copy_other_sparse _____

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csr_matrix(self.m.tocsc())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:447: in tocsc
    return csr2csc(self)
cupy/cusparse.py:976: in csr2cscEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 140,685,334,315,008 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_______ TestCsrMatrix_param_3_{dtype=complex128}.test_init_data_row_col ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_data_row_col(self):
>       o = self.m.tocoo()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7fe80035e0d0>
arg1 = (array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j]), (array([0, 1, 3, 2], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('complex128'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
___________ TestCsrMatrix_param_3_{dtype=complex128}.test_init_dense ___________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 3, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7fe80056bf10>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:202: AssertionError
________ TestCsrMatrix_param_3_{dtype=complex128}.test_init_dense_empty ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 1, 3, 2], dtype=int32), y = [0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 4 (75%)
E       Max absolute difference: 3
E       Max relative difference: inf
E        x: array([0, 1, 3, 2], dtype=int32)
E        y: array([0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
_______ TestCsrMatrix_param_3_{dtype=complex128}.test_init_dense_one_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7ff32e104dc0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:222: AssertionError
______ TestCsrMatrix_param_3_{dtype=complex128}.test_init_dense_zero_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7ff32d77e7f0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:231: AssertionError
________ TestCsrMatrix_param_3_{dtype=complex128}.test_pickle_roundtrip ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
    
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94701680515216 != 94701680515216
E        +  where 94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff32e03c6d0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7ff32e03c6d0> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7ff32e03cee0>._descr
E        +  and   94701680515216 = <cupy.cusparse.MatDescriptor object at 0x7ff32e03cbe0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7ff32e03cbe0> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7ff32e03c220>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:317: AssertionError
____________ TestCsrMatrix_param_3_{dtype=complex128}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:393: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7fe8004b40d0>
arg1 = (array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j]), (array([         0,          0,          0, 1072693248], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('complex128'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
______________ TestDiaMatrix_param_0_{dtype=float32}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_dia.TestDiaMatrix_param_0_{dtype=float32} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/dia.py:136: in toarray
    return self.tocsc().toarray(order=order, out=out)
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
______________ TestDiaMatrix_param_1_{dtype=float64}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_dia.TestDiaMatrix_param_1_{dtype=float64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/dia.py:136: in toarray
    return self.tocsc().toarray(order=order, out=out)
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_____________ TestDiaMatrix_param_2_{dtype=complex64}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_dia.TestDiaMatrix_param_2_{dtype=complex64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/dia.py:136: in toarray
    return self.tocsc().toarray(order=order, out=out)
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csc.py:229: in tocoo
    return cusparse.csc2coo(self, data, indices)
cupy/cusparse.py:1005: in csc2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7fe7ff6aa0d0>
arg1 = (array([3.+0.j, 1.+0.j, 4.+0.j, 2.+0.j], dtype=complex64), (array([1, 1, 2, 2], dtype=int32), array([ 0, -1,  0,  0], dtype=int32)))
shape = (3, 4), dtype = dtype('complex64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
                raise ValueError('column index exceeds matrix dimensions')
            if row.min() < 0:
                raise ValueError('negative row index found')
            if col.min() < 0:
>               raise ValueError('negative column index found')
E               ValueError: negative column index found

cupyx/scipy/sparse/coo.py:163: ValueError
____________ TestDiaMatrix_param_3_{dtype=complex128}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_dia.TestDiaMatrix_param_3_{dtype=complex128} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/dia.py:136: in toarray
    return self.tocsc().toarray(order=order, out=out)
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 7,554,108,627,555,683,328 bytes (allocated so far: 9,501,184 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_______________________ TestMonteCarlo.test_monte_carlo ________________________

self = <example_tests.test_finance.TestMonteCarlo testMethod=test_monte_carlo>

    def test_monte_carlo(self):
>       output = example_test.run_example(
            'finance/monte_carlo.py', '--n-options', '10',
            '--n-samples-per-thread', '10',
            '--n-threads-per-option', '10')

tests/example_tests/test_finance.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/example_tests/example_test.py:12: in run_example
    return subprocess.check_output(
/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:411: in check_output
    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/...tests/example_tests/../../examples/finance/monte_carlo.py', '--n-options', '10', '--n-samples-per-thread', '10', ...),)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fe91f249370>
stdout = b'initializing...\nstart computation\n    # of options: 10\n    # of samples per option: 100\nTraceback (most recent c...r generated when compiling for gfx906.\nError: Failed to compile opencl source (from CL or HIP source to LLVM IR).\n\n'
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/example_tests/../../examples/finance/monte_carlo.py', '--n-options', '10', '--n-samples-per-thread', '10', '--n-threads-per-option', '10')' returned non-zero exit status 1.

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:512: CalledProcessError
----------------------------- Captured stdout call -----------------------------
Original error message:
initializing...
start computation
    # of options: 10
    # of samples per option: 100
Traceback (most recent call last):
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 601, in compile
    nvrtc.compileProgram(self.ptr, options)
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 116, in cupy_backends.cuda.libs.nvrtc.compileProgram
    cpdef compileProgram(intptr_t prog, options):
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 128, in cupy_backends.cuda.libs.nvrtc.compileProgram
    check_status(status)
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 62, in cupy_backends.cuda.libs.nvrtc.check_status
    raise NVRTCError(status)
cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/example_tests/../../examples/finance/monte_carlo.py", line 159, in <module>
    sys.exit(main())
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/example_tests/../../examples/finance/monte_carlo.py", line 145, in main
    call_mc = compute_option_prices(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/example_tests/../../examples/finance/monte_carlo.py", line 104, in compute_option_prices
    monte_carlo_kernel(
  File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
  File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
  File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
  File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 787, in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 249, in compile_using_nvrtc
    return _compile(source, options, cu_path,
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 233, in _compile
    ptx, mapping = prog.compile(options, log_stream)
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 613, in compile
    raise CompileException(log, self.src, self.name, options,
cupy.cuda.compiler.CompileException: /tmp/comgr-c7e8a4/input/CompileSource:5358:32: error: typedef redefinition with different types ('unsigned long long' vs '__uint64_t' (aka 'unsigned long'))
    typedef unsigned long long uint64_t;
                               ^
/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h:27:20: note: previous definition is here
typedef __uint64_t uint64_t;
                   ^
/tmp/comgr-c7e8a4/input/CompileSource:5388:25: warning: integer literal is too large to be represented in a signed integer type, interpreting as unsigned [-Wimplicitly-unsigned-literal]
        return T(x) / T(18446744073709551615);
                        ^
1 warning and 1 error generated when compiling for gfx906.
Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).


_____________ TestMonteCarloWithMultiGPU.test_monte_carlo_multigpu _____________

self = <example_tests.test_finance.TestMonteCarloWithMultiGPU testMethod=test_monte_carlo_multigpu>

    @testing.multi_gpu(2)
    def test_monte_carlo_multigpu(self):
>       output = example_test.run_example(
            'finance/monte_carlo_multigpu.py', '--gpus', '0', '1',
            '--n-options', '10',
            '--n-samples-per-thread', '10',
            '--n-threads-per-option', '10')

tests/example_tests/test_finance.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/example_tests/example_test.py:12: in run_example
    return subprocess.check_output(
/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:411: in check_output
    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/example_tests/../../examples/finance/monte_carlo_multigpu.py', '--gpus', '0', '1', '--n-options', ...),)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fe800cd4040>
stdout = b'initializing...\nstart computation\n    # of gpus: 2\n    # of options: 10\n    # of samples per option: 200\nTraceb...r generated when compiling for gfx906.\nError: Failed to compile opencl source (from CL or HIP source to LLVM IR).\n\n'
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/example_tests/../../examples/finance/monte_carlo_multigpu.py', '--gpus', '0', '1', '--n-options', '10', '--n-samples-per-thread', '10', '--n-threads-per-option', '10')' returned non-zero exit status 1.

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:512: CalledProcessError
----------------------------- Captured stdout call -----------------------------
Original error message:
initializing...
start computation
    # of gpus: 2
    # of options: 10
    # of samples per option: 200
Traceback (most recent call last):
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 601, in compile
    nvrtc.compileProgram(self.ptr, options)
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 116, in cupy_backends.cuda.libs.nvrtc.compileProgram
    cpdef compileProgram(intptr_t prog, options):
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 128, in cupy_backends.cuda.libs.nvrtc.compileProgram
    check_status(status)
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 62, in cupy_backends.cuda.libs.nvrtc.check_status
    raise NVRTCError(status)
cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/example_tests/../../examples/finance/monte_carlo_multigpu.py", line 74, in <module>
    monte_carlo_kernel(
  File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
  File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
  File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
  File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 787, in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 249, in compile_using_nvrtc
    return _compile(source, options, cu_path,
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 233, in _compile
    ptx, mapping = prog.compile(options, log_stream)
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/cupy/cuda/compiler.py", line 613, in compile
    raise CompileException(log, self.src, self.name, options,
cupy.cuda.compiler.CompileException: /tmp/comgr-a768c5/input/CompileSource:5358:32: error: typedef redefinition with different types ('unsigned long long' vs '__uint64_t' (aka 'unsigned long'))
    typedef unsigned long long uint64_t;
                               ^
/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h:27:20: note: previous definition is here
typedef __uint64_t uint64_t;
                   ^
/tmp/comgr-a768c5/input/CompileSource:5388:25: warning: integer literal is too large to be represented in a signed integer type, interpreting as unsigned [-Wimplicitly-unsigned-literal]
        return T(x) / T(18446744073709551615);
                        ^
1 warning and 1 error generated when compiling for gfx906.
Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).


___________________ TestCheckVersion.test_check_cuda_version ___________________

self = <install_tests.test_build.TestCheckVersion testMethod=test_check_cuda_version>

    @pytest.mark.gpu
    def test_check_cuda_version(self):
        with self.assertRaises(RuntimeError):
            build.get_cuda_version()
>       assert build.check_cuda_version(
            self.compiler, self.settings)
E       AssertionError: assert False
E        +  where False = <function check_cuda_version at 0x7fe91f052310>(<distutils.unixccompiler.UnixCCompiler object at 0x7fe800fc2bb0>, {'define_macros': [], 'extra_compile_args': [], 'include_dirs': ['/home/kmaeh/Development/cupy-rocm-ci-report/tools/tm...kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/install/../cupy/core/include'], 'language': 'c++', ...})
E        +    where <function check_cuda_version at 0x7fe91f052310> = build.check_cuda_version
E        +    and   <distutils.unixccompiler.UnixCCompiler object at 0x7fe800fc2bb0> = <install_tests.test_build.TestCheckVersion testMethod=test_check_cuda_version>.compiler
E        +    and   {'define_macros': [], 'extra_compile_args': [], 'include_dirs': ['/home/kmaeh/Development/cupy-rocm-ci-report/tools/tm...kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/install/../cupy/core/include'], 'language': 'c++', ...} = <install_tests.test_build.TestCheckVersion testMethod=test_check_cuda_version>.settings

tests/install_tests/test_build.py:21: AssertionError
----------------------------- Captured stdout call -----------------------------
**************************************************
*** WARNING: Cannot check CUDA version
*** WARNING: command 'gcc' failed with exit status 1
**************************************************
----------------------------- Captured stderr call -----------------------------
/tmp/tmpsak3j60n/a.cpp:2:18: fatal error: cuda.h: No such file or directory
         #include <cuda.h>
                  ^~~~~~~~
compilation terminated.
__________________ TestCheckVersion.test_check_cudnn_version ___________________

self = <install_tests.test_build.TestCheckVersion testMethod=test_check_cudnn_version>

    @pytest.mark.gpu
    @pytest.mark.cudnn
    def test_check_cudnn_version(self):
        with self.assertRaises(RuntimeError):
            build.get_cudnn_version()
>       assert build.check_cudnn_version(
            self.compiler, self.settings)
E       AssertionError: assert False
E        +  where False = <function check_cudnn_version at 0x7fe91f052790>(<distutils.unixccompiler.UnixCCompiler object at 0x7fe7fc0e0370>, {'define_macros': [], 'extra_compile_args': [], 'include_dirs': ['/home/kmaeh/Development/cupy-rocm-ci-report/tools/tm...kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/install/../cupy/core/include'], 'language': 'c++', ...})
E        +    where <function check_cudnn_version at 0x7fe91f052790> = build.check_cudnn_version
E        +    and   <distutils.unixccompiler.UnixCCompiler object at 0x7fe7fc0e0370> = <install_tests.test_build.TestCheckVersion testMethod=test_check_cudnn_version>.compiler
E        +    and   {'define_macros': [], 'extra_compile_args': [], 'include_dirs': ['/home/kmaeh/Development/cupy-rocm-ci-report/tools/tm...kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/install/../cupy/core/include'], 'language': 'c++', ...} = <install_tests.test_build.TestCheckVersion testMethod=test_check_cudnn_version>.settings

tests/install_tests/test_build.py:31: AssertionError
----------------------------- Captured stdout call -----------------------------
**************************************************
*** WARNING: Cannot check cuDNN version
command 'gcc' failed with exit status 1
**************************************************
----------------------------- Captured stderr call -----------------------------
/tmp/tmpukz0c9i1/a.cpp:2:18: fatal error: cudnn.h: No such file or directory
         #include <cudnn.h>
                  ^~~~~~~~~
compilation terminated.
=============================== warnings summary ===============================
tests/cupy_tests/core_tests/fusion_tests/test_array.py: 1 warning
tests/cupy_tests/math_tests/test_sumprod.py: 19 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: overflow encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/core_tests/fusion_tests/test_routines.py::TestFusionNumericalReduction_param_1_{func='prod'}::test_reduction
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: overflow encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/functional_tests/test_vectorize.py::TestVectorize::test_vectorize_arithmetic_ops
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/functional_tests/test_vectorize.py:372: RuntimeWarning: overflow encountered in byte_scalars
    y = x1 + x2 * x3 ** x1

tests/cupy_tests/functional_tests/test_vectorize.py::TestVectorize::test_vectorize_arithmetic_ops
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/functional_tests/test_vectorize.py:372: RuntimeWarning: overflow encountered in ubyte_scalars
    y = x1 + x2 * x3 ** x1

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_0_{type_l='poly1d', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_3_{type_l='ndarray', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_array
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in multiply
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in half_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in byte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in short_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ubyte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ushort_scalars
    y = y * x + p[i]

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in power
    absx **= ord

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in reciprocal
    absx **= ord

tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf
tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf_nan
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/numeric.py:2276: RuntimeWarning: overflow encountered in absolute
    return less_equal(abs(x-y), atol + rtol * abs(y))

tests/cupy_tests/math_tests/test_sumprod.py: 15 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: invalid value encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: invalid value encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/math_tests/test_sumprod.py: 32 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/math_tests/test_sumprod.py:799: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all_transposed2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes4
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axis_transposed2
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:47: RuntimeWarning: overflow encountered in reduce
    return umr_sum(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/statistics_tests/test_meanvar.py: 28 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.rzzuYeWtbX/cupy/tests/cupy_tests/statistics_tests/test_meanvar.py:114: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_4_{axis=0, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_5_{axis=0, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_6_{axis=0, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_7_{axis=0, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_8_{axis=1, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_9_{axis=1, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_10_{axis=1, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_11_{axis=1, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/nanfunctions.py:1113: RuntimeWarning: All-NaN slice encountered
    r, k = function_base._ureduce(a, func=_nanmedian, axis=axis, out=out,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_3_{func='mean', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_5_{func='mean', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3372: RuntimeWarning: Mean of empty slice.
    return _methods._mean(a, axis=axis, dtype=dtype,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:168: RuntimeWarning: invalid value encountered in true_divide
    ret = arr.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_9_{func='std', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_11_{func='std', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:233: RuntimeWarning: Degrees of freedom <= 0 for slice
    ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:194: RuntimeWarning: invalid value encountered in true_divide
    arrmean = um.true_divide(

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_15_{func='var', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_17_{func='var', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3621: RuntimeWarning: Degrees of freedom <= 0 for slice
    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

-- Docs: https://docs.pytest.org/en/stable/warnings.html
=========================== short test summary info ============================
FAILED tests/cupy_tests/test_cublas.py::TestDgmm_param_5_{ordera='C', orderc='F', shape=(9, 10), side='R'}::test_dgmm_incx_minus_one
FAILED tests/cupy_tests/test_cublas.py::TestDgmm_param_7_{ordera='C', orderc='F', shape=(10, 9), side='R'}::test_dgmm_incx_minus_one
FAILED tests/cupy_tests/test_cublas.py::TestDgmm_param_12_{ordera='F', orderc='F', shape=(9, 10), side='L'}::test_dgmm_incx_minus_one
FAILED tests/cupy_tests/test_cublas.py::TestDgmm_param_14_{ordera='F', orderc='F', shape=(10, 9), side='L'}::test_dgmm_incx_minus_one
FAILED tests/cupy_tests/test_cusparse.py::TestMatDescriptor::test_pickle - As...
FAILED tests/cupy_tests/core_tests/test_ndarray_conversion.py::TestNdarrayToBytes_param_1_{shape=(1,)}::test_item
FAILED tests/cupy_tests/core_tests/test_ndarray_conversion.py::TestNdarrayToBytes_param_2_{shape=(2, 3)}::test_item
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_0_{indexes=(1, 0, 2), shape=(2, 3, 4), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_1_{indexes=(-1, 0, -2), shape=(2, 3, 4), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_2_{indexes=(1, 0, 2), shape=(2, 3, 4), transpose=(2, 0, 1)}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_3_{indexes=(-1, 0, -2), shape=(2, 3, 4), transpose=(2, 0, 1)}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_27_{indexes=(slice(-4, -5, -1),), shape=(10,), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_38_{indexes=(slice(-5, -6, -1),), shape=(10,), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_unary_op.py::TestArrayBoolOp::test_bool_one_element
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)}::test_fft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)}::test_ifft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)}::test_fft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)}::test_ifft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)}::test_fft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)}::test_ifft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)}::test_fft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)}::test_ifft
FAILED tests/cupy_tests/cuda_tests/test_device.py::TestDeviceHandles::test_cusparse_handle
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_0_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_1_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_2_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_3_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_4_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_5_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_6_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_7_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_8_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_9_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_10_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_11_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_12_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_13_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_14_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_15_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_16_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_17_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_18_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_19_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_20_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_21_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_22_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_23_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_24_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_25_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_26_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_27_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_28_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_29_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_30_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_31_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_32_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_33_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_34_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_35_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_36_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_37_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_38_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_39_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_40_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_41_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_42_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_43_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_44_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_45_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_46_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_47_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_48_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_49_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_50_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_51_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_52_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_53_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_54_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_55_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_56_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_57_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_58_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_59_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_60_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_61_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_62_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_63_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_64_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_65_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_66_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_67_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_68_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_69_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_70_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_71_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_72_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_73_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_74_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_75_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_76_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_77_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_78_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_79_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_80_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_81_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_82_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_83_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_84_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_85_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_86_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_87_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_88_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_89_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_90_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_91_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_92_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_93_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_94_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_95_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_96_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_97_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_98_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_99_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_100_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_101_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_102_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_103_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_104_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_105_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_106_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_107_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_108_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_109_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_110_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_111_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_112_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_113_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_114_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_115_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_116_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_117_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_118_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_119_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_120_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_121_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_122_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_123_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_124_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_125_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_126_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_127_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_128_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_129_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_130_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_131_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_132_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_133_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_134_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_135_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_136_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_137_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_138_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_139_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_140_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_141_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_142_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_143_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_144_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_145_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_146_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_147_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_148_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_149_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_150_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_151_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_152_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_153_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_154_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_155_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_156_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_157_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_158_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_159_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_160_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_161_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_162_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_163_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_164_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_165_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_166_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_167_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_168_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_169_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_170_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_171_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_172_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_173_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_174_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_175_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_176_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_177_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_178_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_179_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_180_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_181_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_182_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_183_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_184_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_185_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_186_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_187_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_188_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_189_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_190_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_191_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_192_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_193_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_194_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_195_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_196_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_197_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_198_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_199_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_200_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_201_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_202_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_203_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_204_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_205_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_206_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_207_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_208_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_209_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_210_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_211_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_212_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_213_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_214_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_215_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_216_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_217_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_218_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_219_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_220_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_221_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_222_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_223_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_224_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_225_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_226_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_227_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_228_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_229_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_230_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_231_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_232_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_233_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_234_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_235_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_236_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_237_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_238_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_239_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_240_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_241_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_242_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_243_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_244_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_245_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_246_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_247_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_248_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_249_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_250_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_251_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_252_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_253_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_254_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_255_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_256_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_257_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_258_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_259_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_260_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_261_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_262_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_263_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_264_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_265_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_266_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_267_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_268_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_269_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_270_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_271_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_272_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_273_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_274_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_275_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_276_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_277_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_278_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_279_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_280_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_281_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_282_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_283_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_284_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_285_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_286_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_287_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_0_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_1_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_2_{dimensions=(64, 0, 0), mem_type='linear', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_3_{dimensions=(64, 0, 0), mem_type='linear', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_6_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_7_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_10_{dimensions=(64, 32, 0), mem_type='pitch2D', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_11_{dimensions=(64, 32, 0), mem_type='pitch2D', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_12_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_13_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTextureVectorType_param_0_{target='object'}::test_fetch_float4_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTextureVectorType_param_1_{target='reference'}::test_fetch_float4_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestSurface_param_0_{dimensions=(64, 0, 0)}::test_write_float_surface
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestSurface_param_1_{dimensions=(64, 32, 0)}::test_write_float_surface
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestSurface_param_2_{dimensions=(64, 32, 32)}::test_write_float_surface
FAILED tests/cupy_tests/indexing_tests/test_generate.py::TestIX_::test_ix_ndarray
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_0_{fname='add', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_1_{fname='add', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_2_{fname='add', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_3_{fname='add', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_4_{fname='subtract', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_5_{fname='subtract', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_6_{fname='subtract', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_7_{fname='subtract', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_8_{fname='multiply', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_9_{fname='multiply', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_10_{fname='multiply', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_11_{fname='multiply', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_12_{fname='divide', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_13_{fname='divide', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_14_{fname='divide', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_15_{fname='divide', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_16_{fname='power', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_17_{fname='power', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_18_{fname='power', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_19_{fname='power', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyArithmeticDiffTypes_param_2_{fname='polymul'}::test_polyroutine_diff_types_array
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyArithmeticDiffTypes_param_2_{fname='polymul'}::test_polyroutine_diff_types_poly1d
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_0_{cov='unscaled', deg=0, rcond=None, shape=(3,), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_1_{cov='unscaled', deg=0, rcond=None, shape=(3,), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_2_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_3_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_4_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_5_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_6_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_7_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_16_{cov=True, deg=0, rcond=None, shape=(3,), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_17_{cov=True, deg=0, rcond=None, shape=(3,), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_18_{cov=True, deg=0, rcond=None, shape=(3, 2), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_19_{cov=True, deg=0, rcond=None, shape=(3, 2), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_20_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_21_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_22_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_23_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsReal_param_0_{input=[2, -1, -2]}::test_roots_array
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsReal_param_0_{input=[2, -1, -2]}::test_roots_poly1d
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsReal_param_1_{input=[-4, 10, 4]}::test_roots_array
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsReal_param_1_{input=[-4, 10, 4]}::test_roots_poly1d
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]}::test_roots_array
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]}::test_roots_poly1d
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1d::test_poly1d_roots
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_0_{UPLO='U'}::test_eigh
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_0_{UPLO='U'}::test_eigh_complex
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_0_{UPLO='U'}::test_eigh_float16
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_0_{UPLO='U'}::test_eigvalsh
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_1_{UPLO='L'}::test_eigh
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_1_{UPLO='L'}::test_eigh_complex
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_1_{UPLO='L'}::test_eigh_float16
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_1_{UPLO='L'}::test_eigvalsh
FAILED tests/cupy_tests/manipulation_tests/test_dims.py::TestBroadcast_param_2_{shapes=[(1,), (1,)]}::test_broadcast_arrays
FAILED tests/cupy_tests/manipulation_tests/test_dims.py::TestBroadcast_param_3_{shapes=[(2,), (2,)]}::test_broadcast_arrays
FAILED tests/cupy_tests/math_tests/test_misc.py::TestConvolve_param_0_{mode='valid'}::test_convolve_diff_types
FAILED tests/cupy_tests/math_tests/test_misc.py::TestConvolve_param_1_{mode='same'}::test_convolve_diff_types
FAILED tests/cupy_tests/math_tests/test_misc.py::TestConvolve_param_2_{mode='full'}::test_convolve_diff_types
FAILED tests/cupy_tests/math_tests/test_rational.py::TestRational::test_lcm_check_boundary_cases
FAILED tests/cupy_tests/random_tests/test_generator.py::TestRandomState::test_methods
FAILED tests/cupy_tests/random_tests/test_generator.py::TestChoiceChi::test_goodness_of_fit_2
FAILED tests/cupy_tests/random_tests/test_sample.py::TestRandint2::test_goodness_of_fit_2
FAILED tests/cupy_tests/random_tests/test_sample.py::TestRandomIntegers2::test_goodness_of_fit_2
FAILED tests/cupy_tests/statistics_tests/test_correlation.py::TestCorrelate_param_0_{mode='valid'}::test_correlate_diff_types
FAILED tests/cupy_tests/statistics_tests/test_correlation.py::TestCorrelate_param_1_{mode='full'}::test_correlate_diff_types
FAILED tests/cupy_tests/statistics_tests/test_correlation.py::TestCorrelate_param_1_{mode='full'}::test_correlate_non_contiguous
FAILED tests/cupy_tests/statistics_tests/test_correlation.py::TestCorrelate_param_2_{mode='same'}::test_correlate_diff_types
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_0_{dtype=float32, size=5}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_1_{dtype=float32, size=9}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_2_{dtype=float32, size=17}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_3_{dtype=float32, size=33}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_4_{dtype=float64, size=5}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_5_{dtype=float64, size=9}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_6_{dtype=float64, size=17}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_7_{dtype=float64, size=33}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_8_{dtype=complex64, size=5}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_9_{dtype=complex64, size=9}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_10_{dtype=complex64, size=17}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_11_{dtype=complex64, size=33}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_12_{dtype=complex128, size=5}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_13_{dtype=complex128, size=9}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_14_{dtype=complex128, size=17}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_15_{dtype=complex128, size=33}::test_invh
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_0_{dtype=float32}::test_basic_vstack
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_0_{dtype=float32}::test_csr
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_0_{dtype=float32}::test_csr_with_dtype
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_1_{dtype=float64}::test_basic_vstack
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_1_{dtype=float64}::test_csr
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_1_{dtype=float64}::test_csr_with_dtype
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_0_{dtype=float32}::test_basic_hstack
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_0_{dtype=float32}::test_csc
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_0_{dtype=float32}::test_csc_with_dtype
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_1_{dtype=float64}::test_basic_hstack
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_1_{dtype=float64}::test_csc
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_1_{dtype=float64}::test_csc_with_dtype
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_0_{dtype=float32}::test_basic_inputs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_0_{dtype=float32}::test_edge_cases
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_0_{dtype=float32}::test_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_0_{dtype=float32}::test_failure_cases
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_1_{dtype=float64}::test_basic_inputs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_1_{dtype=float64}::test_edge_cases
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_1_{dtype=float64}::test_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_1_{dtype=float64}::test_failure_cases
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}::test_random_with_data_rvs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}::test_random_with_data_rvs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_4_{dtype=float32, format='coo', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_4_{dtype=float32, format='coo', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_5_{dtype=float32, format='coo', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_5_{dtype=float32, format='coo', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}::test_random_with_data_rvs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}::test_random_with_data_rvs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_10_{dtype=float64, format='coo', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_10_{dtype=float64, format='coo', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_11_{dtype=float64, format='coo', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_11_{dtype=float64, format='coo', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_0_{dtype=float32}::test_init_copy
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_0_{dtype=float32}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_0_{dtype=float32}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_1_{dtype=float64}::test_init_copy
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_1_{dtype=float64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_1_{dtype=float64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_2_{dtype=complex64}::test_init_copy
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_2_{dtype=complex64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_2_{dtype=complex64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_3_{dtype=complex128}::test_init_copy
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_3_{dtype=complex128}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_3_{dtype=complex128}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py::TestDiaMatrix_param_0_{dtype=float32}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py::TestDiaMatrix_param_1_{dtype=float64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py::TestDiaMatrix_param_2_{dtype=complex64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py::TestDiaMatrix_param_3_{dtype=complex128}::test_toarray
FAILED tests/example_tests/test_finance.py::TestMonteCarlo::test_monte_carlo
FAILED tests/example_tests/test_finance.py::TestMonteCarloWithMultiGPU::test_monte_carlo_multigpu
FAILED tests/install_tests/test_build.py::TestCheckVersion::test_check_cuda_version
FAILED tests/install_tests/test_build.py::TestCheckVersion::test_check_cudnn_version
XPASS tests/cupy_tests/sorting_tests/test_sort.py::TestMsort::test_msort_zero_dim Explicit error types required
= 574 failed, 24461 passed, 61513 skipped, 56 deselected, 14 xfailed, 1 xpassed, 209 warnings in 13770.94s (3:49:30) =
