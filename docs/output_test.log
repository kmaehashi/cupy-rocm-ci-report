============================= test session starts ==============================
platform linux -- Python 3.8.7, pytest-6.2.2, py-1.10.0, pluggy-0.13.1
rootdir: /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.huAymRnpdw/cupy, configfile: setup.cfg
plugins: html-3.1.1, metadata-1.11.0
collected 71407 items / 57 deselected / 12 skipped / 71338 selected

tests/cupy_tests/test_cublas.py ........................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  3%]
........................................................................ [  3%]
........................................................................ [  3%]
...........................x...........x.............................x.. [  3%]
.........x..........                                                     [  3%]
tests/cupy_tests/test_cudnn.py sssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssss                  [  5%]
tests/cupy_tests/test_cusolver.py ssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssss                                               [  6%]
tests/cupy_tests/test_cutensor.py ssssssssssssssssssssssssssssssssssssss [  6%]
sssssssssssssssssssssssssssssssssssss                                    [  6%]
tests/cupy_tests/test_init.py ..s.......                                 [  6%]
tests/cupy_tests/test_ndim.py ............                               [  7%]
tests/cupy_tests/test_numpy_interop.py ..x....                           [  7%]
tests/cupy_tests/test_type_routines.py ................................. [  7%]
.                                                                        [  7%]
tests/cupy_tests/binary_tests/test_elementwise.py ......                 [  7%]
tests/cupy_tests/binary_tests/test_packing.py ...                        [  7%]
tests/cupy_tests/core_tests/test_array_function.py .....                 [  7%]
tests/cupy_tests/core_tests/test_carray.py .....                         [  7%]
tests/cupy_tests/core_tests/test_core.py ....                            [  7%]
tests/cupy_tests/core_tests/test_cub_reduction.py ...................... [  7%]
...                                                                      [  7%]
tests/cupy_tests/core_tests/test_dlpack.py ....                          [  7%]
tests/cupy_tests/core_tests/test_elementwise.py ...............          [  7%]
tests/cupy_tests/core_tests/test_flags.py .............................  [  7%]
tests/cupy_tests/core_tests/test_function.py ..                          [  7%]
tests/cupy_tests/core_tests/test_internal.py ........................... [  7%]
...............................................................          [  7%]
tests/cupy_tests/core_tests/test_iter.py ............                    [  7%]
tests/cupy_tests/core_tests/test_ndarray.py ..........................ss [  7%]
ssss.................................................................... [  7%]
.........................sss...............                              [  7%]
tests/cupy_tests/core_tests/test_ndarray_adv_indexing.py ............... [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
.............................................                            [  7%]
tests/cupy_tests/core_tests/test_ndarray_complex_ops.py ................ [  7%]
.....                                                                    [  7%]
tests/cupy_tests/core_tests/test_ndarray_contiguity.py .                 [  7%]
tests/cupy_tests/core_tests/test_ndarray_conversion.py .......xx..       [  7%]
tests/cupy_tests/core_tests/test_ndarray_copy_and_view.py ss........s... [  7%]
....ssss.......                                                          [  8%]
tests/cupy_tests/core_tests/test_ndarray_cuda_array_interface.py sssssss [  8%]
sssssssssssssssssssssssssssssssssssssssssssssssss                        [  8%]
tests/cupy_tests/core_tests/test_ndarray_elementwise_op.py ............. [  8%]
........................................................................ [  8%]
.................................................................        [  8%]
tests/cupy_tests/core_tests/test_ndarray_get.py ............             [  8%]
tests/cupy_tests/core_tests/test_ndarray_indexing.py xxxx..........x...x [  8%]
........x..........x.............................                        [  8%]
tests/cupy_tests/core_tests/test_ndarray_math.py ......................s [  8%]
sssssssssss                                                              [  8%]
tests/cupy_tests/core_tests/test_ndarray_owndata.py ...                  [  8%]
tests/cupy_tests/core_tests/test_ndarray_reduction.py .................. [  8%]
........................................................................ [  8%]
........................................................................ [  8%]
................................                                         [  8%]
tests/cupy_tests/core_tests/test_ndarray_scatter.py .................... [  8%]
........................................................................ [  8%]
...............................................................          [  8%]
tests/cupy_tests/core_tests/test_ndarray_ufunc.py .......                [  8%]
tests/cupy_tests/core_tests/test_ndarray_unary_op.py .......x..........s [  8%]
...                                                                      [  8%]
tests/cupy_tests/core_tests/test_raw.py .ss.........sss..s.s.s........ss [  9%]
.........sss..s.s.s........ss.........sss..s.s.s......ssssssssssssssssss [  9%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.s [  9%]
s.......sssss....s.s......sssssssssssssssssssssssssssss                  [  9%]
tests/cupy_tests/core_tests/test_reduction.py .....................      [  9%]
tests/cupy_tests/core_tests/test_scan.py ....                            [  9%]
tests/cupy_tests/core_tests/test_syncdetect.py ....                      [  9%]
tests/cupy_tests/core_tests/test_userkernel.py ....sss.............      [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_array.py ................. [  9%]
........................................................................ [  9%]
....................................................                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_indexing.py .............. [  9%]
.................s                                                       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py ....       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_misc.py .......s.......... [  9%]
........                                                                 [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_optimization.py .......... [  9%]
....                                                                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_reduction.py ............. [  9%]
........................................................................ [  9%]
.........................................................s.s.s.s.s.s.s.s [  9%]
.s.ssssssssssssssssss.sss                                                [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_routines.py .............. [  9%]
........................................................................ [ 10%]
..............                                                           [ 10%]
tests/cupy_tests/core_tests/fusion_tests/test_ufunc.py ................. [ 10%]
......................................................                   [ 10%]
tests/cupy_tests/creation_tests/test_basic.py .......................... [ 10%]
...........................................................s............ [ 10%]
....s.                                                                   [ 10%]
tests/cupy_tests/creation_tests/test_from_data.py ssssssssssssssssssssss [ 10%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss............. [ 10%]
...................................................................      [ 10%]
tests/cupy_tests/creation_tests/test_matrix.py ......................... [ 10%]
.................................                                        [ 10%]
tests/cupy_tests/creation_tests/test_ranges.py ......................... [ 10%]
..............................................................           [ 10%]
tests/cupy_tests/cuda_tests/test_compiler.py sssssss........             [ 10%]
tests/cupy_tests/cuda_tests/test_cublas.py .                             [ 10%]
tests/cupy_tests/cuda_tests/test_cudnn.py s                              [ 10%]
tests/cupy_tests/cuda_tests/test_cufft.py ssssssssssssssss.              [ 10%]
tests/cupy_tests/cuda_tests/test_curand.py .....                         [ 10%]
tests/cupy_tests/cuda_tests/test_cusolver.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cusparse.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cutensor.py s                           [ 10%]
tests/cupy_tests/cuda_tests/test_device.py .............x.               [ 10%]
tests/cupy_tests/cuda_tests/test_driver.py ss.                           [ 10%]
tests/cupy_tests/cuda_tests/test_memory.py ....ssssssss................. [ 10%]
.ssssssssss.................................................ssssss       [ 10%]
tests/cupy_tests/cuda_tests/test_memory_hook.py .                        [ 10%]
tests/cupy_tests/cuda_tests/test_nccl.py ........                        [ 10%]
tests/cupy_tests/cuda_tests/test_nvrtc.py .                              [ 10%]
tests/cupy_tests/cuda_tests/test_nvtx.py ....                            [ 11%]
tests/cupy_tests/cuda_tests/test_pinned_memory.py ............           [ 11%]
tests/cupy_tests/cuda_tests/test_profile.py ..                           [ 11%]
tests/cupy_tests/cuda_tests/test_runtime.py .                            [ 11%]
tests/cupy_tests/cuda_tests/test_stream.py ..s..s..ssssssss.s            [ 11%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_debug_print.py .     [ 11%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_line_profile.py ..   [ 11%]
tests/cupy_tests/fft_tests/test_cache.py ..sss.....s..                   [ 11%]
tests/cupy_tests/fft_tests/test_callback.py ssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssss                     [ 11%]
tests/cupy_tests/fft_tests/test_fft.py ....ssss....ssss........ssss....s [ 11%]
sss........ssss....ssss........ssss....ssss........ssss....ssss........s [ 12%]
sss....ssss........ssss....ssss........ssss....ssss........ssss....ssss. [ 12%]
.......ssss....ssss....................................................s [ 12%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 12%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss. [ 12%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 12%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s [ 12%]
..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s.. [ 12%]
s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s. [ 12%]
s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s. [ 12%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 13%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.s.s.sssss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.sssss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.sss [ 13%]
ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.s.s..s.s. [ 13%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 13%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s...ss..ss....ss..ss....ss..ss....ss [ 13%]
..ss....ss..ss....ss..ss....ss..ss....ss..ss...s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.s.s.s.s.s.s.s.s.s.s.s.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s. [ 13%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 14%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s......s.s..s.s..s.s..s.s..s.s..s.s. [ 14%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 14%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s [ 14%]
..s.s..s.s..s.s..s.s..s.s..s.s..s.s.sssss.s.s..s.s.sssssssssssssssssssss [ 14%]
ssssssssssssssssssssssssssssssssssssssssssss.s.s..s.s..s.s..s.s..s.s..s. [ 14%]
s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s. [ 14%]
.s.s..s.s..s.s..s.s..s.s..s.s.......ss..ss....ss..ss....ss..ss....ss..ss [ 14%]
....ss..ss....ss..ss....ss..ss....ss..ss........................         [ 14%]
tests/cupy_tests/functional_tests/test_piecewise.py .............        [ 14%]
tests/cupy_tests/functional_tests/test_vectorize.py .................... [ 14%]
..............................                                           [ 14%]
tests/cupy_tests/indexing_tests/test_generate.py .......x............... [ 14%]
...............                                                          [ 14%]
tests/cupy_tests/indexing_tests/test_indexing.py ....................... [ 15%]
.........................                                                [ 15%]
tests/cupy_tests/indexing_tests/test_insert.py ......................... [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
.........................................................                [ 15%]
tests/cupy_tests/indexing_tests/test_iterate.py ........................ [ 15%]
...............................................                          [ 15%]
tests/cupy_tests/io_tests/test_base_n.py ............................    [ 15%]
tests/cupy_tests/io_tests/test_formatting.py ..                          [ 15%]
tests/cupy_tests/io_tests/test_npz.py .......                            [ 15%]
tests/cupy_tests/lib_tests/test_polynomial.py .......ss.......ssssssssss [ 15%]
sssssss........ssssssssssssssssssssssssssssssssssssxxxxxxxxxxxxxxxxxxxx. [ 15%]
..ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 15%]
ssssssssssssssssssssssssss......xxxxxxxxxxxxxxxxxxxxxxxx................ [ 15%]
........................................................................ [ 15%]
........xxxxxxxx........xxxxxxxx........................................ [ 16%]
...........xxxxxx............................x.......................... [ 16%]
..                                                                       [ 16%]
tests/cupy_tests/lib_tests/test_shape_base.py ......................     [ 16%]
tests/cupy_tests/lib_tests/test_strided_tricks.py ..                     [ 16%]
tests/cupy_tests/linalg_tests/test_decomposition.py .................... [ 16%]
.......................                                                  [ 16%]
tests/cupy_tests/linalg_tests/test_eigenvalue.py xxxxxxxx                [ 16%]
tests/cupy_tests/linalg_tests/test_einsum.py ........................... [ 16%]
................................................................F....... [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
..........                                                               [ 17%]
tests/cupy_tests/linalg_tests/test_norms.py ............................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
.................................................................        [ 17%]
tests/cupy_tests/linalg_tests/test_product.py .......................... [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
..........................................                               [ 17%]
tests/cupy_tests/linalg_tests/test_solve.py ............................ [ 18%]
                                                                         [ 18%]
tests/cupy_tests/logic_tests/test_comparison.py ........................ [ 18%]
.....                                                                    [ 18%]
tests/cupy_tests/logic_tests/test_content.py ...                         [ 18%]
tests/cupy_tests/logic_tests/test_ops.py ....                            [ 18%]
tests/cupy_tests/logic_tests/test_truth.py ............................. [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 19%]
...........................................                              [ 19%]
tests/cupy_tests/logic_tests/test_type_test.py ......................... [ 19%]
.......                                                                  [ 19%]
tests/cupy_tests/manipulation_tests/test_add_remove.py ................. [ 19%]
.........................                                                [ 19%]
tests/cupy_tests/manipulation_tests/test_basic.py ...................... [ 19%]
.......................................................                  [ 19%]
tests/cupy_tests/manipulation_tests/test_dims.py .....x.x............... [ 19%]
..........F.....................................                         [ 19%]
tests/cupy_tests/manipulation_tests/test_join.py ....................... [ 19%]
...........................                                              [ 19%]
tests/cupy_tests/manipulation_tests/test_kind.py ...........             [ 19%]
tests/cupy_tests/manipulation_tests/test_rearrange.py .................. [ 19%]
.......................................................                  [ 19%]
tests/cupy_tests/manipulation_tests/test_shape.py ...................... [ 19%]
....................................                                     [ 19%]
tests/cupy_tests/manipulation_tests/test_split.py ..................     [ 19%]
tests/cupy_tests/manipulation_tests/test_tiling.py ..................... [ 19%]
...........                                                              [ 19%]
tests/cupy_tests/manipulation_tests/test_transpose.py .................. [ 19%]
..........                                                               [ 19%]
tests/cupy_tests/math_tests/test_arithmetic.py ......................... [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 31%]
...........................                                              [ 31%]
tests/cupy_tests/math_tests/test_explog.py .........                     [ 31%]
tests/cupy_tests/math_tests/test_floating.py .......                     [ 31%]
tests/cupy_tests/math_tests/test_hyperbolic.py ......                    [ 31%]
tests/cupy_tests/math_tests/test_matmul.py ............................. [ 31%]
........................................................................ [ 31%]
........................................................................ [ 31%]
........................................................................ [ 31%]
...............................................                          [ 31%]
tests/cupy_tests/math_tests/test_misc.py ............................... [ 31%]
............................................x..x..x..................... [ 31%]
............................                                             [ 31%]
tests/cupy_tests/math_tests/test_rational.py ....                        [ 31%]
tests/cupy_tests/math_tests/test_rounding.py ........................... [ 31%]
..........................................                               [ 31%]
tests/cupy_tests/math_tests/test_special.py ...                          [ 31%]
tests/cupy_tests/math_tests/test_sumprod.py ............................ [ 31%]
....................................................ssssssssssssssss.... [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
..............................................................           [ 32%]
tests/cupy_tests/math_tests/test_trigonometric.py ...............        [ 32%]
tests/cupy_tests/math_tests/test_window.py ............................. [ 32%]
.....                                                                    [ 32%]
tests/cupy_tests/misc_tests/test_memory_ranges.py ................       [ 32%]
tests/cupy_tests/misc_tests/test_who.py ......                           [ 32%]
tests/cupy_tests/padding_tests/test_pad.py ............................. [ 33%]
..............................................                           [ 33%]
tests/cupy_tests/polynomial_tests/test_polynomial.py ................... [ 33%]
                                                                         [ 33%]
tests/cupy_tests/polynomial_tests/test_polyutils.py .................... [ 33%]
................                                                         [ 33%]
tests/cupy_tests/prof_tests/test_range.py ........                       [ 33%]
tests/cupy_tests/random_tests/test_bit_generator.py ssssssssssss         [ 33%]
tests/cupy_tests/random_tests/test_distributions.py .................... [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
.................................................                        [ 34%]
tests/cupy_tests/random_tests/test_generator.py ........................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 35%]
......................s.s............................................... [ 35%]
............................x...............................             [ 35%]
tests/cupy_tests/random_tests/test_generator_api.py ssssssssssssssssssss [ 35%]
ssssss                                                                   [ 35%]
tests/cupy_tests/random_tests/test_init.py .                             [ 35%]
tests/cupy_tests/random_tests/test_permutations.py ...x...x............. [ 35%]
........................................................................ [ 35%]
........................................................................ [ 35%]
.............                                                            [ 35%]
tests/cupy_tests/random_tests/test_random.py .                           [ 35%]
tests/cupy_tests/random_tests/test_sample.py ...............x........x.. [ 35%]
............                                                             [ 35%]
tests/cupy_tests/sorting_tests/test_count.py ....                        [ 35%]
tests/cupy_tests/sorting_tests/test_search.py ssssssss........ssssssss.. [ 35%]
........................................................................ [ 35%]
........................................................................ [ 35%]
....................................................................     [ 35%]
tests/cupy_tests/sorting_tests/test_sort.py ............................ [ 35%]
........................................................................ [ 36%]
..........................................................x...........   [ 36%]
tests/cupy_tests/statistics_tests/test_correlation.py .................. [ 36%]
..............................x..x.xx...................                 [ 36%]
tests/cupy_tests/statistics_tests/test_histogram.py .................... [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................                 [ 36%]
tests/cupy_tests/statistics_tests/test_meanvar.py ...................... [ 36%]
........................................................................ [ 36%]
........................................................................ [ 37%]
..                                                                       [ 37%]
tests/cupy_tests/statistics_tests/test_order.py sssss................... [ 37%]
.........................                                                [ 37%]
tests/cupy_tests/testing_tests/test_array.py ........................... [ 37%]
...............................................                          [ 37%]
tests/cupy_tests/testing_tests/test_condition.py ................        [ 37%]
tests/cupy_tests/testing_tests/test_helper.py .......................... [ 37%]
........................................................................ [ 37%]
.....sssss..sssssss..ssxxxxxxxx................x..x.................     [ 37%]
tests/cupy_tests/testing_tests/test_parameterized.py ............s.s.s.s [ 37%]
....ssss......                                                           [ 37%]
tests/cupyx_tests/test_cupyx.py ..                                       [ 37%]
tests/cupyx_tests/test_lapack.py .s.s.s.s.....s.s.s.s.....s.s.s.s.....s. [ 37%]
s.s.s.............sssssssssssss                                          [ 37%]
tests/cupyx_tests/test_optimize.py sssssssss                             [ 37%]
tests/cupyx_tests/test_rsqrt.py .                                        [ 37%]
tests/cupyx_tests/test_runtime.py s.                                     [ 37%]
tests/cupyx_tests/test_scatter.py ...                                    [ 37%]
tests/cupyx_tests/test_time.py .........                                 [ 37%]
tests/cupyx_tests/fallback_mode_tests/test_fallback.py ................. [ 37%]
........................................................................ [ 37%]
.........                                                                [ 37%]
tests/cupyx_tests/fallback_mode_tests/test_notifications.py .........    [ 37%]
tests/cupyx_tests/jit_tests/test_raw.py ....                             [ 37%]
tests/cupyx_tests/linalg_tests/test_solve.py xxxxxxxxxxxxxxxx....ssss    [ 37%]
tests/cupyx_tests/scipy_tests/test_get_array_module.py ..                [ 37%]
tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py .................... [ 37%]
........................................................................ [ 37%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 48%]
........................................................................ [ 48%]
........................................................................ [ 48%]
.................sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss........................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
......................................                                   [ 51%]
tests/cupyx_tests/scipy_tests/fft_tests/test_helper.py .                 [ 51%]
tests/cupyx_tests/scipy_tests/fftpack_tests/test_fftpack.py ............ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
.........................                                                [ 52%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py ........... [ 52%]
...................................................                      [ 52%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_solve_triangular.py .... [ 52%]
........................................................................ [ 52%]
........................................................................ [ 53%]
........................................................................ [ 53%]
....................................................................     [ 53%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_special_matrices.py .... [ 53%]
........................................................................ [ 53%]
.................................................                        [ 53%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py ...sss...... [ 53%]
sss......sss......sss......sss......sss.........sss......sss......sss... [ 53%]
...sss......sss......sss................................................ [ 53%]
...........................................................sss......sss. [ 53%]
.....sss......sss......sss......sss.........sss......sss......sss......s [ 53%]
ss......sss......sss.................................................... [ 53%]
.......................................................sss......sss..... [ 54%]
.sss......sss......sss......sss.........sss......sss......sss......sss.. [ 54%]
....sss......sss........................................................ [ 54%]
...................................................sss......sss......sss [ 54%]
......sss......sss......sss.........sss......sss......sss......sss...... [ 54%]
sss......sss............................................................ [ 54%]
...............................................sss......sss......sss.... [ 54%]
..sss......sss......sss.........sss......sss......sss......sss......sss. [ 54%]
.....sss................................................................ [ 54%]
...........................................sss......sss......sss......ss [ 54%]
s......sss......sss.........sss......sss......sss......sss......sss..... [ 55%]
.sss.................................................................... [ 55%]
.......................................sss......sss......sss......sss... [ 55%]
...sss......sss.........sss......sss......sss......sss......sss......sss [ 55%]
........................................................................ [ 55%]
...................................sss......sss......sss......sss......s [ 55%]
ss......sss.........sss......sss......sss......sss......sss......sss.... [ 55%]
........................................................................ [ 55%]
...............................sss......sss......sss......sss......sss.. [ 55%]
....sss.........sss......sss......sss......sss......sss......sss........ [ 55%]
........................................................................ [ 56%]
...........................sss......sss......sss......sss......sss...... [ 56%]
sss.........sss......sss......sss......sss......sss......sss............ [ 56%]
........................................................................ [ 56%]
.......................sss......sss......sss......sss......sss......sss. [ 56%]
........sss......sss......sss......sss......sss......sss................ [ 56%]
........................................................................ [ 56%]
...................sss......sss......sss......sss......sss......sss..... [ 56%]
....sss......sss......sss......sss......sss......sss.................... [ 56%]
........................................................................ [ 56%]
...............sss......sss......sss......sss......sss......sss......... [ 57%]
sss......sss......sss......sss......sss......sss........................ [ 57%]
........................................................................ [ 57%]
...........sss......sss......sss......sss......sss......sss.........sss. [ 57%]
.....sss......sss......sss......sss......sss............................ [ 57%]
........................................................................ [ 57%]
xxx....sss......sss......sss......sss......sss......sss....x..x.sss.x..x [ 57%]
.sss.x..x.sss......sss......sss......sss................................ [ 57%]
.....................................................x..x.............x. [ 57%]
......................................x.....x....x.....x......x.....x... [ 57%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................F.F.F.F......................................... [ 59%]
........................................................................ [ 59%]
................................................F.F..................... [ 59%]
........................................................................ [ 59%]
................................................................F.F.F.F. [ 59%]
........................................................................ [ 59%]
........................................................................ [ 59%]
................F.F..................................................... [ 59%]
........................................................................ [ 59%]
........................................................................ [ 59%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 60%]
........................................................................ [ 60%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 60%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 61%]
.............................................................s.s.s.s.s.s [ 61%]
.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 61%]
........................................................................ [ 61%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 61%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 61%]
.............................................................s.s.s.s.s.s [ 61%]
.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 61%]
........................................................................ [ 61%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 61%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 62%]
.............................................................s.s.s.s.s.s [ 62%]
.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 62%]
........................................................................ [ 62%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 62%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 62%]
.............................................................s.s.s.s.s.s [ 62%]
.s.s.s.s.s.s.s.s.s.s.s.ssss..sss..sss............sss..sss..sss.......... [ 62%]
..sss..sss..sss............sss..sss..sss............sss..sss..sss....... [ 62%]
.....sss..sss..sss............sss..sss..sss............sss..sss..sss.... [ 62%]
........sss..sss..sss............sss..sss..sss............sss..sss..sss. [ 63%]
...........sss..sss..sss................................................ [ 63%]
........................................................................ [ 63%]
....................................                                     [ 63%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_fourier.py ............ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 64%]
........................................                                 [ 64%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py ...... [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
...............................F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 77%]
.F...F.F...F.F...F...................................................... [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
.....................s.................................................. [ 78%]
........................................................................ [ 78%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
...........................F........F..F..F........s.................... [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
.......F.....F....................F.....F....................F.....F.... [ 80%]
................F.....F....................F.....F....................F. [ 80%]
....F....................F.....F....................F.....F............. [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................s............................... [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
.................................ss..................................... [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
...........ssssssssssssssssssssssssssssssssssssssssssssssss              [ 82%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py ....... [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 86%]
........................................................................ [ 86%]
........................................................................ [ 86%]
........................................................................ [ 86%]
.....xx..........xx..........xx..........xx..........xx................. [ 86%]
.....xx..................................xx............................. [ 86%]
.....xx..........xx..........xx..........xx..........xx................. [ 86%]
.....xx..................................xx............................. [ 86%]
........................................................................ [ 86%]
........................................................................ [ 86%]
...                                                                      [ 86%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_morphology.py ......... [ 86%]
......................s....s....s..s....s....s.......................... [ 87%]
..........s....s....s..s....s....s....................................s. [ 87%]
...s....s..s....s....s....................................s....s....s..s [ 87%]
....s....s....................................s....s....s..s....s....s.. [ 87%]
..................................s....s....s..s....s....s.............. [ 87%]
......................s....s....s..s....s....s.......................... [ 87%]
..........s....s....s..s....s....s....................................s. [ 87%]
...s....s..s....s....s....................................s....s....s..s [ 87%]
....s....s....................................s....s....s..s....s....s.. [ 87%]
..................................s....s....s..s....s....s.............. [ 88%]
......................s....s....s..s....s....s.......................... [ 88%]
..........s....s....s..s....s....s....................................s. [ 88%]
...s....s..s....s....s....................................s....s....s..s [ 88%]
....s....s....................................s....s....s..s....s....s.. [ 88%]
..................................s....s....s..s....s....s.............. [ 88%]
......................s....s....s..s....s....s.......................... [ 88%]
..........s....s....s..s....s....s....................................s. [ 88%]
...s....s..s....s....s....................................s....s....s..s [ 88%]
....s....s....................................s....s....s..s....s....s.. [ 88%]
..................................s....s....s..s....s....s.............. [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
.......................................................................s [ 89%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 89%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............. [ 93%]
........................................................................ [ 93%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 93%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 93%]
..........................................s....s....s....s....s....s.... [ 93%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 93%]
s....s....s....s........................................................ [ 94%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 94%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 94%]
..........................................s....s....s....s....s....s.... [ 94%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 94%]
s....s....s....s........................................................ [ 94%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 94%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 94%]
..........................................s....s....s....s....s....s.... [ 94%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 94%]
s....s....s....s........................................................ [ 95%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 95%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 95%]
..........................................s....s....s....s....s....s.... [ 95%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 95%]
s....s....s....s........................................................ [ 95%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 95%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 95%]
..........................................s....s....s....s....s....s.... [ 95%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 95%]
s....s....s....s........................................................ [ 96%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 96%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 96%]
..........................................s....s....s....s....s....s.... [ 96%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 96%]
s....s....s....s........................................................ [ 96%]
........................................................................ [ 96%]
........................................................................ [ 96%]
........................................................................ [ 96%]
........................................................ssssssss........ [ 96%]
........................................................ssssssss........ [ 97%]
........................................................ssssssss........ [ 97%]
........................................................ssssssss........ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
                                                                         [ 98%]
tests/cupyx_tests/scipy_tests/signal_tests/test_bsplines.py ............ [ 98%]
                                                                         [ 98%]
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py ......... [ 98%]
........................................................................ [ 98%]
......................................................xxxxxxxxx......... [ 98%]
...........................xxxxxxxxxxxx................................. [ 99%]
............xxx..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x.. [ 99%]
x.x..................................................................... [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
....................................                                     [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_bessel.py ............  [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_convex_analysis.py .... [ 99%]
.                                                                        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_digamma.py .....        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_erf.py ............     [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gamma.py ....           [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gammaln.py ....         [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_polygamma.py ....       [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_statistics.py ..        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_zeta.py ....            [ 99%]
tests/cupyx_tests/scipy_tests/stats_tests/test_distributions.py ........ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
                                                                         [ 99%]
tests/cupyx_tests/tools_tests/test_install_library.py ..                 [ 99%]
tests/example_tests/test_finance.py ...                                  [ 99%]
tests/example_tests/test_gemm.py .                                       [ 99%]
tests/example_tests/test_gmm.py ss                                       [ 99%]
tests/example_tests/test_kmeans.py sss                                   [ 99%]
tests/install_tests/test_build.py sx.                                    [ 99%]
tests/install_tests/test_utils.py ..                                     [100%]

=================================== FAILURES ===================================
_ TestEinSumUnaryOperation_param_30_{_raw_params={'orig': {'shape_a': (2, 3), 'subscripts': '...'}, 'dec': 0, 'drop': True}, shape_a=(1, 1), subscripts='...'}.test_einsum_unary_dtype _
cupy/testing/_helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1.]], dtype=float16), desired = array([[1.]], dtype=float16)
rtol = 1e-07, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 1.
E       Max relative difference: 1.
E        x: array([[6.e-08]], dtype=float16)
E        y: array([[1.]], dtype=float16)

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
skipped: dtype_a = <class 'numpy.int16'>, dtype_out = <class 'numpy.uint64'> ()
skipped: dtype_a = <class 'numpy.uint16'>, dtype_out = <class 'numpy.int16'> ()
{'dtype_a': <class 'numpy.float16'>, 'dtype_out': <class 'numpy.float16'>}
__________________________ TestDims.test_atleast_2d2 ___________________________
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:648: in check_func
    _array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[[1., 2.],
        [3., 4.],
        [5., 6.]]], dtype=float32)
y = array([[[1., 2.],
        [3., 4.],
        [5., 6.]]], dtype=float32)
err_msg = '', verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 6 (33.3%)
E       Max absolute difference: 2.
E       Max relative difference: 1.
E        x: array([[[1.e-45, 0.e+00],
E               [3.e+00, 4.e+00],
E               [5.e+00, 6.e+00]]], dtype=float32)
E        y: array([[[1., 2.],
E               [3., 4.],
E               [5., 6.]]], dtype=float32)

cupy/testing/_array.py:91: AssertionError
_ TestGenericFilter.test_filter[_param_156_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6dbd453d0>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7ef7e804f700>}>
args = (), kw = {}
cupy_result = (array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[28, 38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]],...38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8))]
cupy_r = array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]], dtype=uint8)
numpy_r = array([[28, 38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]], dtype=uint8)
desired = array([[28, 38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 253
E       Max relative difference: 14.
E        x: array([[21, 31, 40, 31, 33],
E              [27, 29, 28, 20, 27],
E              [14, 25, 35, 34, 32],
E              [27, 26, 33, 25, 31]], dtype=uint8)
E        y: array([[28, 38, 48, 42, 45],
E              [32, 36, 44, 37, 44],
E              [18, 31, 45, 48, 55],
E              [22, 29, 41, 43, 54]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_158_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6dbc4e670>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7ef7e804f700>}>
args = (), kw = {}
cupy_result = (array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[34, 34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]],...34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8))]
cupy_r = array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
numpy_r = array([[34, 34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
desired = array([[34, 34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 251
E       Max relative difference: 8.48148148
E        x: array([[28, 24, 32, 32, 39],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0]], dtype=uint8)
E        y: array([[34, 34, 44, 37, 47],
E              [34, 34, 44, 37, 47],
E              [29, 29, 39, 37, 46],
E              [27, 27, 41, 38, 52]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_160_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6dbd67190>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7ef7e804f700>}>
args = (), kw = {}
cupy_result = (array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.011765...2, 44.03386405, 43.67148673, 48.63067102],
       [32.28830047, 30.15609296, 36.65741325, 35.73179981, 40.69098504]]),)
cupy_error = None
numpy_result = (array([[32.49418447, 44.26508328, 55.58324819, 50.90632842, 53.13241351],
       [36.78467189, 42.32410703, 50.513759...4, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.01176...4, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]]))]
cupy_r = array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.0117654...672, 44.03386405, 43.67148673, 48.63067102],
       [32.28830047, 30.15609296, 36.65741325, 35.73179981, 40.69098504]])
numpy_r = array([[32.49418447, 44.26508328, 55.58324819, 50.90632842, 53.13241351],
       [36.78467189, 42.32410703, 50.5137596...954, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.0117654...672, 44.03386405, 43.67148673, 48.63067102],
       [32.28830047, 30.15609296, 36.65741325, 35.73179981, 40.69098504]])
desired = array([[32.49418447, 44.26508328, 55.58324819, 50.90632842, 53.13241351],
       [36.78467189, 42.32410703, 50.5137596...954, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 19.36441258
E       Max relative difference: 0.34647974
E        x: array([[30.366597, 39.629756, 53.455653, 42.070115, 42.814124],
E              [33.368385, 37.733903, 33.011765, 32.58301 , 39.999025],
E              [18.994361, 35.440507, 44.033864, 43.671487, 48.630671],
E              [32.2883  , 30.156093, 36.657413, 35.7318  , 40.690985]])
E        y: array([[32.494184, 44.265083, 55.583248, 50.906328, 53.132414],
E              [36.784672, 42.324107, 50.51376 , 43.278745, 49.956693],
E              [22.164907, 37.049   , 51.930152, 56.789857, 63.231118],
E              [26.455394, 35.108023, 46.860663, 49.162274, 60.055398]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_162_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6dbd52670>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7ef7e804f700>}>
args = (), kw = {}
cupy_result = (array([[27.0934986 , 29.71082989, 34.62650201, 25.1770475 , 27.3937211 ],
       [ 0.        ,  0.        ,  0.      ... ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]]),)
cupy_error = None
numpy_result = (array([[39.92050807, 39.92050807, 51.40005714, 43.376314  , 54.85586307],
       [39.92050807, 39.92050807, 51.400057...2, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[27.0934986 , 29.71082989, 34.62650201, 25.1770475 , 27.3937211 ],
       [ 0.        ,  0.        ,  0.     ...2, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]]))]
cupy_r = array([[27.0934986 , 29.71082989, 34.62650201, 25.1770475 , 27.3937211 ],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
numpy_r = array([[39.92050807, 39.92050807, 51.40005714, 43.376314  , 54.85586307],
       [39.92050807, 39.92050807, 51.4000571...222, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[27.0934986 , 29.71082989, 34.62650201, 25.1770475 , 27.3937211 ],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
desired = array([[39.92050807, 39.92050807, 51.40005714, 43.376314  , 54.85586307],
       [39.92050807, 39.92050807, 51.4000571...222, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 59.64480722
E       Max relative difference: 1.
E        x: array([[27.093499, 29.71083 , 34.626502, 25.177048, 27.393721],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ]])
E        y: array([[39.920508, 39.920508, 51.400057, 43.376314, 54.855863],
E              [39.920508, 39.920508, 51.400057, 43.376314, 54.855863],
E              [34.334642, 34.334642, 44.988915, 43.336931, 53.991204],
E              [33.218712, 33.218712, 48.820469, 44.04305 , 59.644807]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_324_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...6c553b0>, <function lt_pyfunc at 0x7ef7e6ca5f70>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6db8e7310>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7ef7e6ca5f70>}>
args = (), kw = {}
cupy_result = (array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]]),)
cupy_error = None
numpy_result = (array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]]), array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]]))]
cupy_r = array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]])
numpy_r = array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]])
desired = array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 14 / 20 (70%)
E       Max absolute difference: 7.
E       Max relative difference: 2.
E        x: array([[4., 6., 3., 4., 3.],
E              [5., 7., 7., 5., 3.],
E              [6., 5., 4., 3., 2.],
E              [5., 7., 6., 4., 3.]])
E        y: array([[4., 6., 3., 3., 2.],
E              [5., 0., 6., 8., 1.],
E              [8., 3., 3., 7., 0.],
E              [2., 0., 6., 4., 4.]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_326_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...6c553b0>, <function lt_pyfunc at 0x7ef7e6ca5f70>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6db0da1c0>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7ef7e6ca5f70>}>
args = (), kw = {}
cupy_result = (array([[15.,  5., 12.,  6.,  8.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]]),)
cupy_error = None
numpy_result = (array([[ 8., 11.,  4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[15.,  5., 12.,  6.,  8.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  ...4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]]))]
cupy_r = array([[15.,  5., 12.,  6.,  8.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
numpy_r = array([[ 8., 11.,  4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[15.,  5., 12.,  6.,  8.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
desired = array([[ 8., 11.,  4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 17 / 20 (85%)
E       Max absolute difference: 14.
E       Max relative difference: 2.
E        x: array([[15.,  5., 12.,  6.,  8.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.]])
E        y: array([[ 8., 11.,  4., 10.,  7.],
E              [14.,  0.,  7.,  4.,  8.],
E              [ 8.,  5., 11.,  5.,  5.],
E              [14.,  0.,  1.,  0.,  7.]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_484_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6db0a60a0>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7ef7e804f700>}>
args = (), kw = {}
cupy_result = (array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[31, 36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]],...36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8))]
cupy_r = array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]], dtype=uint8)
numpy_r = array([[31, 36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]], dtype=uint8)
desired = array([[31, 36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 254
E       Max relative difference: 15.875
E        x: array([[21, 28, 45, 28, 29],
E              [28, 24, 27, 19, 21],
E              [14, 25, 40, 31, 32],
E              [28, 19, 33, 25, 26]], dtype=uint8)
E        y: array([[31, 36, 54, 42, 44],
E              [32, 37, 44, 33, 44],
E              [16, 36, 54, 41, 63],
E              [24, 30, 40, 45, 48]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_486_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6da932250>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7ef7e804f700>}>
args = (), kw = {}
cupy_result = (array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[31, 37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]],...37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8))]
cupy_r = array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
numpy_r = array([[31, 37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
desired = array([[31, 37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 255
E       Max relative difference: 8.84615385
E        x: array([[23, 27, 36, 28, 53],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0]], dtype=uint8)
E        y: array([[31, 37, 37, 34, 51],
E              [36, 33, 47, 34, 49],
E              [32, 30, 35, 33, 43],
E              [26, 31, 44, 32, 61]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_488_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6da8ed5e0>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7ef7e804f700>}>
args = (), kw = {}
cupy_result = (array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.257219...9, 51.41878991, 42.0040045 , 51.31070106],
       [33.21458492, 22.51034287, 37.94448098, 37.08985252, 37.51394469]]),)
cupy_error = None
numpy_result = (array([[34.73996818, 43.64546371, 63.5383726 , 49.84875414, 52.48268444],
       [37.33873469, 42.72655042, 49.589277...5, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.25721...5, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]]))]
cupy_r = array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.2572195...229, 51.41878991, 42.0040045 , 51.31070106],
       [33.21458492, 22.51034287, 37.94448098, 37.08985252, 37.51394469]])
numpy_r = array([[34.73996818, 43.64546371, 63.5383726 , 49.84875414, 52.48268444],
       [37.33873469, 42.72655042, 49.5892777...725, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.2572195...229, 51.41878991, 42.0040045 , 51.31070106],
       [33.21458492, 22.51034287, 37.94448098, 37.08985252, 37.51394469]])
desired = array([[34.73996818, 43.64546371, 63.5383726 , 49.84875414, 52.48268444],
       [37.33873469, 42.72655042, 49.5892777...725, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 21.26396424
E       Max relative difference: 0.37779527
E        x: array([[32.004498, 37.685758, 60.802894, 38.487909, 39.216312],
E              [34.603265, 32.253241, 33.25722 , 33.041408, 36.624282],
E              [20.112677, 38.150832, 51.41879 , 42.004005, 51.310701],
E              [33.214585, 22.510343, 37.944481, 37.089853, 37.513945]])
E        y: array([[34.739968, 43.645464, 63.538373, 49.848754, 52.482684],
E              [37.338735, 42.72655 , 49.589278, 37.768093, 49.890655],
E              [19.537204, 43.529837, 62.151861, 50.872889, 72.574665],
E              [29.909488, 36.178354, 46.34963 , 49.948601, 54.161936]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_490_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6db0b25e0>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7ef7e804f700>}>
args = (), kw = {}
cupy_result = (array([[21.27808861, 29.80163272, 37.25897052, 32.87956485, 40.18680146],
       [ 0.        ,  0.        ,  0.      ... ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]]),)
cupy_error = None
numpy_result = (array([[36.86077635, 42.87616583, 43.41972747, 39.82804323, 58.74618737],
       [42.04291274, 39.49732697, 56.260026...8, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[21.27808861, 29.80163272, 37.25897052, 32.87956485, 40.18680146],
       [ 0.        ,  0.        ,  0.     ...8, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]]))]
cupy_r = array([[21.27808861, 29.80163272, 37.25897052, 32.87956485, 40.18680146],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
numpy_r = array([[36.86077635, 42.87616583, 43.41972747, 39.82804323, 58.74618737],
       [42.04291274, 39.49732697, 56.2600260...358, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[21.27808861, 29.80163272, 37.25897052, 32.87956485, 40.18680146],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
desired = array([[36.86077635, 42.87616583, 43.41972747, 39.82804323, 58.74618737],
       [42.04291274, 39.49732697, 56.2600260...358, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 70.43768385
E       Max relative difference: 1.
E        x: array([[21.278089, 29.801633, 37.258971, 32.879565, 40.186801],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ]])
E        y: array([[36.860776, 42.876166, 43.419727, 39.828043, 58.746187],
E              [42.042913, 39.497327, 56.260026, 40.67984 , 58.57918 ],
E              [36.303403, 34.455314, 40.066132, 37.533243, 49.792072],
E              [31.441124, 37.686712, 51.654176, 39.594527, 70.437684]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_652_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...6c553b0>, <function lt_pyfunc at 0x7ef7e6ca5f70>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6da889970>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7ef7e6ca5f70>}>
args = (), kw = {}
cupy_result = (array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]]),)
cupy_error = None
numpy_result = (array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]]), array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]]))]
cupy_r = array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]])
numpy_r = array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]])
desired = array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 14 / 20 (70%)
E       Max absolute difference: 2.
E       Max relative difference: 1.
E        x: array([[5., 3., 2., 4., 3.],
E              [1., 5., 1., 5., 6.],
E              [4., 4., 1., 3., 5.],
E              [1., 1., 1., 4., 4.]])
E        y: array([[5., 2., 2., 3., 2.],
E              [0., 4., 0., 5., 5.],
E              [4., 4., 1., 2., 3.],
E              [0., 0., 0., 3., 2.]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_654_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...6c553b0>, <function lt_pyfunc at 0x7ef7e6ca5f70>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7ef6da031b20>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7ef7e6ca5f70>}>
args = (), kw = {}
cupy_result = (array([[ 6., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]]),)
cupy_error = None
numpy_result = (array([[ 0., 10., 10.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[ 6., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  ...0.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]]))]
cupy_r = array([[ 6., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
numpy_r = array([[ 0., 10., 10.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
desired = array([[ 0., 10., 10.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 18 / 20 (90%)
E       Max absolute difference: 10.
E       Max relative difference: 2.
E        x: array([[ 6., 10., 10.,  3.,  9.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.]])
E        y: array([[ 0., 10., 10.,  1.,  8.],
E              [ 7.,  6.,  2.,  2.,  2.],
E              [ 1., 10., 10.,  2.,  9.],
E              [ 4.,  5.,  9.,  1.,  6.]])

cupy/testing/_array.py:24: AssertionError
_ TestAffineTransform.test_affine_transform_int[_param_13_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf1fe4f0>  parameter: {..._shape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_17_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf127100>  parameter: {...ape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_19_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0fd1c0>  parameter: {..._shape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_23_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf13e5e0>  parameter: {...ape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_25_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf2380d0>  parameter: {..._shape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_29_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0ee700>  parameter: {...ape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_31_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf211400>  parameter: {..._shape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 9, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 9, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_35_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf102280>  parameter: {...ape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 9, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 9, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_49_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf132400>  parameter: {... (2,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_53_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf13e7c0>  parameter: {...,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_55_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf238310>  parameter: {... (2,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_59_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf238610>  parameter: {...,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_61_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef6b220>  parameter: {... (2,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 8 / 10000 (0.08%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_65_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceeb65b0>  parameter: {...,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 8 / 10000 (0.08%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_67_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf106640>  parameter: {... (2,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [5, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [5, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [5, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [5, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_71_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf225d30>  parameter: {...,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [5, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [5, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [5, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [5, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_85_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceeac220>  parameter: {...x_shape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[5, 8, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[5, 8, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_89_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf220370>  parameter: {...hape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[5, 8, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[5, 8, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_91_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef39670>  parameter: {...x_shape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   1,   1,   1],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[5, 8, 2, ..., 1, 1, 1],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[5, 8, 2, ..., 1, 1, 1],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_95_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf1040a0>  parameter: {...hape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   1,   1,   1],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[5, 8, 2, ..., 1, 1, 1],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[5, 8, 2, ..., 1, 1, 1],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_97_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef2d070>  parameter: {...x_shape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   0,   0],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 0, 0],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   0,   0],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[6, 8, 2, ..., 0, 0, 0],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_101_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef2d0d0>  parameter: {...hape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   0,   0],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 0, 0],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   0,   0],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[6, 8, 2, ..., 0, 0, 0],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_103_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ddd5f700>  parameter: {...x_shape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   0,   0],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 0, 0],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 89 / 10000 (0.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   0,   0],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[6, 8, 2, ..., 0, 0, 0],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_107_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6da8ed850>  parameter: {...hape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   0,   0],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 0, 0],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 89 / 10000 (0.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   0,   0],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[6, 8, 2, ..., 0, 0, 0],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_121_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf20b700>  parameter: {...: (2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_125_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6d6d05ca0>  parameter: {...2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_127_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf09fb20>  parameter: {...: (2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_131_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb59730>  parameter: {...2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_133_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf220700>  parameter: {...: (2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_137_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf07be80>  parameter: {...2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_139_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf2209a0>  parameter: {...: (2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 10 / 10000 (0.1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_143_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf21d370>  parameter: {...2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 10 / 10000 (0.1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_157_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf120a30>  parameter: {...ix_shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   3,   2,   2],
       [  2,   0,   6, ...,   2,   5,   8],
       [  4, 255,   0, ...,   ...,   1,   4,   8],
       [  2,   5,   0, ...,   8,   2,   1],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 0, ..., 3, 2, 2],
       [2, 0, 6, ..., 2, 5, 8],
       [4, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 8],
       [2, 5, 0, ..., 8, 2, 1],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 72 / 10000 (0.72%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   3,   2,   2],
E              [  2,   0,   6, ...,   2,   5,   8],
E              [  4, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 3, 2, 2],
E              [2, 0, 6, ..., 2, 5, 8],
E              [4, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_161_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cee320a0>  parameter: {...shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   3,   2,   2],
       [  2,   0,   6, ...,   2,   5,   8],
       [  4, 255,   0, ...,   ...,   1,   4,   8],
       [  2,   5,   0, ...,   8,   2,   1],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 0, ..., 3, 2, 2],
       [2, 0, 6, ..., 2, 5, 8],
       [4, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 8],
       [2, 5, 0, ..., 8, 2, 1],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 72 / 10000 (0.72%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   3,   2,   2],
E              [  2,   0,   6, ...,   2,   5,   8],
E              [  4, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 3, 2, 2],
E              [2, 0, 6, ..., 2, 5, 8],
E              [4, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_163_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf10deb0>  parameter: {...ix_shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   3,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   1,   4,   8],
       [  2,   5,   0, ...,   7,   2,   1],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 1, ..., 3, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 8],
       [2, 5, 0, ..., 7, 2, 1],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   3,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 1, ..., 3, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_167_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cee322b0>  parameter: {...shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   3,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   1,   4,   8],
       [  2,   5,   0, ...,   7,   2,   1],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 1, ..., 3, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 8],
       [2, 5, 0, ..., 7, 2, 1],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   3,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 1, ..., 3, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_169_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0e71c0>  parameter: {...ix_shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   4,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   0,   4,   8],
       [  2,   5, 255, ...,   7,   2,   0],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 0, ..., 4, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 0, 4, 8],
       [2, 5, 0, ..., 7, 2, 0],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 163 / 10000 (1.63%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   4,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 4, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_173_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf1184c0>  parameter: {...shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   4,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   0,   4,   8],
       [  2,   5, 255, ...,   7,   2,   0],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 0, ..., 4, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 0, 4, 8],
       [2, 5, 0, ..., 7, 2, 0],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 163 / 10000 (1.63%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   4,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 4, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_175_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf106520>  parameter: {...ix_shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   4,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   0,   4,   8],
       [  2,   5, 255, ...,   7,   2,   0],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 9, 0, ..., 4, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 2, ..., 0, 4, 8],
       [2, 5, 0, ..., 7, 2, 0],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 191 / 10000 (1.91%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   4,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 9, 0, ..., 4, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_179_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf106d00>  parameter: {...shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   4,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   0,   4,   8],
       [  2,   5, 255, ...,   7,   2,   0],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 9, 0, ..., 4, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 2, ..., 0, 4, 8],
       [2, 5, 0, ..., 7, 2, 0],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 191 / 10000 (1.91%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   4,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 9, 0, ..., 4, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_193_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf109f70>  parameter: {...': (2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  8,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  6,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  1, ...,  3,  4, 10]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  8,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  6,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  1, ...,  3,  4, 10]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 63 / 10000 (0.63%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  8,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  8,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_197_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6dbd52220>  parameter: {...(2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  8,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  6,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  1, ...,  3,  4, 10]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  8,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  6,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  1, ...,  3,  4, 10]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 63 / 10000 (0.63%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  8,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  8,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_199_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6db0a6bb0>  parameter: {...': (2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  2, ...,  3,  4, 11]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  2, ...,  3,  4, 11]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 82 / 10000 (0.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_203_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6d7687760>  parameter: {...(2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  2, ...,  3,  4, 11]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  2, ...,  3,  4, 11]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 82 / 10000 (0.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_205_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6dbd67550>  parameter: {...': (2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 11,  7,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 11,  7,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 144 / 10000 (1.44%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 11,  7,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 11,  7,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_209_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0fbbe0>  parameter: {...(2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 11,  7,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 11,  7,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 144 / 10000 (1.44%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 11,  7,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 11,  7,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_211_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf127400>  parameter: {...': (2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 2,  4,  6, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  4,  5,  0],
       [ 5,  2,  3, ..., 11,  7,  3],
    ... 2,  6,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
desired = array([[ 2,  4,  6, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  4,  5,  0],
       [ 5,  2,  3, ..., 11,  7,  3],
    ... 2,  6,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 164 / 10000 (1.64%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 2,  4,  6, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  4,  5,  0],
E              [ 5,  2,  3, ..., 11,  7,  3],...
E        y: array([[ 2,  4,  6, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  4,  5,  0],
E              [ 5,  2,  3, ..., 11,  7,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_215_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6da932dc0>  parameter: {...(2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 2,  4,  6, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  4,  5,  0],
       [ 5,  2,  3, ..., 11,  7,  3],
    ... 2,  6,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
desired = array([[ 2,  4,  6, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  4,  5,  0],
       [ 5,  2,  3, ..., 11,  7,  3],
    ... 2,  6,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 164 / 10000 (1.64%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 2,  4,  6, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  4,  5,  0],
E              [ 5,  2,  3, ..., 11,  7,  3],...
E        y: array([[ 2,  4,  6, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  4,  5,  0],
E              [ 5,  2,  3, ..., 11,  7,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_229_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6da031eb0>  parameter: {...trix_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   3,   2,   5],
       [  2,   0,   6, ...,   2,   5,   2],
       [  4, 255,   0, ...,   ...,   1,   4,   3],
       [  2,   5,   0, ...,   8,   2,   2],
       [  5,   8,   0, ...,   3,   2,   5]], dtype=uint8)
desired = array([[5, 8, 0, ..., 3, 2, 5],
       [2, 0, 6, ..., 2, 5, 2],
       [4, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 3],
       [2, 5, 0, ..., 8, 2, 2],
       [5, 8, 0, ..., 3, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   3,   2,   5],
E              [  2,   0,   6, ...,   2,   5,   2],
E              [  4, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 3, 2, 5],
E              [2, 0, 6, ..., 2, 5, 2],
E              [4, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_233_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6db8fbeb0>  parameter: {...x_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   3,   2,   5],
       [  2,   0,   6, ...,   2,   5,   2],
       [  4, 255,   0, ...,   ...,   1,   4,   3],
       [  2,   5,   0, ...,   8,   2,   2],
       [  5,   8,   0, ...,   3,   2,   5]], dtype=uint8)
desired = array([[5, 8, 0, ..., 3, 2, 5],
       [2, 0, 6, ..., 2, 5, 2],
       [4, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 3],
       [2, 5, 0, ..., 8, 2, 2],
       [5, 8, 0, ..., 3, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   3,   2,   5],
E              [  2,   0,   6, ...,   2,   5,   2],
E              [  4, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 3, 2, 5],
E              [2, 0, 6, ..., 2, 5, 2],
E              [4, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_235_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf111bb0>  parameter: {...trix_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   3,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   1,   4,   3],
       [  2,   5,   0, ...,   7,   2,   2],
       [  5,   8,   1, ...,   3,   2,   5]], dtype=uint8)
desired = array([[5, 8, 1, ..., 3, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 3, ..., 1, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 8, 1, ..., 3, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 112 / 10000 (1.12%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   3,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 8, 1, ..., 3, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_239_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0e58e0>  parameter: {...x_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   3,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   1,   4,   3],
       [  2,   5,   0, ...,   7,   2,   2],
       [  5,   8,   1, ...,   3,   2,   5]], dtype=uint8)
desired = array([[5, 8, 1, ..., 3, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 3, ..., 1, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 8, 1, ..., 3, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 112 / 10000 (1.12%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   3,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 8, 1, ..., 3, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_241_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6dbd5d850>  parameter: {...trix_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   4,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   0,   4,   3],
       [  2,   5, 255, ...,   7,   2,   2],
       [  5,   8,   0, ...,   4,   2,   5]], dtype=uint8)
desired = array([[5, 8, 0, ..., 4, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 3, ..., 0, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 8, 0, ..., 4, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 181 / 10000 (1.81%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   4,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 8, 0, ..., 4, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_245_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6dbd5de50>  parameter: {...x_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   4,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   0,   4,   3],
       [  2,   5, 255, ...,   7,   2,   2],
       [  5,   8,   0, ...,   4,   2,   5]], dtype=uint8)
desired = array([[5, 8, 0, ..., 4, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 3, ..., 0, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 8, 0, ..., 4, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 181 / 10000 (1.81%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   4,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 8, 0, ..., 4, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_247_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cee685e0>  parameter: {...trix_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   4,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   0,   4,   3],
       [  2,   5, 255, ...,   7,   2,   2],
       [  5,   9,   0, ...,   4,   2,   5]], dtype=uint8)
desired = array([[5, 9, 0, ..., 4, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 2, ..., 0, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 9, 0, ..., 4, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 210 / 10000 (2.1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   4,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 9, 0, ..., 4, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_251_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cee69250>  parameter: {...x_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   4,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   0,   4,   3],
       [  2,   5, 255, ...,   7,   2,   2],
       [  5,   9,   0, ...,   4,   2,   5]], dtype=uint8)
desired = array([[5, 9, 0, ..., 4, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 2, ..., 0, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 9, 0, ..., 4, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 210 / 10000 (2.1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   4,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 9, 0, ..., 4, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_265_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6dbd656a0>  parameter: {...pe': (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 8,  5,  1, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  6,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  1, ...,  3,  4,  8]], dtype=uint8)
desired = array([[ 8,  5,  1, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  6,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  1, ...,  3,  4,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 80 / 10000 (0.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 8,  5,  1, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...
E        y: array([[ 8,  5,  1, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_269_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf082460>  parameter: {...: (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 8,  5,  1, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  6,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  1, ...,  3,  4,  8]], dtype=uint8)
desired = array([[ 8,  5,  1, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  6,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  1, ...,  3,  4,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 80 / 10000 (0.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 8,  5,  1, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...
E        y: array([[ 8,  5,  1, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_271_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef3c1c0>  parameter: {...pe': (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 8,  5,  2, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  2, ...,  3,  4,  8]], dtype=uint8)
desired = array([[ 8,  5,  2, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  2, ...,  3,  4,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 106 / 10000 (1.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 8,  5,  2, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...
E        y: array([[ 8,  5,  2, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_275_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf082220>  parameter: {...: (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 8,  5,  2, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  2, ...,  3,  4,  8]], dtype=uint8)
desired = array([[ 8,  5,  2, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  2, ...,  3,  4,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 106 / 10000 (1.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 8,  5,  2, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...
E        y: array([[ 8,  5,  2, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_277_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf1145e0>  parameter: {...pe': (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 11,  7,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
desired = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 11,  7,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 168 / 10000 (1.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 11,  7,  4],...
E        y: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 11,  7,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_281_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0c4fd0>  parameter: {...: (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 11,  7,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
desired = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 11,  7,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 168 / 10000 (1.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 11,  7,  4],...
E        y: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 11,  7,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_283_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0ccf40>  parameter: {...pe': (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  4,  5,  7],
       [ 5,  2,  3, ..., 11,  7,  5],
    ... 2,  6,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
desired = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  4,  5,  7],
       [ 5,  2,  3, ..., 11,  7,  5],
    ... 2,  6,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 193 / 10000 (1.93%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  4,  5,  7],
E              [ 5,  2,  3, ..., 11,  7,  5],...
E        y: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  4,  5,  7],
E              [ 5,  2,  3, ..., 11,  7,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_287_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb59220>  parameter: {...: (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  4,  5,  7],
       [ 5,  2,  3, ..., 11,  7,  5],
    ... 2,  6,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
desired = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  4,  5,  7],
       [ 5,  2,  3, ..., 11,  7,  5],
    ... 2,  6,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 193 / 10000 (1.93%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  4,  5,  7],
E              [ 5,  2,  3, ..., 11,  7,  5],...
E        y: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  4,  5,  7],
E              [ 5,  2,  3, ..., 11,  7,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_301_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0cc8e0>  parameter: {...shape': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ...,   0,   3,   8],
       [  1,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 8],
       [1, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 90 / 10000 (0.9%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ...,   0,   3,   8],
E              [  1,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 8],
E              [1, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_305_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb6dd30>  parameter: {...pe': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ...,   0,   3,   8],
       [  1,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 8],
       [1, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 90 / 10000 (0.9%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ...,   0,   3,   8],
E              [  1,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 8],
E              [1, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_307_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0d0bb0>  parameter: {...shape': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ...,   0,   3,   8],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  3,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 8],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [3, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 115 / 10000 (1.15%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ...,   0,   3,   8],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 8],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_311_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0c67f0>  parameter: {...pe': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ...,   0,   3,   8],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  3,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 8],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [3, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 115 / 10000 (1.15%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ...,   0,   3,   8],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 8],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_313_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf132d00>  parameter: {...shape': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ..., 255,   3,   9],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  3,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 9],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [4, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [3, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 180 / 10000 (1.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ..., 255,   3,   9],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 9],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_317_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef457f0>  parameter: {...pe': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ..., 255,   3,   9],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  3,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 9],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [4, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [3, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 180 / 10000 (1.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ..., 255,   3,   9],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 9],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_319_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef739243b50>  parameter: {...shape': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   8,   2, ..., 255,   3,   9],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  3,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[7, 8, 2, ..., 0, 3, 9],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [4, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [3, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 205 / 10000 (2.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   8,   2, ..., 255,   3,   9],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[7, 8, 2, ..., 0, 3, 9],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_323_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb52a60>  parameter: {...pe': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   8,   2, ..., 255,   3,   9],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  3,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[7, 8, 2, ..., 0, 3, 9],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [4, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [3, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 205 / 10000 (2.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   8,   2, ..., 255,   3,   9],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[7, 8, 2, ..., 0, 3, 9],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_337_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf08c0d0>  parameter: {...(2,), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 80 / 10000 (0.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_341_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0a7f40>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 80 / 10000 (0.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_343_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceec5100>  parameter: {...(2,), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[3, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[3, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 120 / 10000 (1.2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[3, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[3, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_347_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0fdc40>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[3, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[3, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 120 / 10000 (1.2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[3, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[3, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_349_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef7392430d0>  parameter: {...(2,), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 3, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [5, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 3, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [5, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 175 / 10000 (1.75%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 3, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 3, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_353_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf109940>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 3, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [5, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 3, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [5, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 175 / 10000 (1.75%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 3, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 3, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_355_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0f25e0>  parameter: {...(2,), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 2,  5,  3, ...,  3,  6,  9],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 5,  5,  2, ...,  5,  2,  3],
       [ 5,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 2,  5,  3, ...,  3,  6,  9],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 5,  5,  2, ...,  5,  2,  3],
       [ 5,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 195 / 10000 (1.95%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 2,  5,  3, ...,  3,  6,  9],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 2,  5,  3, ...,  3,  6,  9],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_359_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0ee130>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 2,  5,  3, ...,  3,  6,  9],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 5,  5,  2, ...,  5,  2,  3],
       [ 5,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 2,  5,  3, ...,  3,  6,  9],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 5,  5,  2, ...,  5,  2,  3],
       [ 5,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 195 / 10000 (1.95%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 2,  5,  3, ...,  3,  6,  9],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 2,  5,  3, ...,  3,  6,  9],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_373_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cee4f190>  parameter: {...x_shape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [6, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_377_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6e31f0>  parameter: {...hape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [6, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_379_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6dcdad670>  parameter: {...x_shape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  4,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [4, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 122 / 10000 (1.22%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_383_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb5c130>  parameter: {...hape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  4,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [4, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 122 / 10000 (1.22%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_385_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb6ba90>  parameter: {...x_shape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 173 / 10000 (1.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_389_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce8d2400>  parameter: {...hape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 173 / 10000 (1.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_391_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cee4a940>  parameter: {...x_shape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   7,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 7, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 199 / 10000 (1.99%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   7,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 7, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_395_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef68580>  parameter: {...hape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   7,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 7, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 199 / 10000 (1.99%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   7,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 7, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_409_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6dc520>  parameter: {...: (2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_413_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6d8d60>  parameter: {...2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_415_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6db0b27c0>  parameter: {...: (2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_419_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf111c70>  parameter: {...2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_421_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6d5dc0>  parameter: {...: (2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 176 / 10000 (1.76%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_425_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6be250>  parameter: {...2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 176 / 10000 (1.76%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_427_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce3b6b50>  parameter: {...: (2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_431_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce38efd0>  parameter: {...2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_445_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce3b6eb0>  parameter: {...ape': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [6, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_449_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce80e130>  parameter: {...': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [6, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_451_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce39ad60>  parameter: {...ape': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  4,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [4, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 122 / 10000 (1.22%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_455_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceec5d90>  parameter: {...': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  4,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [4, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 122 / 10000 (1.22%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_457_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6d76872e0>  parameter: {...ape': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 173 / 10000 (1.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_461_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6d7a7dd00>  parameter: {...': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 173 / 10000 (1.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_463_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef39a90>  parameter: {...ape': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   7,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 7, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 199 / 10000 (1.99%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   7,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 7, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_467_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce37e220>  parameter: {...': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   7,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 7, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 199 / 10000 (1.99%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   7,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 7, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_481_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce36ee20>  parameter: {...,), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_485_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6db8fb190>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_487_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2f95e0>  parameter: {...,), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_491_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef6a160>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_493_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6dd8e9610>  parameter: {...,), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 176 / 10000 (1.76%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_497_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce62c430>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 176 / 10000 (1.76%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_499_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf079d90>  parameter: {...,), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_503_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf079dc0>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_517_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf086b50>  parameter: {...e': (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[6, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[6, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_521_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef59c40>  parameter: {... (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[6, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[6, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_523_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6d8130>  parameter: {...e': (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[6, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[6, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_527_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce680580>  parameter: {... (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[6, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[6, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_529_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2f3be0>  parameter: {...e': (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[7, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[7, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_533_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce214370>  parameter: {... (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[7, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[7, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_535_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce360df0>  parameter: {...e': (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   9,   2, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[7, 9, 2, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   9,   2, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[7, 9, 2, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_539_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2c0d00>  parameter: {... (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   9,   2, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[7, 9, 2, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   9,   2, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[7, 9, 2, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_553_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2d7f10>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_557_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2c0eb0>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_559_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2ecc70>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_563_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce660910>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_565_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2e1e50>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 8 / 10000 (0.08%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_569_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb5c4c0>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 8 / 10000 (0.08%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_571_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce37edf0>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_575_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cee3e670>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_589_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6324c0>  parameter: {...hape': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_593_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce651d90>  parameter: {...e': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_595_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef6b3d0>  parameter: {...hape': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_599_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef4f9a0>  parameter: {...e': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_601_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce12c0d0>  parameter: {...hape': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_605_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce66e9a0>  parameter: {...e': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_607_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce215a60>  parameter: {...hape': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_611_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6e3c10>  parameter: {...e': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_625_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6b7a90>  parameter: {...2, 2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_629_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cee51ee0>  parameter: {...2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_631_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce393dc0>  parameter: {...2, 2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_635_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb528e0>  parameter: {...2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_637_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce3e43a0>  parameter: {...2, 2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_641_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2d3a60>  parameter: {...2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_643_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce8caa30>  parameter: {...2, 2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_647_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf08c9d0>  parameter: {...2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_661_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdc83b50>  parameter: {...shape': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_665_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2a5eb0>  parameter: {...pe': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_667_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce8bea30>  parameter: {...shape': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_671_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce137940>  parameter: {...pe': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_673_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce290520>  parameter: {...shape': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_677_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce353610>  parameter: {...pe': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_679_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce297fa0>  parameter: {...shape': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 4 / 10000 (0.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_683_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdb01ca0>  parameter: {...pe': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 4 / 10000 (0.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_697_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd6a20d0>  parameter: {...(2, 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 2, ..., 8, 8, 8],
       [2, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 2, ..., 8, 8, 8],
       [2, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 2, ..., 8, 8, 8],
E              [2, 2, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 2, ..., 8, 8, 8],
E              [2, 2, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_701_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdb01160>  parameter: {... 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 2, ..., 8, 8, 8],
       [2, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 2, ..., 8, 8, 8],
       [2, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 2, ..., 8, 8, 8],
E              [2, 2, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 2, ..., 8, 8, 8],
E              [2, 2, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_703_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd6a2f40>  parameter: {...(2, 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 3, ..., 8, 8, 8],
       [3, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 3, ..., 8, 8, 8],
       [3, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 3, ..., 8, 8, 8],
E              [3, 2, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 3, ..., 8, 8, 8],
E              [3, 2, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_707_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6a40d0>  parameter: {... 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 3, ..., 8, 8, 8],
       [3, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 3, ..., 8, 8, 8],
       [3, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 3, ..., 8, 8, 8],
E              [3, 2, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 3, ..., 8, 8, 8],
E              [3, 2, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_709_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce298b20>  parameter: {...(2, 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_713_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2e1370>  parameter: {... 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_715_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce660130>  parameter: {...(2, 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_719_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdacb730>  parameter: {... 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_733_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd4803d0>  parameter: {..._shape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 7, 8, 6],
       [5, 7, 6, ..., 4, 9, 6],
       [2, 6, 5, ..., 3, 7, 2],
       ...,
       [3, 5, 4, ..., 2, 7, 8],
       [7, 3, 2, ..., 7, 2, 4],
       [6, 6, 2, ..., 3, 9, 2]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 6],
       [5, 7, 6, ..., 4, 9, 6],
       [2, 6, 5, ..., 3, 7, 2],
       ...,
       [3, 5, 4, ..., 2, 7, 8],
       [7, 3, 2, ..., 7, 2, 4],
       [6, 6, 2, ..., 3, 9, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 93 / 10000 (0.93%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 7, 8, 6],
E              [5, 7, 6, ..., 4, 9, 6],
E              [2, 6, 5, ..., 3, 7, 2],...
E        y: array([[5, 3, 1, ..., 7, 8, 6],
E              [5, 7, 6, ..., 4, 9, 6],
E              [2, 6, 5, ..., 3, 7, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_737_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce3ea460>  parameter: {...ape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 7, 8, 6],
       [5, 7, 6, ..., 4, 9, 6],
       [2, 6, 5, ..., 3, 7, 2],
       ...,
       [3, 5, 4, ..., 2, 7, 8],
       [7, 3, 2, ..., 7, 2, 4],
       [6, 6, 2, ..., 3, 9, 2]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 6],
       [5, 7, 6, ..., 4, 9, 6],
       [2, 6, 5, ..., 3, 7, 2],
       ...,
       [3, 5, 4, ..., 2, 7, 8],
       [7, 3, 2, ..., 7, 2, 4],
       [6, 6, 2, ..., 3, 9, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 93 / 10000 (0.93%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 7, 8, 6],
E              [5, 7, 6, ..., 4, 9, 6],
E              [2, 6, 5, ..., 3, 7, 2],...
E        y: array([[5, 3, 1, ..., 7, 8, 6],
E              [5, 7, 6, ..., 4, 9, 6],
E              [2, 6, 5, ..., 3, 7, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_739_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce66ecd0>  parameter: {..._shape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 4,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  2, ...,  7,  3,  4],
       [ 6,  6,  2, ...,  3,  9,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 4,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  2, ...,  7,  3,  4],
       [ 6,  6,  2, ...,  3,  9,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 114 / 10000 (1.14%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_743_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0a7f70>  parameter: {...ape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 4,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  2, ...,  7,  3,  4],
       [ 6,  6,  2, ...,  3,  9,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 4,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  2, ...,  7,  3,  4],
       [ 6,  6,  2, ...,  3,  9,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 114 / 10000 (1.14%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_745_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce820790>  parameter: {..._shape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 3,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  3, ...,  7,  3,  3],
       [ 6,  6,  2, ...,  3, 10,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 3,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  3, ...,  7,  3,  3],
       [ 6,  6,  2, ...,  3, 10,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 177 / 10000 (1.77%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_749_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd6d41f0>  parameter: {...ape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 3,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  3, ...,  7,  3,  3],
       [ 6,  6,  2, ...,  3, 10,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 3,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  3, ...,  7,  3,  3],
       [ 6,  6,  2, ...,  3, 10,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 177 / 10000 (1.77%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_751_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce66c5e0>  parameter: {..._shape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 11,  5],
       [ 2,  6,  5, ...,  3,  8,  2],
    ... 3,  5,  6, ...,  2,  6,  8],
       [ 7,  3,  3, ...,  7,  2,  3],
       [ 6,  6,  2, ...,  4, 10,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 11,  5],
       [ 2,  6,  5, ...,  3,  8,  2],
    ... 3,  5,  6, ...,  2,  6,  8],
       [ 7,  3,  3, ...,  7,  2,  3],
       [ 6,  6,  2, ...,  4, 10,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 205 / 10000 (2.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 11,  5],
E              [ 2,  6,  5, ...,  3,  8,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 11,  5],
E              [ 2,  6,  5, ...,  3,  8,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_755_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdc7dfa0>  parameter: {...ape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 11,  5],
       [ 2,  6,  5, ...,  3,  8,  2],
    ... 3,  5,  6, ...,  2,  6,  8],
       [ 7,  3,  3, ...,  7,  2,  3],
       [ 6,  6,  2, ...,  4, 10,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 11,  5],
       [ 2,  6,  5, ...,  3,  8,  2],
    ... 3,  5,  6, ...,  2,  6,  8],
       [ 7,  3,  3, ...,  7,  2,  3],
       [ 6,  6,  2, ...,  4, 10,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 205 / 10000 (2.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 11,  5],
E              [ 2,  6,  5, ...,  3,  8,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 11,  5],
E              [ 2,  6,  5, ...,  3,  8,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_769_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd59ebb0>  parameter: {... (2, 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  10],
       [  3,   2,   2, ...,   1,   4,   4],
       [  2,   2,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   6],
       [  8,  10,   9, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 10],
       [ 3,  2,  2, ...,  1,  4,  4],
       [ 2,  2,  8, ...,  5,  0,  4],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  6],
       [ 8, 10,  9, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 85 / 10000 (0.85%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  10],
E              [  3,   2,   2, ...,   1,   4,   4],
E              [  2,   2,   8, ...,   5, 255,   4],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 10],
E              [ 3,  2,  2, ...,  1,  4,  4],
E              [ 2,  2,  8, ...,  5,  0,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_773_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce38e2e0>  parameter: {..., 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  10],
       [  3,   2,   2, ...,   1,   4,   4],
       [  2,   2,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   6],
       [  8,  10,   9, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 10],
       [ 3,  2,  2, ...,  1,  4,  4],
       [ 2,  2,  8, ...,  5,  0,  4],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  6],
       [ 8, 10,  9, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 85 / 10000 (0.85%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  10],
E              [  3,   2,   2, ...,   1,   4,   4],
E              [  2,   2,   8, ...,   5, 255,   4],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 10],
E              [ 3,  2,  2, ...,  1,  4,  4],
E              [ 2,  2,  8, ...,  5,  0,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_775_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce1375e0>  parameter: {... (2, 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  11],
       [  3,   2,   3, ...,   0,   4,   5],
       [  3,   2,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  8,  10,   8, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 11],
       [ 3,  2,  3, ...,  0,  4,  5],
       [ 3,  2,  8, ...,  5,  0,  4],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 8, 10,  8, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 123 / 10000 (1.23%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  11],
E              [  3,   2,   3, ...,   0,   4,   5],
E              [  3,   2,   8, ...,   5, 255,   4],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 11],
E              [ 3,  2,  3, ...,  0,  4,  5],
E              [ 3,  2,  8, ...,  5,  0,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_779_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cef4f5b0>  parameter: {..., 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  11],
       [  3,   2,   3, ...,   0,   4,   5],
       [  3,   2,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  8,  10,   8, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 11],
       [ 3,  2,  3, ...,  0,  4,  5],
       [ 3,  2,  8, ...,  5,  0,  4],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 8, 10,  8, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 123 / 10000 (1.23%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  11],
E              [  3,   2,   3, ...,   0,   4,   5],
E              [  3,   2,   8, ...,   5, 255,   4],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 11],
E              [ 3,  2,  3, ...,  0,  4,  5],
E              [ 3,  2,  8, ...,  5,  0,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_781_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce298970>  parameter: {... (2, 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  12],
       [  4,   1,   3, ...,   0,   4,   5],
       [  2,   3,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  9,  10,   8, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 12],
       [ 4,  1,  3, ...,  0,  4,  5],
       [ 2,  3,  8, ...,  5,  0,  3],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 9, 10,  8, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 189 / 10000 (1.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  12],
E              [  4,   1,   3, ...,   0,   4,   5],
E              [  2,   3,   8, ...,   5, 255,   3],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 12],
E              [ 4,  1,  3, ...,  0,  4,  5],
E              [ 2,  3,  8, ...,  5,  0,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_785_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdb0fbb0>  parameter: {..., 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  12],
       [  4,   1,   3, ...,   0,   4,   5],
       [  2,   3,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  9,  10,   8, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 12],
       [ 4,  1,  3, ...,  0,  4,  5],
       [ 2,  3,  8, ...,  5,  0,  3],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 9, 10,  8, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 189 / 10000 (1.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  12],
E              [  4,   1,   3, ...,   0,   4,   5],
E              [  2,   3,   8, ...,   5, 255,   3],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 12],
E              [ 4,  1,  3, ...,  0,  4,  5],
E              [ 2,  3,  8, ...,  5,  0,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_787_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdb0f0d0>  parameter: {... (2, 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   7,   3,  12],
       [  4,   1,   3, ...,   0,   4,   6],
       [  2,   3,   8, ...,   ...,   6,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  9,  10,   8, ...,   9,   2,   2]], dtype=uint8)
desired = array([[ 2,  3,  2, ...,  7,  3, 12],
       [ 4,  1,  3, ...,  0,  4,  6],
       [ 2,  3,  8, ...,  6,  0,  3],
    ... 6,  4,  3, ...,  6,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 9, 10,  8, ...,  9,  2,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 220 / 10000 (2.2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   7,   3,  12],
E              [  4,   1,   3, ...,   0,   4,   6],
E              [  2,   3,   8, ...,   6, 255,   3],...
E        y: array([[ 2,  3,  2, ...,  7,  3, 12],
E              [ 4,  1,  3, ...,  0,  4,  6],
E              [ 2,  3,  8, ...,  6,  0,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_791_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce10f2b0>  parameter: {..., 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   7,   3,  12],
       [  4,   1,   3, ...,   0,   4,   6],
       [  2,   3,   8, ...,   ...,   6,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  9,  10,   8, ...,   9,   2,   2]], dtype=uint8)
desired = array([[ 2,  3,  2, ...,  7,  3, 12],
       [ 4,  1,  3, ...,  0,  4,  6],
       [ 2,  3,  8, ...,  6,  0,  3],
    ... 6,  4,  3, ...,  6,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 9, 10,  8, ...,  9,  2,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 220 / 10000 (2.2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   7,   3,  12],
E              [  4,   1,   3, ...,   0,   4,   6],
E              [  2,   3,   8, ...,   6, 255,   3],...
E        y: array([[ 2,  3,  2, ...,  7,  3, 12],
E              [ 4,  1,  3, ...,  0,  4,  6],
E              [ 2,  3,  8, ...,  6,  0,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_805_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd46c6a0>  parameter: {...ix_shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   5,   5],
       [  2,   6,   5, ..., 25...,   1,   1,   5],
       [  8,   8,   7, ...,   6,   4,   8],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 5, 5],
       [2, 6, 5, ..., 0, 2, 2],
       ...,
       [5, 6, 4, ..., 1, 1, 5],
       [8, 8, 7, ..., 6, 4, 8],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   5,   5],
E              [  2,   6,   5, ..., 255,   2,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 5, 5],
E              [2, 6, 5, ..., 0, 2, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_809_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce820100>  parameter: {...shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   5,   5],
       [  2,   6,   5, ..., 25...,   1,   1,   5],
       [  8,   8,   7, ...,   6,   4,   8],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 5, 5],
       [2, 6, 5, ..., 0, 2, 2],
       ...,
       [5, 6, 4, ..., 1, 1, 5],
       [8, 8, 7, ..., 6, 4, 8],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   5,   5],
E              [  2,   6,   5, ..., 255,   2,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 5, 5],
E              [2, 6, 5, ..., 0, 2, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_811_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdb03dc0>  parameter: {...ix_shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   5,   5],
       [  2,   6,   5, ..., 25...,   1,   1,   5],
       [  8,   7,   7, ...,   6,   4,   8],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 5, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 1, 5],
       [8, 7, 7, ..., 6, 4, 8],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 111 / 10000 (1.11%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   5,   5],
E              [  2,   6,   5, ..., 255,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 5, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_815_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd560c70>  parameter: {...shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   5,   5],
       [  2,   6,   5, ..., 25...,   1,   1,   5],
       [  8,   7,   7, ...,   6,   4,   8],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 5, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 1, 5],
       [8, 7, 7, ..., 6, 4, 8],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 111 / 10000 (1.11%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   5,   5],
E              [  2,   6,   5, ..., 255,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 5, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_817_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdaa9d00>  parameter: {...ix_shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   6,   5],
       [  2,   6,   5, ..., 25...,   1,   0,   5],
       [  9,   7,   7, ...,   6,   4,   9],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 6, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 0, 5],
       [9, 7, 7, ..., 6, 4, 9],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 182 / 10000 (1.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   6,   5],
E              [  2,   6,   5, ..., 254,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 6, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_821_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd590d00>  parameter: {...shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   6,   5],
       [  2,   6,   5, ..., 25...,   1,   0,   5],
       [  9,   7,   7, ...,   6,   4,   9],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 6, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 0, 5],
       [9, 7, 7, ..., 6, 4, 9],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 182 / 10000 (1.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   6,   5],
E              [  2,   6,   5, ..., 254,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 6, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_823_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdc88430>  parameter: {...ix_shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   6,   5],
       [  2,   6,   5, ..., 25...,   1,   0,   5],
       [  9,   8,   7, ...,   6,   4,   9],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 6, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 0, 5],
       [9, 8, 7, ..., 6, 4, 9],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 211 / 10000 (2.11%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   6,   5],
E              [  2,   6,   5, ..., 254,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 6, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_827_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd4567f0>  parameter: {...shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   6,   5],
       [  2,   6,   5, ..., 25...,   1,   0,   5],
       [  9,   8,   7, ...,   6,   4,   9],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 6, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 0, 5],
       [9, 8, 7, ..., 6, 4, 9],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 211 / 10000 (2.11%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   6,   5],
E              [  2,   6,   5, ..., 254,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 6, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_841_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdb06f10>  parameter: {...': (2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 2, ..., 1, 1, 3],
       [2, 2, 8, ..., 5, 5, 2],
       ...,
       [3, 6, 2, ..., 7, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
desired = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 2, ..., 1, 1, 3],
       [2, 2, 8, ..., 5, 5, 2],
       ...,
       [3, 6, 2, ..., 7, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 79 / 10000 (0.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 2, ..., 1, 1, 3],
E              [2, 2, 8, ..., 5, 5, 2],...
E        y: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 2, ..., 1, 1, 3],
E              [2, 2, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_845_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd7e22e0>  parameter: {...(2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 2, ..., 1, 1, 3],
       [2, 2, 8, ..., 5, 5, 2],
       ...,
       [3, 6, 2, ..., 7, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
desired = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 2, ..., 1, 1, 3],
       [2, 2, 8, ..., 5, 5, 2],
       ...,
       [3, 6, 2, ..., 7, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 79 / 10000 (0.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 2, ..., 1, 1, 3],
E              [2, 2, 8, ..., 5, 5, 2],...
E        y: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 2, ..., 1, 1, 3],
E              [2, 2, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_847_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd7eb790>  parameter: {...': (2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 3, ..., 0, 0, 3],
       [3, 2, 8, ..., 5, 5, 3],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
desired = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 3, ..., 0, 0, 3],
       [3, 2, 8, ..., 5, 5, 3],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 3, ..., 0, 0, 3],
E              [3, 2, 8, ..., 5, 5, 3],...
E        y: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 3, ..., 0, 0, 3],
E              [3, 2, 8, ..., 5, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_851_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce11e430>  parameter: {...(2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 3, ..., 0, 0, 3],
       [3, 2, 8, ..., 5, 5, 3],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
desired = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 3, ..., 0, 0, 3],
       [3, 2, 8, ..., 5, 5, 3],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 3, ..., 0, 0, 3],
E              [3, 2, 8, ..., 5, 5, 3],...
E        y: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 3, ..., 0, 0, 3],
E              [3, 2, 8, ..., 5, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_853_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef7e2d48250>  parameter: {...': (2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[9, 3, 2, ..., 6, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 6, 3, 9]], dtype=uint8)
desired = array([[9, 3, 2, ..., 6, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 6, 3, 9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 164 / 10000 (1.64%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[9, 3, 2, ..., 6, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...
E        y: array([[9, 3, 2, ..., 6, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_857_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce651be0>  parameter: {...(2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[9, 3, 2, ..., 6, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 6, 3, 9]], dtype=uint8)
desired = array([[9, 3, 2, ..., 6, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 6, 3, 9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 164 / 10000 (1.64%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[9, 3, 2, ..., 6, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...
E        y: array([[9, 3, 2, ..., 6, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_859_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce651d00>  parameter: {...': (2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[9, 3, 2, ..., 7, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 7, 3, 9]], dtype=uint8)
desired = array([[9, 3, 2, ..., 7, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 7, 3, 9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 189 / 10000 (1.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[9, 3, 2, ..., 7, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...
E        y: array([[9, 3, 2, ..., 7, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_863_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdacb610>  parameter: {...(2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[9, 3, 2, ..., 7, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 7, 3, 9]], dtype=uint8)
desired = array([[9, 3, 2, ..., 7, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 7, 3, 9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 189 / 10000 (1.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[9, 3, 2, ..., 7, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...
E        y: array([[9, 3, 2, ..., 7, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_877_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf079880>  parameter: {...ape': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 5, 3, 6],
       [2, 6, 5, ..., 1, 4, 2],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 0, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 5, 3, 6],
       [2, 6, 5, ..., 1, 4, 2],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 0, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 91 / 10000 (0.91%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 5, 3, 6],
E              [2, 6, 5, ..., 1, 4, 2],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 5, 3, 6],
E              [2, 6, 5, ..., 1, 4, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_881_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd578b20>  parameter: {...': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 5, 3, 6],
       [2, 6, 5, ..., 1, 4, 2],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 0, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 5, 3, 6],
       [2, 6, 5, ..., 1, 4, 2],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 0, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 91 / 10000 (0.91%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 5, 3, 6],
E              [2, 6, 5, ..., 1, 4, 2],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 5, 3, 6],
E              [2, 6, 5, ..., 1, 4, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_883_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef7e2d7e310>  parameter: {...ape': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 7, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 7, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 116 / 10000 (1.16%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_887_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd59e310>  parameter: {...': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 7, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 7, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 116 / 10000 (1.16%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_889_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceed5fa0>  parameter: {...ape': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 1, 4],
       [5, 6, 7, ..., 1, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 1, 4],
       [5, 6, 7, ..., 1, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 184 / 10000 (1.84%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_893_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd560ca0>  parameter: {...': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 1, 4],
       [5, 6, 7, ..., 1, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 1, 4],
       [5, 6, 7, ..., 1, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 184 / 10000 (1.84%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_895_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce36eb50>  parameter: {...ape': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [6, 9, 0, ..., 5, 8, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [4, 6, 7, ..., 1, 6, 7]], dtype=uint8)
desired = array([[7, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [6, 9, 0, ..., 5, 8, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [4, 6, 7, ..., 1, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 216 / 10000 (2.16%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[7, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_899_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce216160>  parameter: {...': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [6, 9, 0, ..., 5, 8, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [4, 6, 7, ..., 1, 6, 7]], dtype=uint8)
desired = array([[7, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [6, 9, 0, ..., 5, 8, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [4, 6, 7, ..., 1, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 216 / 10000 (2.16%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[7, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_913_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd4563a0>  parameter: {..., 2), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 7],
       [2, 2, 8, ..., 6, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 1],
       [6, 2, 4, ..., 2, 6, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 7],
       [2, 2, 8, ..., 6, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 1],
       [6, 2, 4, ..., 2, 6, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 82 / 10000 (0.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 7],
E              [2, 2, 8, ..., 6, 5, 5],...
E        y: array([[2, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 7],
E              [2, 2, 8, ..., 6, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_917_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb6b9a0>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 7],
       [2, 2, 8, ..., 6, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 1],
       [6, 2, 4, ..., 2, 6, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 7],
       [2, 2, 8, ..., 6, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 1],
       [6, 2, 4, ..., 2, 6, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 82 / 10000 (0.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 7],
E              [2, 2, 8, ..., 6, 5, 5],...
E        y: array([[2, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 7],
E              [2, 2, 8, ..., 6, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_919_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd6a2be0>  parameter: {..., 2), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[3, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 7],
       [3, 2, 8, ..., 5, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
desired = array([[3, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 7],
       [3, 2, 8, ..., 5, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 109 / 10000 (1.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[3, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 7],
E              [3, 2, 8, ..., 5, 5, 5],...
E        y: array([[3, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 7],
E              [3, 2, 8, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_923_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd480eb0>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[3, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 7],
       [3, 2, 8, ..., 5, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
desired = array([[3, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 7],
       [3, 2, 8, ..., 5, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 109 / 10000 (1.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[3, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 7],
E              [3, 2, 8, ..., 5, 5, 5],...
E        y: array([[3, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 7],
E              [3, 2, 8, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_925_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0ee280>  parameter: {..., 2), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   8],
       [  2,   3,   8, ...,   ...,   6,   6,   2],
       [  6,   2,   4, ...,   2,   5,   7],
       [  6,   6,   6, ..., 255,   5,   3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 1, 1],
       [4, 1, 3, ..., 5, 0, 8],
       [2, 3, 8, ..., 5, 6, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 169 / 10000 (1.69%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   8],
E              [  2,   3,   8, ...,   5,   6,   5],...
E        y: array([[2, 3, 2, ..., 2, 1, 1],
E              [4, 1, 3, ..., 5, 0, 8],
E              [2, 3, 8, ..., 5, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_929_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce680a90>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   8],
       [  2,   3,   8, ...,   ...,   6,   6,   2],
       [  6,   2,   4, ...,   2,   5,   7],
       [  6,   6,   6, ..., 255,   5,   3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 1, 1],
       [4, 1, 3, ..., 5, 0, 8],
       [2, 3, 8, ..., 5, 6, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 169 / 10000 (1.69%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   8],
E              [  2,   3,   8, ...,   5,   6,   5],...
E        y: array([[2, 3, 2, ..., 2, 1, 1],
E              [4, 1, 3, ..., 5, 0, 8],
E              [2, 3, 8, ..., 5, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_931_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef7e2d726d0>  parameter: {..., 2), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   8],
       [  2,   3,   8, ...,   ...,   6,   6,   2],
       [  6,   2,   4, ...,   2,   5,   7],
       [  6,   6,   6, ..., 255,   5,   3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 1, 1],
       [4, 1, 3, ..., 4, 0, 8],
       [2, 3, 8, ..., 5, 6, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 197 / 10000 (1.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   8],
E              [  2,   3,   8, ...,   5,   6,   5],...
E        y: array([[2, 3, 2, ..., 2, 1, 1],
E              [4, 1, 3, ..., 4, 0, 8],
E              [2, 3, 8, ..., 5, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_935_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd6cb4f0>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   8],
       [  2,   3,   8, ...,   ...,   6,   6,   2],
       [  6,   2,   4, ...,   2,   5,   7],
       [  6,   6,   6, ..., 255,   5,   3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 1, 1],
       [4, 1, 3, ..., 4, 0, 8],
       [2, 3, 8, ..., 5, 6, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 197 / 10000 (1.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   8],
E              [  2,   3,   8, ...,   5,   6,   5],...
E        y: array([[2, 3, 2, ..., 2, 1, 1],
E              [4, 1, 3, ..., 4, 0, 8],
E              [2, 3, 8, ..., 5, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_949_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef71794e6a0>  parameter: {...shape': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 97 / 10000 (0.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_953_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef7e2df5190>  parameter: {...pe': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 97 / 10000 (0.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_955_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce8daf10>  parameter: {...shape': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 131 / 10000 (1.31%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_959_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cda99c70>  parameter: {...pe': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 131 / 10000 (1.31%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_961_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdc7d850>  parameter: {...shape': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_965_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd570370>  parameter: {...pe': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_967_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce39a8e0>  parameter: {...shape': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 218 / 10000 (2.18%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_971_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6dbd5dd30>  parameter: {...pe': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 218 / 10000 (2.18%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_985_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce6e3f70>  parameter: {...(2, 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   3,   2, ...,   2,   2,   1],
       [  3,   2,   2, ...,   5,   0,   4],
       [  2,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   8, ...,   4,   4,   7],
       [  4,   4,   6, ...,   5,   4,   3]], dtype=uint8)
desired = array([[6, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 4],
       [2, 2, 8, ..., 6, 2, 0],
       ...,
       [5, 1, 3, ..., 4, 2, 8],
       [6, 2, 8, ..., 4, 4, 7],
       [4, 4, 6, ..., 5, 4, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 102 / 10000 (1.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   2, ...,   5,   0,   4],
E              [  2,   2,   8, ...,   6,   2, 255],...
E        y: array([[6, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 4],
E              [2, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_989_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce360970>  parameter: {... 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   3,   2, ...,   2,   2,   1],
       [  3,   2,   2, ...,   5,   0,   4],
       [  2,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   8, ...,   4,   4,   7],
       [  4,   4,   6, ...,   5,   4,   3]], dtype=uint8)
desired = array([[6, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 4],
       [2, 2, 8, ..., 6, 2, 0],
       ...,
       [5, 1, 3, ..., 4, 2, 8],
       [6, 2, 8, ..., 4, 4, 7],
       [4, 4, 6, ..., 5, 4, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 102 / 10000 (1.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   2, ...,   5,   0,   4],
E              [  2,   2,   8, ...,   6,   2, 255],...
E        y: array([[6, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 4],
E              [2, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_991_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce298c10>  parameter: {...(2, 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   2,   1],
       [  3,   2,   3, ...,   5,   0,   4],
       [  3,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   9, ...,   4,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[5, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 4],
       [3, 2, 8, ..., 6, 2, 0],
       ...,
       [4, 1, 3, ..., 4, 2, 8],
       [6, 2, 9, ..., 4, 4, 8],
       [4, 4, 6, ..., 5, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 130 / 10000 (1.3%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   3, ...,   5,   0,   4],
E              [  3,   2,   8, ...,   6,   2, 255],...
E        y: array([[5, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 4],
E              [3, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_995_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf127910>  parameter: {... 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   2,   1],
       [  3,   2,   3, ...,   5,   0,   4],
       [  3,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   9, ...,   4,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[5, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 4],
       [3, 2, 8, ..., 6, 2, 0],
       ...,
       [4, 1, 3, ..., 4, 2, 8],
       [6, 2, 9, ..., 4, 4, 8],
       [4, 4, 6, ..., 5, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 130 / 10000 (1.3%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   3, ...,   5,   0,   4],
E              [  3,   2,   8, ...,   6,   2, 255],...
E        y: array([[5, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 4],
E              [3, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_997_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce8ca0d0>  parameter: {...(2, 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  5,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  3, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  4,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 179 / 10000 (1.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  5,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1001_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceec5f10>  parameter: {... 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  5,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  3, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  4,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 179 / 10000 (1.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  5,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1003_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce215f10>  parameter: {...(2, 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   3,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  4,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  2, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  3,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 202 / 10000 (2.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  4,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1007_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0c4910>  parameter: {... 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   3,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  4,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  2, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  3,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 202 / 10000 (2.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  4,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1021_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd6cbbb0>  parameter: {...e': (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 97 / 10000 (0.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1025_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce7f6d60>  parameter: {... (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 97 / 10000 (0.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1027_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cdc83370>  parameter: {...e': (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 131 / 10000 (1.31%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1031_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6de01f130>  parameter: {... (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 131 / 10000 (1.31%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1033_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef7e2e86550>  parameter: {...e': (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1037_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce66c160>  parameter: {... (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1039_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ceb59880>  parameter: {...e': (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 218 / 10000 (2.18%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1043_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce12c9d0>  parameter: {... (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 218 / 10000 (2.18%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1057_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd6cd940>  parameter: {...2), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   3,   2, ...,   2,   2,   1],
       [  3,   2,   2, ...,   5,   0,   4],
       [  2,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   8, ...,   4,   4,   7],
       [  4,   4,   6, ...,   5,   4,   3]], dtype=uint8)
desired = array([[6, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 4],
       [2, 2, 8, ..., 6, 2, 0],
       ...,
       [5, 1, 3, ..., 4, 2, 8],
       [6, 2, 8, ..., 4, 4, 7],
       [4, 4, 6, ..., 5, 4, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 102 / 10000 (1.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   2, ...,   5,   0,   4],
E              [  2,   2,   8, ...,   6,   2, 255],...
E        y: array([[6, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 4],
E              [2, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1061_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0a7400>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   3,   2, ...,   2,   2,   1],
       [  3,   2,   2, ...,   5,   0,   4],
       [  2,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   8, ...,   4,   4,   7],
       [  4,   4,   6, ...,   5,   4,   3]], dtype=uint8)
desired = array([[6, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 4],
       [2, 2, 8, ..., 6, 2, 0],
       ...,
       [5, 1, 3, ..., 4, 2, 8],
       [6, 2, 8, ..., 4, 4, 7],
       [4, 4, 6, ..., 5, 4, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 102 / 10000 (1.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   2, ...,   5,   0,   4],
E              [  2,   2,   8, ...,   6,   2, 255],...
E        y: array([[6, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 4],
E              [2, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1063_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf0e53d0>  parameter: {...2), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   2,   1],
       [  3,   2,   3, ...,   5,   0,   4],
       [  3,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   9, ...,   4,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[5, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 4],
       [3, 2, 8, ..., 6, 2, 0],
       ...,
       [4, 1, 3, ..., 4, 2, 8],
       [6, 2, 9, ..., 4, 4, 8],
       [4, 4, 6, ..., 5, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 130 / 10000 (1.3%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   3, ...,   5,   0,   4],
E              [  3,   2,   8, ...,   6,   2, 255],...
E        y: array([[5, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 4],
E              [3, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1067_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf1188b0>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   2,   1],
       [  3,   2,   3, ...,   5,   0,   4],
       [  3,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   9, ...,   4,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[5, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 4],
       [3, 2, 8, ..., 6, 2, 0],
       ...,
       [4, 1, 3, ..., 4, 2, 8],
       [6, 2, 9, ..., 4, 4, 8],
       [4, 4, 6, ..., 5, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 130 / 10000 (1.3%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   3, ...,   5,   0,   4],
E              [  3,   2,   8, ...,   6,   2, 255],...
E        y: array([[5, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 4],
E              [3, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1069_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce8cb1c0>  parameter: {...2), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  5,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  3, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  4,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 179 / 10000 (1.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  5,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1073_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd6d4850>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  5,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  3, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  4,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 179 / 10000 (1.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  5,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1075_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd486280>  parameter: {...2), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   3,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  4,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  2, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  3,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 202 / 10000 (2.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  4,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1079_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf102640>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   3,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  4,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  2, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  3,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 202 / 10000 (2.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  4,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1093_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cc9f9790>  parameter: {...: (2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1097_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cee68310>  parameter: {...2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1099_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6ce2d3b50>  parameter: {...: (2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1103_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd645760>  parameter: {...2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1105_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cc9e18e0>  parameter: {...: (2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1109_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cc9e4820>  parameter: {...2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1111_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cc9e7d90>  parameter: {...: (2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1115_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd3525e0>  parameter: {...2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1129_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cc938520>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1133_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cc93a8b0>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1135_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cc938820>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1139_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cc93ad00>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1141_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cc9360a0>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1145_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd2fd8b0>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1147_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cd47fa30>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1151_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7ef6cf082a90>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestRotate.test_rotate_int[_param_77_{angle=-15, axes=(1, 0), cval=1.0, mode='nearest', order=3, output=None, prefilter=True, reshape=False}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestRotate object at 0x7ef6cbbe01f0>  parameter: {'angle': -15, 'axes': (1, 0), 'cval': 1.0, 'mode': 'nearest', 'order': 3, 'output': None, 'prefilter': True, 'reshape': False}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
       [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
...   0,   6,   4,   2,   4,   1,   1,   1, 255],
       [  4,   2,   7,   1,   2,   5,   0,   6,   9,   8]], dtype=uint8)
desired = array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
       [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
       [ 1,  5,  6, ...5,  0],
       [ 6,  0,  6,  4,  2,  4,  1,  1,  1,  0],
       [ 4,  2,  7,  1,  2,  5,  0,  6,  9,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 100 (1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
E              [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
E              [  1,   5,   6,   5,   4,   2,   3,   1,   9,   7],...
E        y: array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
E              [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
E              [ 1,  5,  6,  5,  4,  2,  3,  1,  9,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestRotate.test_rotate_int[_param_86_{angle=-15, axes=(1, 0), cval=1.0, mode='grid-wrap', order=3, output=None, prefilter=True, reshape=False}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestRotate object at 0x7ef6cbbffd60>  parameter: {'angle': -15, 'axes': (1, 0), 'cval': 1.0, 'mode': 'grid-wrap', 'order': 3, 'output': None, 'prefilter': True, 'reshape': False}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   7,   5,   6,   6,   4,   5,   5,   2,   6],
       [  5,   9,   6,   5,   9,   0,   1,   2,   9,   9],
...   0,   7,   4,   2,   4,   1,   2,   0,   6],
       [  7,   5,   5,   2,   2,   5, 255,   6,   9,   5]], dtype=uint8)
desired = array([[7, 7, 5, 6, 6, 4, 5, 5, 2, 6],
       [5, 9, 6, 5, 9, 0, 1, 2, 9, 9],
       [3, 4, 6, 5, 4, 2, 3, 1, 8, 7],
 ...2, 6, 8, 2, 2, 2, 4, 5, 0],
       [6, 0, 7, 4, 2, 4, 1, 2, 0, 6],
       [7, 5, 5, 2, 2, 5, 0, 6, 9, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 100 (1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   7,   5,   6,   6,   4,   5,   5,   2,   6],
E              [  5,   9,   6,   5,   9,   0,   1,   2,   9,   9],
E              [  3,   4,   6,   5,   4,   2,   3,   1,   8,   7],...
E        y: array([[7, 7, 5, 6, 6, 4, 5, 5, 2, 6],
E              [5, 9, 6, 5, 9, 0, 1, 2, 9, 9],
E              [3, 4, 6, 5, 4, 2, 3, 1, 8, 7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestRotate.test_rotate_int[_param_89_{angle=-15, axes=(1, 0), cval=1.0, mode='reflect', order=3, output=None, prefilter=True, reshape=False}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestRotate object at 0x7ef6cb774f70>  parameter: {'angle': -15, 'axes': (1, 0), 'cval': 1.0, 'mode': 'reflect', 'order': 3, 'output': None, 'prefilter': True, 'reshape': False}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
       [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
...   0,   6,   4,   2,   4,   1,   2,   1, 255],
       [  4,   3,   7,   1,   2,   5,   0,   6,   9,   8]], dtype=uint8)
desired = array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
       [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
       [ 0,  5,  6, ...5,  0],
       [ 6,  0,  6,  4,  2,  4,  1,  2,  1,  0],
       [ 4,  3,  7,  1,  2,  5,  0,  6,  9,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 100 (2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
E              [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
E              [  0,   5,   6,   5,   4,   2,   3,   1,   9,   7],...
E        y: array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
E              [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
E              [ 0,  5,  6,  5,  4,  2,  3,  1,  9,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestRotate.test_rotate_int[_param_92_{angle=-15, axes=(1, 0), cval=1.0, mode='grid-mirror', order=3, output=None, prefilter=True, reshape=False}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestRotate object at 0x7ef6cb5dec10>  parameter: {'angle': -15, 'axes': (1, 0), 'cval': 1.0, 'mode': 'grid-mirror', 'order': 3, 'output': None, 'prefilter': True, 'reshape': False}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
       [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
...   0,   6,   4,   2,   4,   1,   2,   1, 255],
       [  4,   3,   7,   1,   2,   5,   0,   6,   9,   8]], dtype=uint8)
desired = array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
       [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
       [ 0,  5,  6, ...5,  0],
       [ 6,  0,  6,  4,  2,  4,  1,  2,  1,  0],
       [ 4,  3,  7,  1,  2,  5,  0,  6,  9,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 100 (2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
E              [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
E              [  0,   5,   6,   5,   4,   2,   3,   1,   9,   7],...
E        y: array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
E              [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
E              [ 0,  5,  6,  5,  4,  2,  3,  1,  9,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_18_{cval=1.0, mode='constant', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6cab9a6d0>  parameter: {'cval': 1.0, 'mode': 'constant', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [1, 2, 6, ..., 2, 0, 3],
       [1, 5, 4, ..., 7, 9, 9],
       ...,
       [1, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [1, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [1, 2, 6, ..., 2, 0, 3],
       [1, 5, 4, ..., 7, 9, 9],
       ...,
       [1, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [1, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [1, 2, 6, ..., 2, 0, 3],
E              [1, 5, 4, ..., 7, 9, 9],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [1, 2, 6, ..., 2, 0, 3],
E              [1, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_24_{cval=1.0, mode='constant', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6caa47910>  parameter: {'cval': 1.0, 'mode': 'constant', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [1, 2, 6, ..., 2, 0, 3],
       [1, 5, 4, ..., 7, 9, 9],
       ...,
       [1, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [1, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [1, 2, 6, ..., 2, 0, 3],
       [1, 5, 4, ..., 7, 9, 9],
       ...,
       [1, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [1, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [1, 2, 6, ..., 2, 0, 3],
E              [1, 5, 4, ..., 7, 9, 9],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [1, 2, 6, ..., 2, 0, 3],
E              [1, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_45_{cval=1.0, mode='nearest', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6cabb1550>  parameter: {'cval': 1.0, 'mode': 'nearest', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 73 / 10000 (0.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_51_{cval=1.0, mode='nearest', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6cabb6220>  parameter: {'cval': 1.0, 'mode': 'nearest', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 73 / 10000 (0.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_72_{cval=1.0, mode='mirror', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6caa1c250>  parameter: {'cval': 1.0, 'mode': 'mirror', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 0],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 5, 4, ..., 7, 9, 9],
       ...,
       [8, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 0],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 5, 4, ..., 7, 9, 9],
       ...,
       [8, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 0],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 5, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 0],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_78_{cval=1.0, mode='mirror', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6caa106a0>  parameter: {'cval': 1.0, 'mode': 'mirror', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 0],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 5, 4, ..., 7, 9, 9],
       ...,
       [8, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 0],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 5, 4, ..., 7, 9, 9],
       ...,
       [8, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 0],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 5, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 0],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_99_{cval=1.0, mode='wrap', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6caa0c3d0>  parameter: {'cval': 1.0, 'mode': 'wrap', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 2, 4, ..., 7, 0, 8],
       [3, 2, 6, ..., 2, 0, 3],
       [9, 5, 4, ..., 7, 9, 9],
       ...,
       [3, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[8, 2, 4, ..., 7, 0, 8],
       [3, 2, 6, ..., 2, 0, 3],
       [9, 5, 4, ..., 7, 9, 9],
       ...,
       [3, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 2, 4, ..., 7, 0, 8],
E              [3, 2, 6, ..., 2, 0, 3],
E              [9, 5, 4, ..., 7, 9, 9],...
E        y: array([[8, 2, 4, ..., 7, 0, 8],
E              [3, 2, 6, ..., 2, 0, 3],
E              [9, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_105_{cval=1.0, mode='wrap', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6ca9ad1c0>  parameter: {'cval': 1.0, 'mode': 'wrap', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 2, 4, ..., 7, 0, 8],
       [3, 2, 6, ..., 2, 0, 3],
       [9, 5, 4, ..., 7, 9, 9],
       ...,
       [3, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[8, 2, 4, ..., 7, 0, 8],
       [3, 2, 6, ..., 2, 0, 3],
       [9, 5, 4, ..., 7, 9, 9],
       ...,
       [3, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 2, 4, ..., 7, 0, 8],
E              [3, 2, 6, ..., 2, 0, 3],
E              [9, 5, 4, ..., 7, 9, 9],...
E        y: array([[8, 2, 4, ..., 7, 0, 8],
E              [3, 2, 6, ..., 2, 0, 3],
E              [9, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_126_{cval=1.0, mode='grid-wrap', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6ca9c33d0>  parameter: {'cval': 1.0, 'mode': 'grid-wrap', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  1,  0,  3],
       [ 3,  5,  4, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  7,  9, ...,  8,  9,  1],
       [ 8,  1,  5, ...,  8,  0,  7]], dtype=uint8)
desired = array([[ 5,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  1,  0,  3],
       [ 3,  5,  4, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  7,  9, ...,  8,  9,  1],
       [ 8,  1,  5, ...,  8,  0,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 71 / 10000 (0.71%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  1,  0,  3],
E              [ 3,  5,  4, ...,  7,  9, 10],...
E        y: array([[ 5,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  1,  0,  3],
E              [ 3,  5,  4, ...,  7,  9, 10],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_132_{cval=1.0, mode='grid-wrap', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6ca9e07c0>  parameter: {'cval': 1.0, 'mode': 'grid-wrap', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  1,  0,  3],
       [ 3,  5,  4, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  7,  9, ...,  8,  9,  1],
       [ 8,  1,  5, ...,  8,  0,  7]], dtype=uint8)
desired = array([[ 5,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  1,  0,  3],
       [ 3,  5,  4, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  7,  9, ...,  8,  9,  1],
       [ 8,  1,  5, ...,  8,  0,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 71 / 10000 (0.71%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  1,  0,  3],
E              [ 3,  5,  4, ...,  7,  9, 10],...
E        y: array([[ 5,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  1,  0,  3],
E              [ 3,  5,  4, ...,  7,  9, 10],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_153_{cval=1.0, mode='reflect', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6ca9ba3a0>  parameter: {'cval': 1.0, 'mode': 'reflect', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 74 / 10000 (0.74%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_159_{cval=1.0, mode='reflect', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6ca3d92e0>  parameter: {'cval': 1.0, 'mode': 'reflect', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 74 / 10000 (0.74%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_180_{cval=1.0, mode='grid-mirror', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6ca9af670>  parameter: {'cval': 1.0, 'mode': 'grid-mirror', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 74 / 10000 (0.74%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_186_{cval=1.0, mode='grid-mirror', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6ca525190>  parameter: {'cval': 1.0, 'mode': 'grid-mirror', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 74 / 10000 (0.74%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_207_{cval=1.0, mode='grid-constant', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6ca30afd0>  parameter: {'cval': 1.0, 'mode': 'grid-constant', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 4,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  2,  0,  3],
       [ 3,  6,  3, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  6,  9, ...,  8,  9,  1],
       [ 8,  2,  5, ...,  8,  1,  8]], dtype=uint8)
desired = array([[ 4,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  2,  0,  3],
       [ 3,  6,  3, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  6,  9, ...,  8,  9,  1],
       [ 8,  2,  5, ...,  8,  1,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 71 / 10000 (0.71%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 4,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  2,  0,  3],
E              [ 3,  6,  3, ...,  7,  9, 10],...
E        y: array([[ 4,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  2,  0,  3],
E              [ 3,  6,  3, ...,  7,  9, 10],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_213_{cval=1.0, mode='grid-constant', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7ef6ca5df520>  parameter: {'cval': 1.0, 'mode': 'grid-constant', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 4,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  2,  0,  3],
       [ 3,  6,  3, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  6,  9, ...,  8,  9,  1],
       [ 8,  2,  5, ...,  8,  1,  8]], dtype=uint8)
desired = array([[ 4,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  2,  0,  3],
       [ 3,  6,  3, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  6,  9, ...,  8,  9,  1],
       [ 8,  2,  5, ...,  8,  1,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 71 / 10000 (0.71%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 4,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  2,  0,  3],
E              [ 3,  6,  3, ...,  7,  9, 10],...
E        y: array([[ 4,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  2,  0,  3],
E              [ 3,  6,  3, ...,  7,  9, 10],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
=============================== warnings summary ===============================
tests/cupy_tests/core_tests/fusion_tests/test_array.py: 1 warning
tests/cupy_tests/math_tests/test_sumprod.py: 19 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: overflow encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/core_tests/fusion_tests/test_routines.py::TestFusionNumericalReduction_param_1_{func='prod'}::test_reduction
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: overflow encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_0_{type_l='poly1d', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_3_{type_l='ndarray', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_array
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in multiply
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in half_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in byte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in short_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ubyte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ushort_scalars
    y = y * x + p[i]

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in power
    absx **= ord

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in reciprocal
    absx **= ord

tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf
tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf_nan
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/numeric.py:2276: RuntimeWarning: overflow encountered in absolute
    return less_equal(abs(x-y), atol + rtol * abs(y))

tests/cupy_tests/math_tests/test_sumprod.py: 15 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: invalid value encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: invalid value encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/math_tests/test_sumprod.py: 32 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.huAymRnpdw/cupy/tests/cupy_tests/math_tests/test_sumprod.py:799: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all_transposed2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes4
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axis_transposed2
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py::TestStats::test_only_input[_param_2_{op='variance'}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py::TestStats::test_only_input[_param_3_{op='standard_deviation'}]
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:47: RuntimeWarning: overflow encountered in reduce
    return umr_sum(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/statistics_tests/test_meanvar.py: 28 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.huAymRnpdw/cupy/tests/cupy_tests/statistics_tests/test_meanvar.py:114: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_4_{axis=0, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_5_{axis=0, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_6_{axis=0, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_7_{axis=0, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_8_{axis=1, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_9_{axis=1, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_10_{axis=1, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_11_{axis=1, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/nanfunctions.py:1113: RuntimeWarning: All-NaN slice encountered
    r, k = function_base._ureduce(a, func=_nanmedian, axis=axis, out=out,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_3_{func='mean', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_5_{func='mean', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3372: RuntimeWarning: Mean of empty slice.
    return _methods._mean(a, axis=axis, dtype=dtype,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:168: RuntimeWarning: invalid value encountered in true_divide
    ret = arr.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_9_{func='std', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_11_{func='std', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:233: RuntimeWarning: Degrees of freedom <= 0 for slice
    ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:194: RuntimeWarning: invalid value encountered in true_divide
    arrmean = um.true_divide(

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_15_{func='var', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_17_{func='var', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3621: RuntimeWarning: Degrees of freedom <= 0 for slice
    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_217_{cval=nan, mode='constant', order=0, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_220_{cval=nan, mode='constant', order=1, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_223_{cval=nan, mode='constant', order=3, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_226_{cval=inf, mode='constant', order=0, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_229_{cval=inf, mode='constant', order=1, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_232_{cval=inf, mode='constant', order=3, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_235_{cval=-inf, mode='constant', order=0, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_238_{cval=-inf, mode='constant', order=1, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_241_{cval=-inf, mode='constant', order=3, output=float64, prefilter=True, shift=0.1}]
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.huAymRnpdw/cupy/tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py:497: RuntimeWarning: invalid value encountered in remainder
    float_out = self._shift(xp, scp, a.astype(xp.float64)) % 1

tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/ndimage/measurements.py:684: RuntimeWarning: invalid value encountered in true_divide
    return sum / numpy.asanyarray(count).astype(numpy.float64)

tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py: 28 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/ndimage/measurements.py:736: RuntimeWarning: invalid value encountered in true_divide
    return sum_c_sq / np.asanyarray(count).astype(float)

tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_0_{im=(10,), mysize=3, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_1_{im=(10,), mysize=3, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_2_{im=(10,), mysize=4, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_3_{im=(10,), mysize=4, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_4_{im=(10,), mysize=(3, 4, 5), noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_5_{im=(10,), mysize=(3, 4, 5), noise=True}::test_wiener
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/signal/signaltools.py:1598: RuntimeWarning: divide by zero encountered in true_divide
    res *= (1 - noise / lVar)

tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_0_{im=(10,), mysize=3, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_1_{im=(10,), mysize=3, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_2_{im=(10,), mysize=4, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_3_{im=(10,), mysize=4, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_4_{im=(10,), mysize=(3, 4, 5), noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_5_{im=(10,), mysize=(3, 4, 5), noise=True}::test_wiener
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/signal/signaltools.py:1598: RuntimeWarning: invalid value encountered in multiply
    res *= (1 - noise / lVar)

-- Docs: https://docs.pytest.org/en/stable/warnings.html
- generated html file: file:///home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.huAymRnpdw/cupy/_output/report.html -
=========================== short test summary info ============================
FAILED tests/cupy_tests/linalg_tests/test_einsum.py::TestEinSumUnaryOperation_param_30_{_raw_params={'orig': {'shape_a': (2, 3), 'subscripts': '...'}, 'dec': 0, 'drop': True}, shape_a=(1, 1), subscripts='...'}::test_einsum_unary_dtype
FAILED tests/cupy_tests/manipulation_tests/test_dims.py::TestDims::test_atleast_2d2
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_156_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_158_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_160_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_162_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_324_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...6c553b0>, <function lt_pyfunc at 0x7ef7e6ca5f70>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_326_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...6c553b0>, <function lt_pyfunc at 0x7ef7e6ca5f70>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_484_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_486_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_488_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_490_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7ef7e8047b40>, <function rms_pyfunc at 0x7ef7e804f700>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_652_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...6c553b0>, <function lt_pyfunc at 0x7ef7e6ca5f70>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_654_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...6c553b0>, <function lt_pyfunc at 0x7ef7e6ca5f70>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_13_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_17_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_19_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_23_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_25_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_29_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_31_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_35_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_49_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_53_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_55_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_59_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_61_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_65_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_67_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_71_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_85_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_89_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_91_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_95_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_97_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_101_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_103_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_107_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_121_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_125_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_127_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_131_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_133_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_137_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_139_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_143_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_157_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_161_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_163_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_167_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_169_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_173_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_175_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_179_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_193_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_197_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_199_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_203_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_205_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_209_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_211_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_215_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_229_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_233_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_235_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_239_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_241_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_245_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_247_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_251_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_265_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_269_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_271_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_275_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_277_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_281_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_283_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_287_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_301_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_305_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_307_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_311_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_313_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_317_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_319_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_323_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_337_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_341_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_343_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_347_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_349_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_353_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_355_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_359_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_373_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_377_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_379_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_383_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_385_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_389_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_391_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_395_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_409_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_413_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_415_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_419_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_421_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_425_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_427_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_431_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_445_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_449_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_451_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_455_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_457_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_461_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_463_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_467_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_481_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_485_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_487_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_491_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_493_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_497_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_499_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_503_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_517_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_521_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_523_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_527_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_529_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_533_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_535_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_539_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_553_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_557_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_559_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_563_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_565_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_569_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_571_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_575_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_589_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_593_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_595_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_599_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_601_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_605_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_607_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_611_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_625_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_629_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_631_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_635_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_637_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_641_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_643_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_647_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_661_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_665_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_667_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_671_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_673_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_677_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_679_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_683_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_697_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_701_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_703_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_707_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_709_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_713_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_715_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_719_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_733_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_737_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_739_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_743_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_745_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_749_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_751_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_755_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_769_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_773_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_775_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_779_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_781_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_785_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_787_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_791_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_805_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_809_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_811_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_815_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_817_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_821_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_823_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_827_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_841_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_845_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_847_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_851_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_853_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_857_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_859_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_863_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_877_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_881_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_883_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_887_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_889_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_893_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_895_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_899_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_913_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_917_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_919_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_923_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_925_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_929_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_931_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_935_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_949_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_953_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_955_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_959_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_961_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_965_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_967_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_971_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_985_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_989_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_991_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_995_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_997_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1001_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1003_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1007_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1021_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1025_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1027_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1031_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1033_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1037_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1039_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1043_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1057_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1061_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1063_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1067_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1069_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1073_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1075_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1079_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1093_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1097_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1099_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1103_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1105_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1109_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1111_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1115_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1129_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1133_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1135_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1139_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1141_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1145_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1147_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1151_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestRotate::test_rotate_int[_param_77_{angle=-15, axes=(1, 0), cval=1.0, mode='nearest', order=3, output=None, prefilter=True, reshape=False}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestRotate::test_rotate_int[_param_86_{angle=-15, axes=(1, 0), cval=1.0, mode='grid-wrap', order=3, output=None, prefilter=True, reshape=False}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestRotate::test_rotate_int[_param_89_{angle=-15, axes=(1, 0), cval=1.0, mode='reflect', order=3, output=None, prefilter=True, reshape=False}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestRotate::test_rotate_int[_param_92_{angle=-15, axes=(1, 0), cval=1.0, mode='grid-mirror', order=3, output=None, prefilter=True, reshape=False}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_18_{cval=1.0, mode='constant', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_24_{cval=1.0, mode='constant', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_45_{cval=1.0, mode='nearest', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_51_{cval=1.0, mode='nearest', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_72_{cval=1.0, mode='mirror', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_78_{cval=1.0, mode='mirror', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_99_{cval=1.0, mode='wrap', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_105_{cval=1.0, mode='wrap', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_126_{cval=1.0, mode='grid-wrap', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_132_{cval=1.0, mode='grid-wrap', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_153_{cval=1.0, mode='reflect', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_159_{cval=1.0, mode='reflect', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_180_{cval=1.0, mode='grid-mirror', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_186_{cval=1.0, mode='grid-mirror', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_207_{cval=1.0, mode='grid-constant', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_213_{cval=1.0, mode='grid-constant', order=3, output='empty', prefilter=True, shift=0.1}]
= 290 failed, 63670 passed, 7173 skipped, 57 deselected, 229 xfailed, 272 warnings in 25394.22s (7:03:14) =
