============================= test session starts ==============================
platform linux -- Python 3.8.7, pytest-6.2.2, py-1.10.0, pluggy-0.13.1
rootdir: /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy, configfile: setup.cfg
plugins: html-3.1.1, metadata-1.11.0
collected 86609 items / 56 deselected / 86553 selected

tests/cupy_tests/test_cublas.py ........................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
...........................F...........F.............................F.. [  2%]
.........F..........                                                     [  2%]
tests/cupy_tests/test_cudnn.py sssssssssssssssssssssssssssssssssssssssss [  2%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  2%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssss                  [  4%]
tests/cupy_tests/test_cusolver.py ssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssss                                               [  5%]
tests/cupy_tests/test_cusparse.py ssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssss.Fsssssssssssssss  [  6%]
tests/cupy_tests/test_cutensor.py ssssssssssssssssssssssssssssssssssssss [  6%]
sssssssssssssssssssssssssssssssssssss                                    [  6%]
tests/cupy_tests/test_init.py ..s.......                                 [  6%]
tests/cupy_tests/test_ndim.py ............                               [  6%]
tests/cupy_tests/test_numpy_interop.py ..x....                           [  6%]
tests/cupy_tests/test_type_routines.py ................................. [  6%]
.                                                                        [  6%]
tests/cupy_tests/binary_tests/test_elementwise.py ......                 [  6%]
tests/cupy_tests/binary_tests/test_packing.py ...                        [  6%]
tests/cupy_tests/core_tests/test_array_function.py .....                 [  6%]
tests/cupy_tests/core_tests/test_carray.py .....                         [  6%]
tests/cupy_tests/core_tests/test_core.py ....                            [  6%]
tests/cupy_tests/core_tests/test_cub_reduction.py ssssssssssssssssssssss [  6%]
sss                                                                      [  7%]
tests/cupy_tests/core_tests/test_dlpack.py ..............                [  7%]
tests/cupy_tests/core_tests/test_elementwise.py ...............          [  7%]
tests/cupy_tests/core_tests/test_flags.py .............................  [  7%]
tests/cupy_tests/core_tests/test_function.py ..                          [  7%]
tests/cupy_tests/core_tests/test_internal.py ........................... [  7%]
...............................................................          [  7%]
tests/cupy_tests/core_tests/test_iter.py ............                    [  7%]
tests/cupy_tests/core_tests/test_ndarray.py ..........................ss [  7%]
ss...................................................................... [  7%]
.......................sss...............                                [  7%]
tests/cupy_tests/core_tests/test_ndarray_adv_indexing.py ............... [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
.............................................                            [  7%]
tests/cupy_tests/core_tests/test_ndarray_complex_ops.py ................ [  7%]
.....                                                                    [  7%]
tests/cupy_tests/core_tests/test_ndarray_contiguity.py .                 [  7%]
tests/cupy_tests/core_tests/test_ndarray_conversion.py .......FF..       [  7%]
tests/cupy_tests/core_tests/test_ndarray_copy_and_view.py ss........s... [  7%]
....ssss.......                                                          [  7%]
tests/cupy_tests/core_tests/test_ndarray_cuda_array_interface.py sssssss [  7%]
ssssssssssssssssssssssssssssssssssssssssssssssss                         [  7%]
tests/cupy_tests/core_tests/test_ndarray_elementwise_op.py ............. [  7%]
........................................................................ [  7%]
.................................................................        [  7%]
tests/cupy_tests/core_tests/test_ndarray_get.py ............             [  7%]
tests/cupy_tests/core_tests/test_ndarray_indexing.py FFFF..........F...F [  8%]
........F..........F.............................                        [  8%]
tests/cupy_tests/core_tests/test_ndarray_math.py ......................s [  8%]
sssssssssss                                                              [  8%]
tests/cupy_tests/core_tests/test_ndarray_owndata.py ...                  [  8%]
tests/cupy_tests/core_tests/test_ndarray_reduction.py .................. [  8%]
........................................................................ [  8%]
........................................................................ [  8%]
................................                                         [  8%]
tests/cupy_tests/core_tests/test_ndarray_scatter.py .................... [  8%]
........................................................................ [  8%]
...............................................................          [  8%]
tests/cupy_tests/core_tests/test_ndarray_ufunc.py .......                [  8%]
tests/cupy_tests/core_tests/test_ndarray_unary_op.py .......F..........s [  8%]
...                                                                      [  8%]
tests/cupy_tests/core_tests/test_raw.py .ss.........sss..s.s.s........ss [  8%]
.........sss..s.s.s........ss.........sss..s.s.s......ssssssssssssssssss [  8%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.s [  8%]
s.......sssss....s.s......sssssssssssssssssssssssssssss                  [  8%]
tests/cupy_tests/core_tests/test_reduction.py .....................      [  8%]
tests/cupy_tests/core_tests/test_scan.py ....                            [  8%]
tests/cupy_tests/core_tests/test_syncdetect.py ....                      [  8%]
tests/cupy_tests/core_tests/test_userkernel.py ....sss.............      [  8%]
tests/cupy_tests/core_tests/fusion_tests/test_array.py ................. [  8%]
.............FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [  8%]
FFFFFFFFFFF.FFFFFFFFFFF.FFFFFFFFFFF.FFFFFFFFFFFFFFFF                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_indexing.py FFFFFFFFFFFFFF [  9%]
FFFFFFF....FFFFFFs                                                       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py FFFF       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_misc.py FFFFFFFsFF.F..FFFF [  9%]
FFFFFFF.                                                                 [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_optimization.py .......... [  9%]
....                                                                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_reduction.py ............. [  9%]
........................................................................ [  9%]
.........................................................s.s.s.s.s.s.s.s [  9%]
.s.ssssssssssssssssss.sss                                                [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_routines.py .............. [  9%]
........................................................................ [  9%]
..............                                                           [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_ufunc.py ................. [  9%]
......................................................                   [  9%]
tests/cupy_tests/creation_tests/test_basic.py .......................... [  9%]
...........................................................s............ [  9%]
....s.                                                                   [  9%]
tests/cupy_tests/creation_tests/test_from_data.py ssssssssssssssssssssss [  9%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss............. [  9%]
...................................................................      [  9%]
tests/cupy_tests/creation_tests/test_matrix.py ......................... [  9%]
.................................                                        [  9%]
tests/cupy_tests/creation_tests/test_ranges.py ......................... [  9%]
..............................................................           [ 10%]
tests/cupy_tests/cuda_tests/test_compiler.py sssssss........             [ 10%]
tests/cupy_tests/cuda_tests/test_cublas.py .                             [ 10%]
tests/cupy_tests/cuda_tests/test_cudnn.py s                              [ 10%]
tests/cupy_tests/cuda_tests/test_cufft.py FFFFFFFFssssssss.              [ 10%]
tests/cupy_tests/cuda_tests/test_curand.py .....                         [ 10%]
tests/cupy_tests/cuda_tests/test_cusolver.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cusparse.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cutensor.py s                           [ 10%]
tests/cupy_tests/cuda_tests/test_device.py .............F.               [ 10%]
tests/cupy_tests/cuda_tests/test_driver.py ss.                           [ 10%]
tests/cupy_tests/cuda_tests/test_memory.py ....ssssssss..........sssssss [ 10%]
sss.................................................ssssss               [ 10%]
tests/cupy_tests/cuda_tests/test_memory_hook.py .                        [ 10%]
tests/cupy_tests/cuda_tests/test_nccl.py ........                        [ 10%]
tests/cupy_tests/cuda_tests/test_nvrtc.py .                              [ 10%]
tests/cupy_tests/cuda_tests/test_nvtx.py ....                            [ 10%]
tests/cupy_tests/cuda_tests/test_pinned_memory.py ............           [ 10%]
tests/cupy_tests/cuda_tests/test_profile.py ..                           [ 10%]
tests/cupy_tests/cuda_tests/test_runtime.py .                            [ 10%]
tests/cupy_tests/cuda_tests/test_stream.py ....s...s                     [ 10%]
tests/cupy_tests/cuda_tests/test_texture.py FFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 10%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 10%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 10%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF [ 10%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFssFFssFFFFssssFFFFF      [ 10%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_debug_print.py .     [ 10%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_line_profile.py ..   [ 10%]
tests/cupy_tests/fft_tests/test_cache.py ..sss.....s..                   [ 10%]
tests/cupy_tests/fft_tests/test_callback.py ssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 10%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssss                     [ 11%]
tests/cupy_tests/fft_tests/test_fft.py ................................. [ 11%]
........................................................................ [ 11%]
...............................................................sssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
sssssssssssssss......................................................... [ 11%]
................................................s................s...... [ 11%]
..........s..............................ssssssssssssssssssssssss....... [ 11%]
........................................................................ [ 11%]
........................................................................ [ 11%]
.......s..sssssssssssss................................................. [ 12%]
...................................                                      [ 12%]
tests/cupy_tests/functional_tests/test_piecewise.py .............        [ 12%]
tests/cupy_tests/functional_tests/test_vectorize.py .................... [ 12%]
..............                                                           [ 12%]
tests/cupy_tests/indexing_tests/test_generate.py .......F............... [ 12%]
...............                                                          [ 12%]
tests/cupy_tests/indexing_tests/test_indexing.py ....................... [ 12%]
..........................                                               [ 12%]
tests/cupy_tests/indexing_tests/test_insert.py ......................... [ 12%]
........................................................................ [ 12%]
........................................................................ [ 12%]
.........................................................                [ 12%]
tests/cupy_tests/indexing_tests/test_iterate.py ........................ [ 12%]
...............................................                          [ 12%]
tests/cupy_tests/io_tests/test_base_n.py ............................    [ 12%]
tests/cupy_tests/io_tests/test_formatting.py ..                          [ 12%]
tests/cupy_tests/io_tests/test_npz.py .......                            [ 12%]
tests/cupy_tests/lib_tests/test_polynomial.py .......ss.......ssssssssss [ 12%]
sssssss........ssssssssssssssssssssssssssssssssssssFFFFFFFFFFFFFFFFFFFF. [ 12%]
..ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 12%]
ssssssssssssssssssssssssss....FFFFFFFFFFFFFFFFFFFFFFFFFF................ [ 12%]
........................................................................ [ 13%]
........FFFFFFFF........FFFFFFFF........................................ [ 13%]
...........FFFFFF............................F.......................... [ 13%]
..                                                                       [ 13%]
tests/cupy_tests/lib_tests/test_shape_base.py ......................     [ 13%]
tests/cupy_tests/lib_tests/test_strided_tricks.py ..                     [ 13%]
tests/cupy_tests/linalg_tests/test_decomposition.py .................... [ 13%]
.                                                                        [ 13%]
tests/cupy_tests/linalg_tests/test_eigenvalue.py FFFFFFFF                [ 13%]
tests/cupy_tests/linalg_tests/test_einsum.py ........................... [ 13%]
........................................................................ [ 13%]
....F................................................................... [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 13%]
........................................................................ [ 14%]
........................................................................ [ 14%]
..........                                                               [ 14%]
tests/cupy_tests/linalg_tests/test_norms.py ............................ [ 14%]
........................................................................ [ 14%]
........................................................................ [ 14%]
.................................................................        [ 14%]
tests/cupy_tests/linalg_tests/test_product.py .......................... [ 14%]
........................................................................ [ 14%]
........................................................................ [ 14%]
..........................................                               [ 14%]
tests/cupy_tests/linalg_tests/test_solve.py ............................ [ 14%]
..                                                                       [ 14%]
tests/cupy_tests/logic_tests/test_comparison.py ........................ [ 14%]
.....                                                                    [ 14%]
tests/cupy_tests/logic_tests/test_content.py ...                         [ 14%]
tests/cupy_tests/logic_tests/test_ops.py ....                            [ 14%]
tests/cupy_tests/logic_tests/test_truth.py ............................. [ 14%]
........................................................................ [ 14%]
........................................................................ [ 14%]
........................................................................ [ 14%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
...........................................                              [ 15%]
tests/cupy_tests/logic_tests/test_type_test.py ......................... [ 15%]
.......                                                                  [ 15%]
tests/cupy_tests/manipulation_tests/test_add_remove.py ................. [ 15%]
.........................                                                [ 15%]
tests/cupy_tests/manipulation_tests/test_basic.py ...................... [ 15%]
.......................................................                  [ 15%]
tests/cupy_tests/manipulation_tests/test_dims.py .....F.F............... [ 15%]
................................................                         [ 15%]
tests/cupy_tests/manipulation_tests/test_join.py ....................... [ 15%]
...........................                                              [ 15%]
tests/cupy_tests/manipulation_tests/test_kind.py ...........             [ 15%]
tests/cupy_tests/manipulation_tests/test_rearrange.py .................. [ 15%]
.................................                                        [ 15%]
tests/cupy_tests/manipulation_tests/test_shape.py ...................... [ 15%]
....................................                                     [ 15%]
tests/cupy_tests/manipulation_tests/test_split.py ..................     [ 16%]
tests/cupy_tests/manipulation_tests/test_tiling.py ..................... [ 16%]
...........                                                              [ 16%]
tests/cupy_tests/manipulation_tests/test_transpose.py .................. [ 16%]
..........                                                               [ 16%]
tests/cupy_tests/math_tests/test_arithmetic.py ......................... [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
...........................                                              [ 25%]
tests/cupy_tests/math_tests/test_explog.py .........                     [ 25%]
tests/cupy_tests/math_tests/test_floating.py .......                     [ 25%]
tests/cupy_tests/math_tests/test_hyperbolic.py ......                    [ 25%]
tests/cupy_tests/math_tests/test_matmul.py ............................. [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
......................................                                   [ 25%]
tests/cupy_tests/math_tests/test_misc.py ............................... [ 25%]
............................................F..F..F..................... [ 25%]
............................                                             [ 25%]
tests/cupy_tests/math_tests/test_rational.py ..F.                        [ 25%]
tests/cupy_tests/math_tests/test_rounding.py ........................... [ 25%]
..........................................                               [ 26%]
tests/cupy_tests/math_tests/test_special.py ...                          [ 26%]
tests/cupy_tests/math_tests/test_sumprod.py ............................ [ 26%]
....................................................ssssssssssssssss.... [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
..............................................................           [ 26%]
tests/cupy_tests/math_tests/test_trigonometric.py ...............        [ 26%]
tests/cupy_tests/math_tests/test_window.py ............................. [ 26%]
.....                                                                    [ 26%]
tests/cupy_tests/misc_tests/test_memory_ranges.py ................       [ 26%]
tests/cupy_tests/misc_tests/test_who.py ......                           [ 26%]
tests/cupy_tests/padding_tests/test_pad.py ............................. [ 27%]
..............................................                           [ 27%]
tests/cupy_tests/polynomial_tests/test_polynomial.py ................... [ 27%]
                                                                         [ 27%]
tests/cupy_tests/polynomial_tests/test_polyutils.py .................... [ 27%]
................                                                         [ 27%]
tests/cupy_tests/prof_tests/test_range.py ........                       [ 27%]
tests/cupy_tests/random_tests/test_bit_generator.py ssssssssssss         [ 27%]
tests/cupy_tests/random_tests/test_distributions.py .................... [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
................................                                         [ 28%]
tests/cupy_tests/random_tests/test_generator.py ........................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
.................................................................F...... [ 28%]
......................F...............................                   [ 28%]
tests/cupy_tests/random_tests/test_generator_api.py sssssssssssssssss    [ 28%]
tests/cupy_tests/random_tests/test_init.py .                             [ 28%]
tests/cupy_tests/random_tests/test_permutations.py ...x...x............. [ 28%]
........................................................................ [ 28%]
........................................................................ [ 29%]
.............                                                            [ 29%]
tests/cupy_tests/random_tests/test_random.py .                           [ 29%]
tests/cupy_tests/random_tests/test_sample.py ...............F........F.. [ 29%]
............                                                             [ 29%]
tests/cupy_tests/sorting_tests/test_count.py ....                        [ 29%]
tests/cupy_tests/sorting_tests/test_search.py ssssssss........ssssssss.. [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
....................................................................     [ 29%]
tests/cupy_tests/sorting_tests/test_sort.py ............................ [ 29%]
........................................................................ [ 29%]
..........................................................x......X....   [ 29%]
tests/cupy_tests/statistics_tests/test_correlation.py .................. [ 29%]
..............................F..F.FF...................                 [ 29%]
tests/cupy_tests/statistics_tests/test_histogram.py .................... [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................                 [ 30%]
tests/cupy_tests/statistics_tests/test_meanvar.py ...................... [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
..                                                                       [ 30%]
tests/cupy_tests/statistics_tests/test_order.py ........................ [ 30%]
....................                                                     [ 30%]
tests/cupy_tests/testing_tests/test_array.py ........................... [ 30%]
...............................................                          [ 30%]
tests/cupy_tests/testing_tests/test_condition.py ................        [ 30%]
tests/cupy_tests/testing_tests/test_helper.py .......................... [ 30%]
........................................................................ [ 30%]
.....sssss..sssssss..ssxxxxxxxx................x..x.................     [ 30%]
tests/cupy_tests/testing_tests/test_parameterized.py ............s.s.s.s [ 30%]
....ssss......                                                           [ 30%]
tests/cupyx_tests/test_cupyx.py ..                                       [ 30%]
tests/cupyx_tests/test_lapack.py .s.s.s.s.....s.s.s.s.....s.s.s.s.....s. [ 30%]
s.s.s.............sssssssssssss                                          [ 30%]
tests/cupyx_tests/test_optimize.py sssssssss                             [ 30%]
tests/cupyx_tests/test_rsqrt.py .                                        [ 30%]
tests/cupyx_tests/test_runtime.py s.                                     [ 30%]
tests/cupyx_tests/test_scatter.py ...                                    [ 30%]
tests/cupyx_tests/test_time.py .........                                 [ 30%]
tests/cupyx_tests/fallback_mode_tests/test_fallback.py ................. [ 30%]
........................................................................ [ 30%]
.........                                                                [ 30%]
tests/cupyx_tests/fallback_mode_tests/test_notifications.py .........    [ 30%]
tests/cupyx_tests/linalg_tests/test_solve.py FFFFFFFFFFFFFFFF....ssss    [ 30%]
tests/cupyx_tests/linalg_tests/sparse_tests/test_solve.py ssssssss       [ 30%]
tests/cupyx_tests/scipy_tests/test_get_array_module.py ss                [ 30%]
tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py .ss.....ss.....ss... [ 30%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 31%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 31%]
.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.. [ 31%]
...ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.... [ 31%]
.ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....s [ 31%]
s.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss. [ 31%]
....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss... [ 31%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 31%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 31%]
.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.. [ 31%]
...ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.... [ 31%]
.ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....s [ 31%]
s.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss. [ 32%]
....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss... [ 32%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 32%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 32%]
.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.. [ 32%]
...ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.... [ 32%]
.ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....s [ 32%]
s.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss. [ 32%]
....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss... [ 32%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 32%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 32%]
.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.. [ 32%]
...ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.... [ 33%]
.ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....s [ 33%]
s.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss. [ 33%]
....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss... [ 33%]
..ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss..... [ 33%]
ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss.....ss [ 33%]
.....ss.....ss.....ss.....ss.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 33%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.....s.. [ 34%]
...s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.s [ 34%]
ss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.s [ 34%]
ss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.s [ 34%]
ss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.s [ 34%]
ss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s.sss.s.....s...s...s...s.. [ 34%]
.s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s.. [ 34%]
.s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s.. [ 34%]
.s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s...s.. [ 35%]
.s...s...s...s...s...s..........                                         [ 35%]
tests/cupyx_tests/scipy_tests/fft_tests/test_helper.py .                 [ 35%]
tests/cupyx_tests/scipy_tests/fftpack_tests/test_fftpack.py ssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
sssssssssssssssssss......                                                [ 36%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py sssssssssss [ 36%]
sssssssssssssssssssssssssssssssssssssssssssssssssss                      [ 36%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_solve_triangular.py ssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss     [ 36%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_special_matrices.py ssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
sssssssssssssssssssssssssssssssssssssssssssssssss                        [ 36%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py ssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 36%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 37%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 38%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 39%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 40%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 41%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 42%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 43%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssss                                     [ 44%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_fourier.py ssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 44%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssss                                 [ 45%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py ssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 45%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 46%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 47%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 48%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 49%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 50%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 51%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 52%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 53%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 54%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 55%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 56%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 57%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 58%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssss........................................................ [ 59%]
........................................................................ [ 59%]
........................................................................ [ 59%]
........................................ssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
sssssssssssssssssssssssssssssssssssssssss............................... [ 59%]
.........sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 59%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss              [ 60%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py sssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 60%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 61%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 62%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 63%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
sss                                                                      [ 64%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_morphology.py sssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 64%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 65%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 66%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 67%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 68%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 69%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 70%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 71%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 72%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 73%]
                                                                         [ 73%]
tests/cupyx_tests/scipy_tests/signal_tests/test_bsplines.py ssssssssssss [ 73%]
                                                                         [ 73%]
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py sssssssss [ 73%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
sssssssssssssss...............ssssssssssssssssssssssssssssssssssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssss                                     [ 74%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_base.py sssssss          [ 74%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py sssssssssss [ 74%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 74%]
sssssFFF.FFF.FFFFFFFFFFFFFFFFFFFsFFFFFFFsFF..FF.sFFFFFFFsFFFFFFFsFF..FF. [ 74%]
sFFsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 75%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 76%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssss                                               [ 77%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py ....s.FsFs.....sF [ 77%]
....s.FsFs.....sF....s.FsFs.....sF....s.FsFs.....sFsssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 77%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 78%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
sssssssssssssssssss..                                                    [ 79%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py ....s...sFsFFFsFF [ 79%]
..F.sF....s...sFsFFFsFF..F.sF....s...sFsFFFsFF..F.sF....s...sFsFFFsFF..F [ 79%]
.sFsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 79%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 80%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 81%]
sssssssssssssssssssssssssssssss..                                        [ 81%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py ....s...sFsFFFsFF [ 82%]
..F.sF....s...sFsFFFsFF..F.sF....s...sFsFFFsFF..F.sF....s...sFsFFFsFF..F [ 82%]
.sFsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 82%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 83%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 84%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 85%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 86%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 87%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 88%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss..        [ 89%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py ..........sF..... [ 89%]
.....sF..........sF..........sFsssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 89%]
sssssssssssssssssssssssssss..                                            [ 89%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_extract.py sssssssssssss [ 89%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
sssssssssssssssssssssss                                                  [ 90%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_index.py sssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 90%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 91%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 92%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 93%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 94%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 95%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
sssssssssssssssssssss                                                    [ 96%]
tests/cupyx_tests/scipy_tests/sparse_tests/test_linalg.py ssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 96%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 97%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 98%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssss                                   [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_bessel.py ssssssssssss  [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_convex_analysis.py ssss [ 99%]
s                                                                        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_digamma.py sssss        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_erf.py ssssssssssss     [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gamma.py ssss           [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gammaln.py ssss         [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_polygamma.py ssss       [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_statistics.py ss        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_zeta.py ssss            [ 99%]
tests/cupyx_tests/scipy_tests/stats_tests/test_distributions.py ssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss........ [ 99%]
                                                                         [ 99%]
tests/cupyx_tests/tools_tests/test_install_library.py ..                 [ 99%]
tests/example_tests/test_finance.py .FF                                  [ 99%]
tests/example_tests/test_gemm.py .                                       [ 99%]
tests/example_tests/test_gmm.py ss                                       [ 99%]
tests/example_tests/test_kmeans.py sss                                   [ 99%]
tests/install_tests/test_build.py FF                                     [ 99%]
tests/install_tests/test_utils.py ..                                     [100%]

=================================== FAILURES ===================================
_ TestDgmm_param_5_{ordera='C', orderc='F', shape=(9, 10), side='R'}.test_dgmm_incx_minus_one _

self = <<cupy_tests.test_cublas.TestDgmm_param_5_{ordera='C', orderc='F', shape=(9, 10), side='R'} testMethod=test_dgmm_incx_minus_one>  parameter: {'ordera': 'C', 'orderc': 'F', 'shape': (9, 10), 'side': 'R'}>
dtype = <class 'numpy.float32'>

    @testing.for_dtypes('fdFD')
    def test_dgmm_incx_minus_one(self, dtype):
        if self.orderc != 'F':
            raise unittest.SkipTest()
        self._setup(dtype)
        if self.side == 'L':
            ref = cupy.diag(self.x[::-1]) @ self.a
        elif self.side == 'R':
            ref = self.a @ cupy.diag(self.x[::-1])
        c = cublas.dgmm(self.side, self.a, self.x, incx=-1)
>       cupy.testing.assert_allclose(c, ref, rtol=self.tol, atol=self.tol)

tests/cupy_tests/test_cublas.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 0.5288711 ,  0.6377865 ,  0.26376152,  0.35193685,  0.17948338,
         0.35193685,  0.26376152,  0.6377865 ....44726366,  0.24004342,
         0.14460628,  0.31539476,  0.06718525,  0.31608725, -0.34620836]],
      dtype=float32)
desired = array([[0.21043788, 0.6892013 , 0.5375281 , 0.23843391, 0.27363613,
        0.27363613, 0.23843391, 0.5375281 , 0.6892...5  , 0.30301693, 0.36596453,
        0.11243354, 0.28510907, 0.0566239 , 0.4119108 , 0.5100103 ]],
      dtype=float32)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 90 / 90 (100%)
E       Max absolute difference: 0.8562187
E       Max relative difference: 1.6788263
E        x: array([[ 0.528871,  0.637787,  0.263762,  0.351937,  0.179483,  0.351937,
E                0.263762,  0.637787,  0.528871, -0.142851],
E              [ 0.762956,  0.471654,  0.248569,  0.597837,  0.030095,  0.047475,...
E        y: array([[0.210438, 0.689201, 0.537528, 0.238434, 0.273636, 0.273636,
E               0.238434, 0.537528, 0.689201, 0.210438],
E              [0.30358 , 0.509676, 0.506567, 0.405029, 0.045882, 0.036913,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is f
_ TestDgmm_param_7_{ordera='C', orderc='F', shape=(10, 9), side='R'}.test_dgmm_incx_minus_one _

self = <<cupy_tests.test_cublas.TestDgmm_param_7_{ordera='C', orderc='F', shape=(10, 9), side='R'} testMethod=test_dgmm_incx_minus_one>  parameter: {'ordera': 'C', 'orderc': 'F', 'shape': (10, 9), 'side': 'R'}>
dtype = <class 'numpy.float32'>

    @testing.for_dtypes('fdFD')
    def test_dgmm_incx_minus_one(self, dtype):
        if self.orderc != 'F':
            raise unittest.SkipTest()
        self._setup(dtype)
        if self.side == 'L':
            ref = cupy.diag(self.x[::-1]) @ self.a
        elif self.side == 'R':
            ref = self.a @ cupy.diag(self.x[::-1])
        c = cublas.dgmm(self.side, self.a, self.x, incx=-1)
>       cupy.testing.assert_allclose(c, ref, rtol=self.tol, atol=self.tol)

tests/cupy_tests/test_cublas.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0.11549115, 0.6892013 , 0.5375281 , 0.23843391, 0.27363613,
        0.27363613, 0.23843391, 0.5375281 , 0.6892....06181655, 0.6175279 , 0.24793755, 0.17141351,
        0.22167656, 0.05118661, 0.34715945, 0.6646227 ]], dtype=float32)
desired = array([[0.5288711 , 0.6377865 , 0.26376152, 0.35193685, 0.17948338,
        0.35193685, 0.26376152, 0.6377865 , 0.5288....057205  , 0.30301693, 0.36596453, 0.11243354,
        0.28510907, 0.0566239 , 0.4119108 , 0.5100103 ]], dtype=float32)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 90 / 90 (100%)
E       Max absolute difference: 0.73572075
E       Max relative difference: 1.0379322
E        x: array([[0.115491, 0.689201, 0.537528, 0.238434, 0.273636, 0.273636,
E               0.238434, 0.537528, 0.689201],
E              [0.080691, 0.762956, 0.471654, 0.248569, 0.597837, 0.030095,...
E        y: array([[0.528871, 0.637787, 0.263762, 0.351937, 0.179483, 0.351937,
E               0.263762, 0.637787, 0.528871],
E              [0.369508, 0.706039, 0.231438, 0.366897, 0.392133, 0.038706,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is f
_ TestDgmm_param_12_{ordera='F', orderc='F', shape=(9, 10), side='L'}.test_dgmm_incx_minus_one _

self = <<cupy_tests.test_cublas.TestDgmm_param_12_{ordera='F', orderc='F', shape=(9, 10), side='L'} testMethod=test_dgmm_incx_minus_one>  parameter: {'ordera': 'F', 'orderc': 'F', 'shape': (9, 10), 'side': 'L'}>
dtype = <class 'numpy.float32'>

    @testing.for_dtypes('fdFD')
    def test_dgmm_incx_minus_one(self, dtype):
        if self.orderc != 'F':
            raise unittest.SkipTest()
        self._setup(dtype)
        if self.side == 'L':
            ref = cupy.diag(self.x[::-1]) @ self.a
        elif self.side == 'R':
            ref = self.a @ cupy.diag(self.x[::-1])
        c = cublas.dgmm(self.side, self.a, self.x, incx=-1)
>       cupy.testing.assert_allclose(c, ref, rtol=self.tol, atol=self.tol)

tests/cupy_tests/test_cublas.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0.9201937 , 1.1991554 , 1.0106511 , 0.9136037 , 0.7103405 ,
        1.0829684 , 0.7337009 , 1.4952326 , 1.6157...761, 0.49524868, 0.40522733,
        0.18980375, 0.37422144, 0.06718525, 0.4119108 , 0.6646227 ]],
      dtype=float32)
desired = array([[0.5288711 , 0.6892013 , 0.5808606 , 0.52508366, 0.40826035,
        0.62242407, 0.42168647, 0.8593684 , 0.9286...501, 0.38003805, 0.31095853,
        0.14564934, 0.2871656 , 0.05155582, 0.31608725, 0.5100103 ]],
      dtype=float32)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 90 / 90 (100%)
E       Max absolute difference: 0.68712395
E       Max relative difference: 1.0379322
E        x: array([[0.920194, 1.199155, 1.010651, 0.913604, 0.71034 , 1.082968,
E               0.733701, 1.495233, 1.61577 , 0.642915],
E              [0.762956, 0.509676, 0.547403, 0.891963, 0.068455, 0.083963,...
E        y: array([[0.528871, 0.689201, 0.580861, 0.525084, 0.40826 , 0.622424,
E               0.421686, 0.859368, 0.928646, 0.369508],
E              [0.706039, 0.471654, 0.506567, 0.825422, 0.063348, 0.0777  ,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is f
_ TestDgmm_param_14_{ordera='F', orderc='F', shape=(10, 9), side='L'}.test_dgmm_incx_minus_one _

self = <<cupy_tests.test_cublas.TestDgmm_param_14_{ordera='F', orderc='F', shape=(10, 9), side='L'} testMethod=test_dgmm_incx_minus_one>  parameter: {'ordera': 'F', 'orderc': 'F', 'shape': (10, 9), 'side': 'L'}>
dtype = <class 'numpy.float32'>

    @testing.for_dtypes('fdFD')
    def test_dgmm_incx_minus_one(self, dtype):
        if self.orderc != 'F':
            raise unittest.SkipTest()
        self._setup(dtype)
        if self.side == 'L':
            ref = cupy.diag(self.x[::-1]) @ self.a
        elif self.side == 'R':
            ref = self.a @ cupy.diag(self.x[::-1])
        c = cublas.dgmm(self.side, self.a, self.x, incx=-1)
>       cupy.testing.assert_allclose(c, ref, rtol=self.tol, atol=self.tol)

tests/cupy_tests/test_cublas.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0.5288711 , 0.6892013 , 0.5808606 , 0.52508366, 0.40826035,
        0.62242407, 0.42168647, 0.8593684 , 0.9286....12011283, 1.2966179 , 1.0609316 , 0.49692798,
        0.9797547 , 0.1758987 , 1.0784297 , 1.7400585 ]], dtype=float32)
desired = array([[0.21043788, 0.27423328, 0.23112449, 0.20893084, 0.16244683,
        0.24766262, 0.1677891 , 0.3419428 , 0.3695....03520501, 0.38003805, 0.31095853, 0.14564934,
        0.2871656 , 0.05155582, 0.31608725, 0.5100103 ]], dtype=float32)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 90 / 90 (100%)
E       Max absolute difference: 1.2300482
E       Max relative difference: 2.4118106
E        x: array([[0.528871, 0.689201, 0.580861, 0.525084, 0.40826 , 0.622424,
E               0.421686, 0.859368, 0.928646],
E              [0.341943, 0.706039, 0.471654, 0.506567, 0.825422, 0.063348,...
E        y: array([[0.210438, 0.274233, 0.231124, 0.208931, 0.162447, 0.247663,
E               0.167789, 0.341943, 0.369508],
E              [0.369508, 0.762956, 0.509676, 0.547403, 0.891963, 0.068455,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is f
________________________ TestMatDescriptor.test_pickle _________________________

self = <cupy_tests.test_cusparse.TestMatDescriptor testMethod=test_pickle>

    def test_pickle(self):
        md = cusparse.MatDescriptor.create()
        md2 = pickle.loads(pickle.dumps(md))
        assert isinstance(md2.descriptor, int)
>       assert md.descriptor != md2.descriptor
E       AssertionError: assert 94662794414224 != 94662794414224
E        +  where 94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f20a0df3820>.descriptor
E        +  and   94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f20a0df3040>.descriptor

tests/cupy_tests/test_cusparse.py:27: AssertionError
______________ TestNdarrayToBytes_param_1_{shape=(1,)}.test_item _______________
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <<cupy_tests.core_tests.test_ndarray_conversion.TestNdarrayToBytes_param_1_{shape=(1,)} testMethod=test_item>  parameter: {'shape': (1,)}>
args = (), kw = {'dtype': <class 'numpy.int32'>}
cupy_result = b'\x00\x00\x00\x00', cupy_error = None
numpy_result = b'\x01\x00\x00\x00', numpy_error = None
message = "Results are not equal:\ncupy: b'\\x00\\x00\\x00\\x00'\nnumpy: b'\\x01\\x00\\x00\\x00'"

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
    
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(
                        cupy_error, numpy_error,
                        accept_error=False)
                    return
    
                if cupy_result != numpy_result:
                    message = '''Results are not equal:
    cupy: %s
    numpy: %s''' % (str(cupy_result), str(numpy_result))
>                   raise AssertionError(message)
E                   AssertionError: Results are not equal:
E                   cupy: b'\x00\x00\x00\x00'
E                   numpy: b'\x01\x00\x00\x00'

cupy/testing/helper.py:758: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int32'>
_____________ TestNdarrayToBytes_param_2_{shape=(2, 3)}.test_item ______________
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <<cupy_tests.core_tests.test_ndarray_conversion.TestNdarrayToBytes_param_2_{shape=(2, 3)} testMethod=test_item>  parameter: {'shape': (2, 3)}>
args = (), kw = {'dtype': <class 'numpy.float64'>}
cupy_result = b'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x00\x18@'
cupy_error = None
numpy_result = b'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x00\x18@'
numpy_error = None
message = "Results are not equal:\ncupy: b'\\x00\\x00\\x80?\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x...x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@\\x00\\x00\\x00\\x00\\x00\\x00\\x14@\\x00\\x00\\x00\\x00\\x00\\x00\\x18@'"

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
    
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(
                        cupy_error, numpy_error,
                        accept_error=False)
                    return
    
                if cupy_result != numpy_result:
                    message = '''Results are not equal:
    cupy: %s
    numpy: %s''' % (str(cupy_result), str(numpy_result))
>                   raise AssertionError(message)
E                   AssertionError: Results are not equal:
E                   cupy: b'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x00\x18@'
E                   numpy: b'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x00\x18@'

cupy/testing/helper.py:758: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestArrayIndexingParameterized_param_0_{indexes=(1, 0, 2), shape=(2, 3, 4), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array(15., dtype=float16), y = 15.0, err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 15.
E       Max relative difference: 1.
E        x: array(0., dtype=float16)
E        y: array(15., dtype=float16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float16'>
_ TestArrayIndexingParameterized_param_1_{indexes=(-1, 0, -2), shape=(2, 3, 4), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array(15, dtype=uint32), y = 15, err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4294967281
E       Max relative difference: 2.86331152e+08
E        x: array(0, dtype=uint32)
E        y: array(15, dtype=uint32)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint32'>
_ TestArrayIndexingParameterized_param_2_{indexes=(1, 0, 2), shape=(2, 3, 4), transpose=(2, 0, 1)}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array(10, dtype=int32), y = 10, err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 1075052534
E       Max relative difference: 1.07505253e+08
E        x: array(1075052544, dtype=int32)
E        y: array(10, dtype=int32)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int32'>
_ TestArrayIndexingParameterized_param_3_{indexes=(-1, 0, -2), shape=(2, 3, 4), transpose=(2, 0, 1)}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array(8, dtype=int16), y = 8, err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 16376
E       Max relative difference: 2047.
E        x: array(16384, dtype=int16)
E        y: array(8, dtype=int16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int16'>
_ TestArrayIndexingParameterized_param_14_{indexes=(slice(None, None, None), None), shape=(2,), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[1],
       [2]], dtype=int16)
y = array([[1],
       [2]], dtype=int16), err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 16254
E       Max relative difference: 8127.
E        x: array([[    0],
E              [16256]], dtype=int16)
E        y: array([[1],
E              [2]], dtype=int16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int16'>
_ TestArrayIndexingParameterized_param_18_{indexes=(slice(-9, -10, -1),), shape=(10,), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([2.], dtype=float16), y = array([2.], dtype=float16), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 2.
E       Max relative difference: 1.
E        x: array([0.], dtype=float16)
E        y: array([2.], dtype=float16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float16'>
_ TestArrayIndexingParameterized_param_27_{indexes=(slice(-4, -5, -1),), shape=(10,), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([7.], dtype=float32), y = array([7.], dtype=float32), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 7.
E       Max relative difference: 1.
E        x: array([0.], dtype=float32)
E        y: array([7.], dtype=float32)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float32'>
_ TestArrayIndexingParameterized_param_38_{indexes=(slice(-5, -6, -1),), shape=(10,), transpose=None}.test_getitem _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([6.], dtype=float16), y = array([6.], dtype=float16), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 6.
E       Max relative difference: 1.
E        x: array([0.], dtype=float16)
E        y: array([6.], dtype=float16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float16'>
____________________ TestArrayBoolOp.test_bool_one_element _____________________

self = <cupy_tests.core_tests.test_ndarray_unary_op.TestArrayBoolOp testMethod=test_bool_one_element>
dtype = <class 'numpy.int16'>

    @testing.for_all_dtypes()
    def test_bool_one_element(self, dtype):
>       assert bool(cupy.array([1], dtype=dtype))
E       AssertionError: assert False
E        +  where False = bool(array([1], dtype=int16))
E        +    where array([1], dtype=int16) = <function array at 0x7f291c3d9670>([1], dtype=<class 'numpy.int16'>)
E        +      where <function array at 0x7f291c3d9670> = cupy.array

tests/cupy_tests/core_tests/test_ndarray_unary_op.py:34: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int16'>
_ TestFusionArrayOperator_param_30_{func=<lambda>, left_value='array', name='eq', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_30_{func=<lambda>, left_value='array', n...arameter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.uint64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...rameter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=uint64))
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=uint64))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b77c66310>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.uint64'>}
_ TestFusionArrayOperator_param_31_{func=<lambda>, left_value='array', name='eq', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_31_{func=<lambda>, left_value='array', n...rameter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f20918435e0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_32_{func=<lambda>, left_value='array', name='eq', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_32_{func=<lambda>, left_value='array', n...eter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float64'>, 'dtype2': <class 'numpy.int8'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.74406752, 3.57594683, 3.01381688, 2.72441591],
       [2.118274  , 3.22947057, 2.18793606, 4.458865  ],
       [4.8183138 , 1.91720759, 3.95862519, 2.6444746 ]]), 3)
kwargs_np = {}
args_cp = (array([[2.74406752, 3.57594683, 3.01381688, 2.72441591],
       [2.118274  , 3.22947057, 2.18793606, 4.458865  ],
       [4.8183138 , 1.91720759, 3.95862519, 2.6444746 ]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f209187e700>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float64'>, 'dtype2': <class 'numpy.int8'>}
_ TestFusionArrayOperator_param_33_{func=<lambda>, left_value='scalar', name='eq', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_33_{func=<lambda>, left_value='scalar', ...rameter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b6f12d910>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_34_{func=<lambda>, left_value='primitive', name='eq', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_34_{func=<lambda>, left_value='primitive...eter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.uint32'>, 'dtype2': <class 'numpy.longlong'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'eq', 'func': <function <lambda> at 0x7f28e5b6aa60>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int64))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int64))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783edd90>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint32'>, 'dtype2': <class 'numpy.longlong'>}
_ TestFusionArrayOperator_param_35_{func=<lambda>, left_value='array', name='ne', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_35_{func=<lambda>, left_value='array', n...arameter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...rameter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783e0a00>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_36_{func=<lambda>, left_value='array', name='ne', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_36_{func=<lambda>, left_value='array', n...rameter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783fb820>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_37_{func=<lambda>, left_value='array', name='ne', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_37_{func=<lambda>, left_value='array', n...eter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b6f12d340>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_38_{func=<lambda>, left_value='scalar', name='ne', right_value='array'}.test_operator _

>   return cp_ufunc(*inputs, **kwargs)

cupy/core/core.pyx:1466: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   kern = self._get_ufunc_kernel(dev_id, op, arginfos)

cupy/core/_kernel.pyx:1103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   kern = _get_ufunc_kernel(

cupy/core/_kernel.pyx:1126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return _get_simple_elementwise_kernel(

cupy/core/_kernel.pyx:900: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   module = compile_with_cache(module_code, options)

cupy/core/_kernel.pyx:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return cuda.compile_with_cache(

cupy/core/core.pyx:2019: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '#include <cupy/complex.cuh>\n#include <cupy/carray.cuh>\n#include <cupy/atomics.cuh>\n#include <cupy/math_constants.h...n1(_raw_in1[_ind.get()]);\nout0_type &out0 = _raw_out0[_ind.get()];\nout0 = in0 != in1;\n      }\n      ;\n    }\n    '
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include')
arch = None, cache_dir = None
extra_source = '/*  Copyright 2008-2013 NVIDIA Corporation\n *  Copyright 2013 Filipe RNC Maia\n *\n *  Licensed under the Apache Lic...)\n#define CUDART_NAN              __longlong_as_double(0xfff8000000000000ULL)\n\n\n#endif  // CUPY_MATH_CONSTANTS_H\n'
backend = 'hiprtc'

    def compile_with_cache(
            source, options=(), arch=None, cache_dir=None, extra_source=None,
            backend='nvrtc', *, enable_cooperative_groups=False,
            name_expressions=None, log_stream=None, jitify=False):
    
        if enable_cooperative_groups:
            if runtime.is_hip:
                raise ValueError(
                    'Cooperative groups is not supported in HIP.')
    
        if name_expressions is not None and backend != 'nvrtc':
            raise NotImplementedError
    
        # We silently ignore CUPY_CACHE_IN_MEMORY if nvcc/hipcc are in use, because
        # they must dump files to disk.
        cache_in_memory = (
            _get_bool_env_variable('CUPY_CACHE_IN_MEMORY', False)
            and backend == 'nvrtc')
    
        if runtime.is_hip:
            backend = 'hiprtc' if backend == 'nvrtc' else 'hipcc'
>           return _compile_with_cache_hip(
                source, options, arch, cache_dir, extra_source, backend,
                name_expressions, log_stream, cache_in_memory)

cupy/cuda/compiler.py:406: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '#include <hip/hip_runtime.h>\n#include <hip/hip_fp16.h>\n/*  Copyright 2008-2013 NVIDIA Corporation\n *  Copyright 20...n1(_raw_in1[_ind.get()]);\nout0_type &out0 = _raw_out0[_ind.get()];\nout0 = in0 != in1;\n      }\n      ;\n    }\n    '
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include')
arch = 'gfx906', cache_dir = '/home/kmaeh/.cupy/kernel_cache'
extra_source = '/*  Copyright 2008-2013 NVIDIA Corporation\n *  Copyright 2013 Filipe RNC Maia\n *\n *  Licensed under the Apache Lic...)\n#define CUDART_NAN              __longlong_as_double(0xfff8000000000000ULL)\n\n\n#endif  // CUPY_MATH_CONSTANTS_H\n'
backend = 'hiprtc', name_expressions = None, log_stream = None
cache_in_memory = False, use_converter = True

    def _compile_with_cache_hip(source, options, arch, cache_dir, extra_source,
                                backend='hiprtc', name_expressions=None,
                                log_stream=None, cache_in_memory=False,
                                use_converter=True):
        global _empty_file_preprocess_cache
    
        # TODO(leofang): this might be possible but is currently undocumented
        if _is_cudadevrt_needed(options):
            raise ValueError('separate compilation is not supported in HIP')
    
        if cache_dir is None:
            cache_dir = get_cache_dir()
        # TODO(leofang): it seems as of ROCm 3.5.0 hiprtc/hipcc can automatically
        # pick up the right arch without needing HCC_AMDGPU_TARGET. Check the
        # earliest ROCm version in which this happened.
        if arch is None:
            arch = os.environ.get('HCC_AMDGPU_TARGET')
            if arch is None:
                raise RuntimeError('HCC_AMDGPU_TARGET is not set')
        if use_converter:
            source = _convert_to_hip_source(source, extra_source,
                                            is_hiprtc=(backend == 'hiprtc'))
    
        env = (arch, options, _get_nvrtc_version(), backend)
        base = _empty_file_preprocess_cache.get(env, None)
        if base is None:
            # This is for checking HIPRTC/HIPCC compiler internal version
            if backend == 'hiprtc':
                base = _preprocess_hiprtc('', options)
            else:
                base = _preprocess_hipcc('', options)
            _empty_file_preprocess_cache[env] = base
    
        key_src = '%s %s %s %s' % (env, base, source, extra_source)
        key_src = key_src.encode('utf-8')
        name = '%s.hsaco' % hashlib.md5(key_src).hexdigest()
    
        mod = function.Module()
    
        if not cache_in_memory:
            # Read from disk cache
            if not os.path.isdir(cache_dir):
                os.makedirs(cache_dir, exist_ok=True)
    
            # To handle conflicts in concurrent situation, we adopt lock-free
            # method to avoid performance degradation.
            # We force recompiling to retrieve C++ mangled names if so desired.
            path = os.path.join(cache_dir, name)
            if os.path.exists(path) and not name_expressions:
                with open(path, 'rb') as f:
                    data = f.read()
                if len(data) >= 32:
                    hash_value = data[:32]
                    binary = data[32:]
                    binary_hash = hashlib.md5(binary).hexdigest().encode('ascii')
                    if hash_value == binary_hash:
                        mod.load(binary)
                        return mod
        else:
            # Enforce compiling -- the resulting kernel will be cached elsewhere,
            # so we do nothing
            pass
    
        if backend == 'hiprtc':
            # compile_using_nvrtc calls hiprtc for hip builds
            binary, mapping = compile_using_nvrtc(
                source, options, arch, name + '.cu', name_expressions,
                log_stream, cache_in_memory)
            mod._set_mapping(mapping)
        else:
            binary = compile_using_hipcc(source, options, arch, log_stream)
    
        if not cache_in_memory:
            # Write to disk cache
            binary_hash = hashlib.md5(binary).hexdigest().encode('ascii')
    
            # shutil.move is not atomic operation, so it could result in a
            # corrupted file. We detect it by appending md5 hash at the beginning
            # of each cache file. If the file is corrupted, it will be ignored
            # next time it is read.
            with tempfile.NamedTemporaryFile(dir=cache_dir, delete=False) as tf:
                tf.write(binary_hash)
                tf.write(binary)
>               temp_path = tf.name

cupy/cuda/compiler.py:805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783e3190>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError

The above exception was the direct cause of the following exception:

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_38_{func=<lambda>, left_value='scalar', ...rameter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
>       result_cp = call(impl_cp, args_cp, kwargs_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/testing/parameterized.py:67: in new_v
    return f(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = 3.0
y = array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32)

>   ???
E   DeprecationWarning: elementwise comparison failed; this will raise an error in the future.

tests/cupy_tests/core_tests/fusion_tests/test_array.py:41: DeprecationWarning
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_39_{func=<lambda>, left_value='primitive', name='ne', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_39_{func=<lambda>, left_value='primitive...eter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'ne', 'func': <function <lambda> at 0x7f28e5b6a430>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d17ca30>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_40_{func=<lambda>, left_value='array', name='lt', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_40_{func=<lambda>, left_value='array', n...arameter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...rameter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cfb16d0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_41_{func=<lambda>, left_value='array', name='lt', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_41_{func=<lambda>, left_value='array', n...rameter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091868190>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_42_{func=<lambda>, left_value='array', name='lt', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_42_{func=<lambda>, left_value='array', n...eter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091871790>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_43_{func=<lambda>, left_value='scalar', name='lt', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_43_{func=<lambda>, left_value='scalar', ...rameter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
>       result_cp = call(impl_cp, args_cp, kwargs_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/testing/parameterized.py:67: in new_v
    return f(*args, **kwargs)
tests/cupy_tests/core_tests/fusion_tests/test_array.py:42: in <lambda>
    ???
cupy/core/core.pyx:1466: in cupy.core.core.ndarray.__array_ufunc__
    return cp_ufunc(*inputs, **kwargs)
cupy/core/_kernel.pyx:1103: in cupy.core._kernel.ufunc.__call__
    kern = self._get_ufunc_kernel(dev_id, op, arginfos)
cupy/core/_kernel.pyx:1126: in cupy.core._kernel.ufunc._get_ufunc_kernel
    kern = _get_ufunc_kernel(
cupy/core/_kernel.pyx:900: in cupy.core._kernel._get_ufunc_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f20919e2be0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_44_{func=<lambda>, left_value='primitive', name='lt', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_44_{func=<lambda>, left_value='primitive...eter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'lt', 'func': <function <lambda> at 0x7f28e5b6a4c0>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783daa60>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_45_{func=<lambda>, left_value='array', name='le', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_45_{func=<lambda>, left_value='array', n...arameter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...rameter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091868eb0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_46_{func=<lambda>, left_value='array', name='le', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_46_{func=<lambda>, left_value='array', n...rameter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cfb1c40>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_47_{func=<lambda>, left_value='array', name='le', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_47_{func=<lambda>, left_value='array', n...eter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091b33670>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_48_{func=<lambda>, left_value='scalar', name='le', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_48_{func=<lambda>, left_value='scalar', ...rameter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
>       result_cp = call(impl_cp, args_cp, kwargs_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/testing/parameterized.py:67: in new_v
    return f(*args, **kwargs)
tests/cupy_tests/core_tests/fusion_tests/test_array.py:43: in <lambda>
    ???
cupy/core/core.pyx:1466: in cupy.core.core.ndarray.__array_ufunc__
    return cp_ufunc(*inputs, **kwargs)
cupy/core/_kernel.pyx:1103: in cupy.core._kernel.ufunc.__call__
    kern = self._get_ufunc_kernel(dev_id, op, arginfos)
cupy/core/_kernel.pyx:1126: in cupy.core._kernel.ufunc._get_ufunc_kernel
    kern = _get_ufunc_kernel(
cupy/core/_kernel.pyx:900: in cupy.core._kernel._get_ufunc_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f28e5eaaf40>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_49_{func=<lambda>, left_value='primitive', name='le', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_49_{func=<lambda>, left_value='primitive...eter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'le', 'func': <function <lambda> at 0x7f28e5b6aaf0>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783d88e0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_50_{func=<lambda>, left_value='array', name='gt', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_50_{func=<lambda>, left_value='array', n...arameter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...rameter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f20abfe9f10>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_51_{func=<lambda>, left_value='array', name='gt', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_51_{func=<lambda>, left_value='array', n...rameter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b77c53610>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_52_{func=<lambda>, left_value='array', name='gt', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_52_{func=<lambda>, left_value='array', n...eter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f20919e2af0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_53_{func=<lambda>, left_value='scalar', name='gt', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_53_{func=<lambda>, left_value='scalar', ...rameter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
>       result_cp = call(impl_cp, args_cp, kwargs_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/testing/parameterized.py:67: in new_v
    return f(*args, **kwargs)
tests/cupy_tests/core_tests/fusion_tests/test_array.py:44: in <lambda>
    ???
cupy/core/core.pyx:1466: in cupy.core.core.ndarray.__array_ufunc__
    return cp_ufunc(*inputs, **kwargs)
cupy/core/_kernel.pyx:1103: in cupy.core._kernel.ufunc.__call__
    kern = self._get_ufunc_kernel(dev_id, op, arginfos)
cupy/core/_kernel.pyx:1126: in cupy.core._kernel.ufunc._get_ufunc_kernel
    kern = _get_ufunc_kernel(
cupy/core/_kernel.pyx:900: in cupy.core._kernel._get_ufunc_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d0cdb50>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_54_{func=<lambda>, left_value='primitive', name='gt', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_54_{func=<lambda>, left_value='primitive...eter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'gt', 'func': <function <lambda> at 0x7f28e5b6ab80>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783e3f10>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_55_{func=<lambda>, left_value='array', name='ge', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_55_{func=<lambda>, left_value='array', n...arameter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...rameter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783fb430>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_56_{func=<lambda>, left_value='array', name='ge', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_56_{func=<lambda>, left_value='array', n...rameter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091871250>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_57_{func=<lambda>, left_value='array', name='ge', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_57_{func=<lambda>, left_value='array', n...eter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf62c10>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_58_{func=<lambda>, left_value='scalar', name='ge', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_58_{func=<lambda>, left_value='scalar', ...rameter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ameter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
>       result_cp = call(impl_cp, args_cp, kwargs_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/testing/parameterized.py:67: in new_v
    return f(*args, **kwargs)
tests/cupy_tests/core_tests/fusion_tests/test_array.py:45: in <lambda>
    ???
cupy/core/core.pyx:1466: in cupy.core.core.ndarray.__array_ufunc__
    return cp_ufunc(*inputs, **kwargs)
cupy/core/_kernel.pyx:1103: in cupy.core._kernel.ufunc.__call__
    kern = self._get_ufunc_kernel(dev_id, op, arginfos)
cupy/core/_kernel.pyx:1126: in cupy.core._kernel.ufunc._get_ufunc_kernel
    kern = _get_ufunc_kernel(
cupy/core/_kernel.pyx:900: in cupy.core._kernel._get_ufunc_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d00b220>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayOperator_param_59_{func=<lambda>, left_value='primitive', name='ge', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOperator_param_59_{func=<lambda>, left_value='primitive...eter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayOp...ter: {'name': 'ge', 'func': <function <lambda> at 0x7f28e5b6ac10>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cfa19a0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayBitwiseOperator_param_0_{func=<lambda>, left_value='array', name='lshift', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_0_{func=<lambda>, left_value='arr...eter: {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...ter: {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d0a64c0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_1_{func=<lambda>, left_value='array', name='lshift', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_1_{func=<lambda>, left_value='arr...ter: {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf99850>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_2_{func=<lambda>, left_value='array', name='lshift', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_2_{func=<lambda>, left_value='arr...: {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi... {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf862b0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_3_{func=<lambda>, left_value='scalar', name='lshift', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_3_{func=<lambda>, left_value='sca...ter: {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2093ab1190>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_4_{func=<lambda>, left_value='primitive', name='lshift', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_4_{func=<lambda>, left_value='pri...: {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi... {'name': 'lshift', 'func': <function <lambda> at 0x7f28e5b6aca0>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b78167880>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_5_{func=<lambda>, left_value='array', name='rshift', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_5_{func=<lambda>, left_value='arr...eter: {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...ter: {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f20918b2c10>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_6_{func=<lambda>, left_value='array', name='rshift', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_6_{func=<lambda>, left_value='arr...ter: {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:802: in _compile_with_cache_hip
    with tempfile.NamedTemporaryFile(dir=cache_dir, delete=False) as tf:
/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:540: in NamedTemporaryFile
    (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags, output_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = '/home/kmaeh/.cupy/kernel_cache', pre = 'tmp', suf = '', flags = 131266
output_type = <class 'str'>

    def _mkstemp_inner(dir, pre, suf, flags, output_type):
        """Code common to mkstemp, TemporaryFile, and NamedTemporaryFile."""
    
        names = _get_candidate_names()
        if output_type is bytes:
            names = map(_os.fsencode, names)
    
        for seq in range(TMP_MAX):
            name = next(names)
            file = _os.path.join(dir, pre + name + suf)
            _sys.audit("tempfile.mkstemp", file)
            try:
>               fd = _os.open(file, flags, 0o600)
E               OSError: [Errno 28] No space left on device: '/home/kmaeh/.cupy/kernel_cache/tmpimm3_sjl'

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:250: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_7_{func=<lambda>, left_value='array', name='rshift', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_7_{func=<lambda>, left_value='arr...: {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi... {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d0bebb0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_8_{func=<lambda>, left_value='scalar', name='rshift', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_8_{func=<lambda>, left_value='sca...ter: {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d00b1f0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_9_{func=<lambda>, left_value='primitive', name='rshift', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_9_{func=<lambda>, left_value='pri...: {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi... {'name': 'rshift', 'func': <function <lambda> at 0x7f28e5b6adc0>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b7814ddc0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_10_{func=<lambda>, left_value='array', name='and', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_10_{func=<lambda>, left_value='ar...rameter: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...ameter: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d00c490>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_11_{func=<lambda>, left_value='array', name='and', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_11_{func=<lambda>, left_value='ar...ameter: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...meter: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d051d60>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_12_{func=<lambda>, left_value='array', name='and', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_12_{func=<lambda>, left_value='ar...ter: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b78150850>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_13_{func=<lambda>, left_value='scalar', name='and', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_13_{func=<lambda>, left_value='sc...ameter: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...meter: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce60970>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_14_{func=<lambda>, left_value='primitive', name='and', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_14_{func=<lambda>, left_value='pr...ter: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'and', 'func': <function <lambda> at 0x7f28e5b6ad30>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783da040>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_15_{func=<lambda>, left_value='array', name='or', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_15_{func=<lambda>, left_value='ar...arameter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...rameter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf86b50>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_16_{func=<lambda>, left_value='array', name='or', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_16_{func=<lambda>, left_value='ar...rameter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...ameter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cecf160>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_17_{func=<lambda>, left_value='array', name='or', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_17_{func=<lambda>, left_value='ar...eter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...ter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d059490>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_18_{func=<lambda>, left_value='scalar', name='or', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_18_{func=<lambda>, left_value='sc...rameter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...ameter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d06bf40>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_19_{func=<lambda>, left_value='primitive', name='or', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_19_{func=<lambda>, left_value='pr...eter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...ter: {'name': 'or', 'func': <function <lambda> at 0x7f28e5b3d670>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce57220>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_20_{func=<lambda>, left_value='array', name='xor', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_20_{func=<lambda>, left_value='ar...rameter: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...ameter: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce6ad00>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_21_{func=<lambda>, left_value='array', name='xor', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_21_{func=<lambda>, left_value='ar...ameter: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...meter: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091865d00>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_22_{func=<lambda>, left_value='array', name='xor', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_22_{func=<lambda>, left_value='ar...ter: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091845160>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_23_{func=<lambda>, left_value='scalar', name='xor', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_23_{func=<lambda>, left_value='sc...ameter: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...meter: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf08370>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_24_{func=<lambda>, left_value='primitive', name='xor', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_24_{func=<lambda>, left_value='pr...ter: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'xor', 'func': <function <lambda> at 0x7f28e5b3d550>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d0638e0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_25_{func=<lambda>, left_value='array', name='invert', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_25_{func=<lambda>, left_value='ar...eter: {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...ter: {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f28e5f68e20>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_26_{func=<lambda>, left_value='array', name='invert', right_value='scalar'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_26_{func=<lambda>, left_value='ar...ter: {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d051fa0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_27_{func=<lambda>, left_value='array', name='invert', right_value='primitive'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_27_{func=<lambda>, left_value='ar...: {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi... {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 4],
       [4, 1, 3, 2]]), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce4bcd0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_28_{func=<lambda>, left_value='scalar', name='invert', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_28_{func=<lambda>, left_value='sc...ter: {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi...er: {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b77c42520>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayBitwiseOperator_param_29_{func=<lambda>, left_value='primitive', name='invert', right_value='array'}.test_operator _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBitwiseOperator_param_29_{func=<lambda>, left_value='pr...: {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayBi... {'name': 'invert', 'func': <function <lambda> at 0x7f28e5b3d1f0>, 'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_np = {}
args_cp = (3, array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f28e614a3a0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int64'>, 'dtype2': <class 'numpy.int64'>}
_ TestFusionArrayFloorDivide_param_0_{left_value='array', right_value='array'}.test_floor_divide _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFloorDivide_param_0_{left_value='array', right_value='array'} testMethod=test_floor_divide>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFl...rray', right_value='array'} testMethod=test_floor_divide>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8...130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce38e80>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayFloorDivide_param_1_{left_value='array', right_value='scalar'}.test_floor_divide _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFloorDivide_param_1_{left_value='array', right_value='scalar'} testMethod=test_floor_divide>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFl...ay', right_value='scalar'} testMethod=test_floor_divide>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf87b80>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayFloorDivide_param_2_{left_value='array', right_value='primitive'}.test_floor_divide _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFloorDivide_param_2_{left_value='array', right_value='primitive'} testMethod=test_floor_divide>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFl...ight_value='primitive'} testMethod=test_floor_divide>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_np = {}
args_cp = (array([[2.7440674, 3.5759468, 3.0138168, 2.724416 ],
       [2.118274 , 3.2294705, 2.187936 , 4.458865 ],
       [4.8183136, 1.9172076, 3.958625 , 2.6444745]], dtype=float32), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cea6a00>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayFloorDivide_param_3_{left_value='scalar', right_value='array'}.test_floor_divide _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFloorDivide_param_3_{left_value='scalar', right_value='array'} testMethod=test_floor_divide>  parameter: {'left_value': 'scalar', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFl...lar', right_value='array'} testMethod=test_floor_divide>  parameter: {'left_value': 'scalar', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d017c70>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayFloorDivide_param_4_{left_value='primitive', right_value='array'}.test_floor_divide _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFloorDivide_param_4_{left_value='primitive', right_value='array'} testMethod=test_floor_divide>  parameter: {'left_value': 'primitive', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method FusionArrayTestBase.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayFl...', right_value='array'} testMethod=test_floor_divide>  parameter: {'left_value': 'primitive', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_np = {}
args_cp = (3.0, array([[2.0851099e+00, 3.6016226e+00, 5.7187409e-04, 1.5116628e+00],
       [7.3377943e-01, 4.6169296e-01, 9.3130106e-01, 1.7278036e+00],
       [1.9838374e+00, 2.6940837e+00, 2.0959725e+00, 3.4260974e+00]],
      dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d5e4c0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_iadd _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_iadd>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...value='array', right_value='array'} testMethod=test_iadd>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[4.82917754, 7.1775693 , 3.01438875, 4.23607878],
       [2.85205345, 3.69116354, 3.11923711, 6.18666864],
   ...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_np = {}
args_cp = (array([[4.82917754, 7.1775693 , 3.01438875, 4.23607878],
       [2.85205345, 3.69116354, 3.11923711, 6.18666864],
   ...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d017e50>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_iand _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_iand>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...value='array', right_value='array'} testMethod=test_iand>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 1, 0],
       [0, 1, 0, 0],
       [0, 0, 2, 2]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_np = {}
args_cp = (array([[2, 3, 1, 0],
       [0, 1, 0, 0],
       [0, 0, 2, 2]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cde4280>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_ilshift _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_ilshift>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...ue='array', right_value='array'} testMethod=test_ilshift>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[ 8, 24,  6,  4],
       [ 4,  6,  4,  8],
       [ 8,  4, 12, 16]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_np = {}
args_cp = (array([[ 8, 24,  6,  4],
       [ 4,  6,  4,  8],
       [ 8,  4, 12, 16]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783daf40>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_imod _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_imod>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...value='array', right_value='array'} testMethod=test_imod>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 1, 1, 2]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_np = {}
args_cp = (array([[0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 1, 1, 2]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091871940>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_imul _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_imul>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...value='array', right_value='array'} testMethod=test_imul>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.72168269e+00, 1.28792105e+01, 1.72352378e-03, 4.11839836e+00],
       [1.55434594e+00, 1.49102387e+00, 2.03...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_np = {}
args_cp = (array([[5.72168269e+00, 1.28792105e+01, 1.72352378e-03, 4.11839836e+00],
       [1.55434594e+00, 1.49102387e+00, 2.03...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce57f70>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_ior _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_ior>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu..._value='array', right_value='array'} testMethod=test_ior>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 3],
       [3, 3, 3, 5],
       [5, 3, 3, 3]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_np = {}
args_cp = (array([[2, 3, 3, 3],
       [3, 3, 3, 5],
       [5, 3, 3, 3]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b77c640d0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_ipow _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_ipow>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...value='array', right_value='array'} testMethod=test_ipow>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[ 8.20543062, 98.42505123,  1.00063109,  4.54974071],
       [ 1.73459861,  1.71815507,  2.07335948, 13.235249...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_np = {}
args_cp = (array([[ 8.20543062, 98.42505123,  1.00063109,  4.54974071],
       [ 1.73459861,  1.71815507,  2.07335948, 13.235249...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783e0a00>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_irshift _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_irshift>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...ue='array', right_value='array'} testMethod=test_irshift>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[0, 0, 1, 1],
       [1, 1, 1, 2],
       [2, 0, 0, 0]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_np = {}
args_cp = (array([[0, 0, 1, 1],
       [1, 1, 1, 2],
       [2, 0, 0, 0]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d0cb4c0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_isub _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_isub>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...value='array', right_value='array'} testMethod=test_isub>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[ 0.6589575 , -0.02567564,  3.01324501,  1.21275305],
       [ 1.38449454,  2.76777759,  1.256635  ,  2.731061...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_np = {}
args_cp = (array([[ 0.6589575 , -0.02567564,  3.01324501,  1.21275305],
       [ 1.38449454,  2.76777759,  1.256635  ,  2.731061...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b6f12d1f0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_itruediv_py3 _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_itruediv_py3>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...rray', right_value='array'} testMethod=test_itruediv_py3>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[1.31603008e+00, 9.92871092e-01, 5.27007072e+03, 1.80226424e+00],
       [2.88679928e+00, 6.99484451e+00, 2.34...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_np = {}
args_cp = (array([[1.31603008e+00, 9.92871092e-01, 5.27007072e+03, 1.80226424e+00],
       [2.88679928e+00, 6.99484451e+00, 2.34...692974e-01, 9.31301057e-01, 1.72780364e+00],
       [1.98383737e+00, 2.69408367e+00, 2.09597257e+00, 3.42609750e+00]]))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f20ab1b9040>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}.test_ixor _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'} testMethod=test_ixor>  parameter: {'left_value': 'array', 'right_value': 'array'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...value='array', right_value='array'} testMethod=test_ixor>  parameter: {'left_value': 'array', 'right_value': 'array'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[0, 0, 2, 3],
       [3, 2, 3, 5],
       [5, 3, 1, 1]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_np = {}
args_cp = (array([[0, 0, 2, 3],
       [3, 2, 3, 5],
       [5, 3, 1, 1]], dtype=int8), array([[2, 3, 1, 1],
       [1, 1, 1, 1],
       [1, 2, 2, 3]], dtype=int8))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d06b760>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_iadd _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_iadd>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...lue='array', right_value='scalar'} testMethod=test_iadd>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.74406752, 6.57594683, 6.01381688, 5.72441591],
       [5.118274  , 6.22947057, 5.18793606, 7.458865  ],
       [7.8183138 , 4.91720759, 6.95862519, 5.6444746 ]]), 3.0)
kwargs_np = {}
args_cp = (array([[5.74406752, 6.57594683, 6.01381688, 5.72441591],
       [5.118274  , 6.22947057, 5.18793606, 7.458865  ],
       [7.8183138 , 4.91720759, 6.95862519, 5.6444746 ]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44cbc610>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_iand _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_iand>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...lue='array', right_value='scalar'} testMethod=test_iand>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 0],
       [0, 1, 3, 2]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 0],
       [0, 1, 3, 2]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce0a340>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_ilshift _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_ilshift>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...='array', right_value='scalar'} testMethod=test_ilshift>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[16, 24, 24, 16],
       [16, 24, 16, 32],
       [32,  8, 24, 16]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[16, 24, 24, 16],
       [16, 24, 16, 32],
       [32,  8, 24, 16]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d75d30>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_imod _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_imod>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...lue='array', right_value='scalar'} testMethod=test_imod>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 0, 0, 2],
       [2, 0, 2, 1],
       [1, 1, 0, 2]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[2, 0, 0, 2],
       [2, 0, 2, 1],
       [1, 1, 0, 2]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f20918718b0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_imul _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_imul>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...lue='array', right_value='scalar'} testMethod=test_imul>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[ 8.23220256, 10.7278405 ,  9.04145064,  8.17324774],
       [ 6.35482199,  9.6884117 ,  6.56380817, 13.37659501],
       [14.45494141,  5.75162278, 11.87587557,  7.9334238 ]]), 3.0)
kwargs_np = {}
args_cp = (array([[ 8.23220256, 10.7278405 ,  9.04145064,  8.17324774],
       [ 6.35482199,  9.6884117 ,  6.56380817, 13.37659501],
       [14.45494141,  5.75162278, 11.87587557,  7.9334238 ]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d5cf70>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_ior _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_ior>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...alue='array', right_value='scalar'} testMethod=test_ior>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[3, 3, 3, 3],
       [3, 3, 3, 7],
       [7, 3, 3, 3]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[3, 3, 3, 3],
       [3, 3, 3, 7],
       [7, 3, 3, 3]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d84670>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_ipow _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_ipow>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...lue='array', right_value='scalar'} testMethod=test_ipow>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[ 20.662572  ,  45.7270473 ,  27.37477656,  20.22181932],
       [  9.50487489,  33.6816991 ,  10.47379034,  88.64882257],
       [111.86268586,   7.04705112,  62.03448081,  18.49346115]]), 3.0)
kwargs_np = {}
args_cp = (array([[ 20.662572  ,  45.7270473 ,  27.37477656,  20.22181932],
       [  9.50487489,  33.6816991 ,  10.47379034,  88.64882257],
       [111.86268586,   7.04705112,  62.03448081,  18.49346115]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cea8c10>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_irshift _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_irshift>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...='array', right_value='scalar'} testMethod=test_irshift>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d8dd90>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_isub _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_isub>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...lue='array', right_value='scalar'} testMethod=test_isub>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[-0.25593248,  0.57594683,  0.01381688, -0.27558409],
       [-0.881726  ,  0.22947057, -0.81206394,  1.458865  ],
       [ 1.8183138 , -1.08279241,  0.95862519, -0.3555254 ]]), 3.0)
kwargs_np = {}
args_cp = (array([[-0.25593248,  0.57594683,  0.01381688, -0.27558409],
       [-0.881726  ,  0.22947057, -0.81206394,  1.458865  ],
       [ 1.8183138 , -1.08279241,  0.95862519, -0.3555254 ]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091874190>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_itruediv_py3 _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_itruediv_py3>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...ay', right_value='scalar'} testMethod=test_itruediv_py3>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[0.91468917, 1.19198228, 1.00460563, 0.90813864],
       [0.70609133, 1.07649019, 0.72931202, 1.48628833],
       [1.6061046 , 0.6390692 , 1.31954173, 0.88149153]]), 3.0)
kwargs_np = {}
args_cp = (array([[0.91468917, 1.19198228, 1.00460563, 0.90813864],
       [0.70609133, 1.07649019, 0.72931202, 1.48628833],
       [1.6061046 , 0.6390692 , 1.31954173, 0.88149153]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d84910>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}.test_ixor _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'} testMethod=test_ixor>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...lue='array', right_value='scalar'} testMethod=test_ixor>  parameter: {'left_value': 'array', 'right_value': 'scalar'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[1, 0, 0, 1],
       [1, 0, 1, 7],
       [7, 2, 0, 1]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[1, 0, 0, 1],
       [1, 0, 1, 7],
       [7, 2, 0, 1]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ceb88b0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_iadd _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_iadd>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...rray', right_value='primitive'} testMethod=test_iadd>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.74406752, 6.57594683, 6.01381688, 5.72441591],
       [5.118274  , 6.22947057, 5.18793606, 7.458865  ],
       [7.8183138 , 4.91720759, 6.95862519, 5.6444746 ]]), 3.0)
kwargs_np = {}
args_cp = (array([[5.74406752, 6.57594683, 6.01381688, 5.72441591],
       [5.118274  , 6.22947057, 5.18793606, 7.458865  ],
       [7.8183138 , 4.91720759, 6.95862519, 5.6444746 ]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ceca250>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_iand _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_iand>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...rray', right_value='primitive'} testMethod=test_iand>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 3, 3, 2],
       [2, 3, 2, 0],
       [0, 1, 3, 2]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[2, 3, 3, 2],
       [2, 3, 2, 0],
       [0, 1, 3, 2]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cdeb2b0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_ilshift _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_ilshift>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...y', right_value='primitive'} testMethod=test_ilshift>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[16, 24, 24, 16],
       [16, 24, 16, 32],
       [32,  8, 24, 16]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[16, 24, 24, 16],
       [16, 24, 16, 32],
       [32,  8, 24, 16]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44ce2730>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_imod _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_imod>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...rray', right_value='primitive'} testMethod=test_imod>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[2, 0, 0, 2],
       [2, 0, 2, 1],
       [1, 1, 0, 2]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[2, 0, 0, 2],
       [2, 0, 2, 1],
       [1, 1, 0, 2]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce8e850>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_imul _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_imul>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...rray', right_value='primitive'} testMethod=test_imul>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[ 8.23220256, 10.7278405 ,  9.04145064,  8.17324774],
       [ 6.35482199,  9.6884117 ,  6.56380817, 13.37659501],
       [14.45494141,  5.75162278, 11.87587557,  7.9334238 ]]), 3.0)
kwargs_np = {}
args_cp = (array([[ 8.23220256, 10.7278405 ,  9.04145064,  8.17324774],
       [ 6.35482199,  9.6884117 ,  6.56380817, 13.37659501],
       [14.45494141,  5.75162278, 11.87587557,  7.9334238 ]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf990d0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_ior _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_ior>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...array', right_value='primitive'} testMethod=test_ior>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[3, 3, 3, 3],
       [3, 3, 3, 7],
       [7, 3, 3, 3]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[3, 3, 3, 3],
       [3, 3, 3, 7],
       [7, 3, 3, 3]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ceb99a0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_ipow _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_ipow>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...rray', right_value='primitive'} testMethod=test_ipow>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[ 20.662572  ,  45.7270473 ,  27.37477656,  20.22181932],
       [  9.50487489,  33.6816991 ,  10.47379034,  88.64882257],
       [111.86268586,   7.04705112,  62.03448081,  18.49346115]]), 3.0)
kwargs_np = {}
args_cp = (array([[ 20.662572  ,  45.7270473 ,  27.37477656,  20.22181932],
       [  9.50487489,  33.6816991 ,  10.47379034,  88.64882257],
       [111.86268586,   7.04705112,  62.03448081,  18.49346115]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f28e76ce520>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_irshift _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_irshift>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...y', right_value='primitive'} testMethod=test_irshift>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d14be0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_isub _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_isub>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...rray', right_value='primitive'} testMethod=test_isub>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[-0.25593248,  0.57594683,  0.01381688, -0.27558409],
       [-0.881726  ,  0.22947057, -0.81206394,  1.458865  ],
       [ 1.8183138 , -1.08279241,  0.95862519, -0.3555254 ]]), 3.0)
kwargs_np = {}
args_cp = (array([[-0.25593248,  0.57594683,  0.01381688, -0.27558409],
       [-0.881726  ,  0.22947057, -0.81206394,  1.458865  ],
       [ 1.8183138 , -1.08279241,  0.95862519, -0.3555254 ]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cef6f70>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_itruediv_py3 _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_itruediv_py3>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...ight_value='primitive'} testMethod=test_itruediv_py3>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[0.91468917, 1.19198228, 1.00460563, 0.90813864],
       [0.70609133, 1.07649019, 0.72931202, 1.48628833],
       [1.6061046 , 0.6390692 , 1.31954173, 0.88149153]]), 3.0)
kwargs_np = {}
args_cp = (array([[0.91468917, 1.19198228, 1.00460563, 0.90813864],
       [0.70609133, 1.07649019, 0.72931202, 1.48628833],
       [1.6061046 , 0.6390692 , 1.31954173, 0.88149153]]), 3.0)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d5fac0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}.test_ixor _

self = <<cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'} testMethod=test_ixor>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>
generate_inputs_kwargs = {'dtype': <class 'numpy.int8'>}
generate_inputs = <bound method TestFusionArrayInplaceOperator.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_array.TestFu...rray', right_value='primitive'} testMethod=test_ixor>  parameter: {'left_value': 'array', 'right_value': 'primitive'}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[1, 0, 0, 1],
       [1, 0, 1, 7],
       [7, 2, 0, 1]], dtype=int8), 3)
kwargs_np = {}
args_cp = (array([[1, 0, 0, 1],
       [1, 0, 1, 7],
       [7, 2, 0, 1]], dtype=int8), 3)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf78160>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________________ TestFusionArraySetItem.test_setitem_ellipsis _________________

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArraySetItem testMethod=test_setitem_ellipsis>
generate_inputs_kwargs = {}
generate_inputs = <bound method TestFusionArraySetItem.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArraySetItem testMethod=test_setitem_ellipsis>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32), array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32))
kwargs_np = {}
args_cp = (array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32), array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cdfaee0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
________________ TestFusionArraySetItem.test_setitem_non_slice _________________

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArraySetItem testMethod=test_setitem_non_slice>
generate_inputs_kwargs = {}
generate_inputs = <bound method TestFusionArraySetItem.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArraySetItem testMethod=test_setitem_non_slice>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32), array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32))
kwargs_np = {}
args_cp = (array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32), array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d77b20>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
_______________________ TestFusionArrayMethods.test_all ________________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 2-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 2-dim array>

>   return lambda x: x.all()
E   AttributeError: '_FusionVarArray' object has no attribute 'all'

tests/cupy_tests/core_tests/fusion_tests/test_array.py:296: AttributeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_all>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayMethods.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_all>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_np = {}
args_cp = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091845be0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 600, in cupy.core._reduction._SimpleReductionKernel._get_function
    return _SimpleReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 613, in cupy.core._reduction._SimpleReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
_______________________ TestFusionArrayMethods.test_any ________________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 2-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 2-dim array>

>   return lambda x: x.any()
E   AttributeError: '_FusionVarArray' object has no attribute 'any'

tests/cupy_tests/core_tests/fusion_tests/test_array.py:301: AttributeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_any>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayMethods.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_any>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_np = {}
args_cp = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d16c70>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 600, in cupy.core._reduction._SimpleReductionKernel._get_function
    return _SimpleReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 613, in cupy.core._reduction._SimpleReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
_______________________ TestFusionArrayMethods.test_copy _______________________

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_copy>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayMethods.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_copy>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_np = {}
args_cp = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce14bb0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_______________________ TestFusionArrayMethods.test_max ________________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 2-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 2-dim array>

>   return lambda x: x.max()
E   AttributeError: '_FusionVarArray' object has no attribute 'max'

tests/cupy_tests/core_tests/fusion_tests/test_array.py:286: AttributeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_max>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayMethods.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_max>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_np = {}
args_cp = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d46a90>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_______________________ TestFusionArrayMethods.test_min ________________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 2-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 2-dim array>

>   return lambda x: x.min()
E   AttributeError: '_FusionVarArray' object has no attribute 'min'

tests/cupy_tests/core_tests/fusion_tests/test_array.py:291: AttributeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_min>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayMethods.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_min>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_np = {}
args_cp = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f28e7722d60>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_______________________ TestFusionArrayMethods.test_prod _______________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 2-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 2-dim array>

>   return lambda x: x.prod()
E   AttributeError: '_FusionVarArray' object has no attribute 'prod'

tests/cupy_tests/core_tests/fusion_tests/test_array.py:281: AttributeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_prod>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayMethods.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_prod>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_np = {}
args_cp = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44c60ee0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 600, in cupy.core._reduction._SimpleReductionKernel._get_function
    return _SimpleReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 613, in cupy.core._reduction._SimpleReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
_______________________ TestFusionArrayMethods.test_sum ________________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 2-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 2-dim array>

>   return lambda x: x.sum()
E   AttributeError: '_FusionVarArray' object has no attribute 'sum'

tests/cupy_tests/core_tests/fusion_tests/test_array.py:276: AttributeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_sum>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayMethods.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayMethods testMethod=test_sum>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_np = {}
args_cp = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783daf70>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
______________________ TestFusionArrayAsType.test_astype _______________________

self = <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayAsType testMethod=test_astype>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float64'>, 'dtype2': <class 'numpy.float64'>}
generate_inputs = <bound method TestFusionArrayAsType.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_array.TestFusionArrayAsType testMethod=test_astype>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_np = {}
args_cp = (array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce102b0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype2 is <class 'numpy.float64'>
dtype1 is <class 'numpy.float64'>
________ TestIndexing_param_0_{indices=1, shape=(2, 3, 4)}.test_getitem ________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_0_{indices=1, shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': 1}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_0_{indices=1, shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': 1}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d5f220>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_______ TestIndexing_param_1_{indices=-1, shape=(2, 3, 4)}.test_getitem ________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_1_{indices=-1, shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': -1}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_1_{indices=-1, shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': -1}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce440d0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
______ TestIndexing_param_2_{indices=(1,), shape=(2, 3, 4)}.test_getitem _______

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_2_{indices=(1,), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1,)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_2_{indices=(1,), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1,)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cdf3fd0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_____ TestIndexing_param_3_{indices=(1, 0), shape=(2, 3, 4)}.test_getitem ______

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_3_{indices=(1, 0), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1, 0)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_3_{indices=(1, 0), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1, 0)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce1c2b0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
____ TestIndexing_param_4_{indices=(1, 0, 2), shape=(2, 3, 4)}.test_getitem ____

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_4_{indices=(1, 0, 2), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1, 0, 2)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_4_{indices=(1, 0, 2), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1, 0, 2)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d7b700>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
___ TestIndexing_param_5_{indices=(-1, 0, -2), shape=(2, 3, 4)}.test_getitem ___

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_5_{indices=(-1, 0, -2), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (-1, 0, -2)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_5_{indices=(-1, 0, -2), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (-1, 0, -2)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44c96f10>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_6_{indices=slice(None, None, None), shape=(2, 3, 4)}.test_getitem _

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_6_{indices=slice(None, None, None), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': slice(None, None, None)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_6_...None), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': slice(None, None, None)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d77c40>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_7_{indices=slice(None, None, 1), shape=(2, 3, 4)}.test_getitem _

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_7_{indices=slice(None, None, 1), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': slice(None, None, 1)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_7_...None, 1), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': slice(None, None, 1)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44c7fc40>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_8_{indices=slice(None, None, -1), shape=(2, 3, 4)}.test_getitem _

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_8_{indices=slice(None, None, -1), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': slice(None, None, -1)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_8_...ne, -1), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': slice(None, None, -1)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44cd74c0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_9_{indices=(slice(None, None, None), slice(None, None, -1)), shape=(2, 3, 4)}.test_getitem _

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_9_{indices=(slice(None, None, None), slice(None,...testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (slice(None, None, None), slice(None, None, -1))}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_9_...estMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (slice(None, None, None), slice(None, None, -1))}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2091874d90>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
____ TestIndexing_param_10_{indices=Ellipsis, shape=(2, 3, 4)}.test_getitem ____

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_10_{indices=Ellipsis, shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': Ellipsis}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_10_{indices=Ellipsis, shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': Ellipsis}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d60550>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
__ TestIndexing_param_11_{indices=(Ellipsis,), shape=(2, 3, 4)}.test_getitem ___

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_11_{indices=(Ellipsis,), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (Ellipsis,)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_11...dices=(Ellipsis,), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (Ellipsis,)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44bd3700>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
______ TestIndexing_param_12_{indices=None, shape=(2, 3, 4)}.test_getitem ______

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_12_{indices=None, shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': None}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_12_{indices=None, shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': None}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44be7af0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
____ TestIndexing_param_13_{indices=(None,), shape=(2, 3, 4)}.test_getitem _____

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_13_{indices=(None,), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (None,)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_13_{indices=(None,), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (None,)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d16550>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_14_{indices=(None, None, None), shape=(2, 3, 4)}.test_getitem _

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_14_{indices=(None, None, None), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (None, None, None)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_14...one, None), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (None, None, None)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce9da60>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_15_{indices=(slice(None, None, None), 0, slice(None, None, -1)), shape=(2, 3, 4)}.test_getitem _

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_15_{indices=(slice(None, None, None), 0, slice(N...tMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (slice(None, None, None), 0, slice(None, None, -1))}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_15...Method=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (slice(None, None, None), 0, slice(None, None, -1))}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44bfa370>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_16_{indices=(1, None, slice(None, None, -1), None, 2), shape=(2, 3, 4)}.test_getitem _

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_16_{indices=(1, None, slice(None, None, -1), Non...3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1, None, slice(None, None, -1), None, 2)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_16..., 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1, None, slice(None, None, -1), None, 2)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d8b3d0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_17_{indices=(slice(None, None, None), None), shape=(2,)}.test_getitem _

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 1-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 1-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_17_{indices=(slice(None, None, None), None), shape=(2,)} testMethod=test_getitem>  parameter: {'shape': (2,), 'indices': (slice(None, None, None), None)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_17..., None), shape=(2,)} testMethod=test_getitem>  parameter: {'shape': (2,), 'indices': (slice(None, None, None), None)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([5.48813504, 7.15189366]),), kwargs_np = {}
args_cp = (array([5.48813504, 7.15189366]),), kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf08970>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_18_{indices=(Ellipsis, 2), shape=(2, 3, 4)}.test_getitem __

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_18_{indices=(Ellipsis, 2), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (Ellipsis, 2)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_18...s=(Ellipsis, 2), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (Ellipsis, 2)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44bf0790>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_19_{indices=(1, Ellipsis), shape=(2, 3, 4)}.test_getitem __

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 3-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 3-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_19_{indices=(1, Ellipsis), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1, Ellipsis)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_19...s=(1, Ellipsis), shape=(2, 3, 4)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4), 'indices': (1, Ellipsis)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_np = {}
args_cp = (array([[[5.48813504, 7.15189366, 6.02763376, 5.44883183],
        [4.23654799, 6.45894113, 4.37587211, 8.91773001],
 ...        [0.20218397, 8.32619846, 7.78156751, 8.70012148],
        [9.78618342, 7.99158564, 4.61479362, 7.80529176]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44b76be0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestIndexing_param_20_{indices=(1, Ellipsis, 3), shape=(2, 3, 4, 5)}.test_getitem _

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float64 4-dim array>,), kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float64 4-dim array>

>   return lambda x: x[self.indices]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:45: TypeError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_20_{indices=(1, Ellipsis, 3), shape=(2, 3, 4, 5)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4, 5), 'indices': (1, Ellipsis, 3)}>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method TestIndexing.generate_inputs of <<cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexing_param_20...is, 3), shape=(2, 3, 4, 5)} testMethod=test_getitem>  parameter: {'shape': (2, 3, 4, 5), 'indices': (1, Ellipsis, 3)}>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[[[5.48813504, 7.15189366, 6.02763376, 5.44883183, 4.23654799],
         [6.45894113, 4.37587211, 8.91773001, ...08672, 6.99479275, 2.97436951, 8.1379782 ],
         [3.96505741, 8.81103197, 5.81272873, 8.81735362, 6.9253159 ]]]]),)
kwargs_np = {}
args_cp = (array([[[[5.48813504, 7.15189366, 6.02763376, 5.44883183, 4.23654799],
         [6.45894113, 4.37587211, 8.91773001, ...08672, 6.99479275, 2.97436951, 8.1379782 ],
         [3.96505741, 8.81103197, 5.81272873, 8.81735362, 6.9253159 ]]]]),)
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44bcb250>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_______________ TestIndexingCombination.test_indexing_and_add_1 ________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float32 2-dim array>, <_FusionVar float32 1-dim array>, <_FusionVar float32 1-dim array>)
kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float32 2-dim array>, y = <_FusionVar float32 1-dim array>
z = <_FusionVar float32 1-dim array>

>   return lambda x, y, z: x + y[1]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:81: TypeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_and_add_1>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method TestIndexingCombination.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_and_add_1>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6...y([4.1702199e+00, 7.2032452e+00, 1.1437482e-03, 3.0233257e+00],
      dtype=float32), array([4.359949], dtype=float32))
kwargs_np = {}
args_cp = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6...y([4.1702199e+00, 7.2032452e+00, 1.1437482e-03, 3.0233257e+00],
      dtype=float32), array([4.359949], dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d09dd00>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_______________ TestIndexingCombination.test_indexing_and_add_2 ________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float32 2-dim array>, <_FusionVar float32 1-dim array>, <_FusionVar float32 1-dim array>)
kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float32 2-dim array>, y = <_FusionVar float32 1-dim array>
z = <_FusionVar float32 1-dim array>

>   return lambda x, y, z: x + z[0] + y
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:87: TypeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_and_add_2>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method TestIndexingCombination.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_and_add_2>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6...y([4.1702199e+00, 7.2032452e+00, 1.1437482e-03, 3.0233257e+00],
      dtype=float32), array([4.359949], dtype=float32))
kwargs_np = {}
args_cp = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6...y([4.1702199e+00, 7.2032452e+00, 1.1437482e-03, 3.0233257e+00],
      dtype=float32), array([4.359949], dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d240a0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
_______________ TestIndexingCombination.test_indexing_and_add_3 ________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar int32 2-dim array>, <_FusionVar uint32 1-dim array>, <_FusionVar int32 1-dim array>)
kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar int32 2-dim array>, y = <_FusionVar uint32 1-dim array>
z = <_FusionVar int32 1-dim array>

>   return lambda x, y, z: x + x[0] + x[1]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:93: TypeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_and_add_3>
generate_inputs_kwargs = {'dtype1': <class 'numpy.int32'>, 'dtype2': <class 'numpy.uint32'>}
generate_inputs = <bound method TestIndexingCombination.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_and_add_3>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32), array([4, 7, 0, 3], dtype=uint32), array([4], dtype=int32))
kwargs_np = {}
args_cp = (array([[5, 7, 6, 5],
       [4, 6, 4, 8],
       [9, 3, 7, 5]], dtype=int32), array([4, 7, 0, 3], dtype=uint32), array([4], dtype=int32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce6ab50>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.int32'>, 'dtype2': <class 'numpy.uint32'>}
_______________ TestIndexingCombination.test_indexing_and_add_4 ________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float32 2-dim array>, <_FusionVar float32 1-dim array>, <_FusionVar float32 1-dim array>)
kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float32 2-dim array>, y = <_FusionVar float32 1-dim array>
z = <_FusionVar float32 1-dim array>

>   return lambda x, y, z: x + x[0, 1] + x[1] + x + x[2, 1]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:99: TypeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_and_add_4>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method TestIndexingCombination.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_and_add_4>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6...y([4.1702199e+00, 7.2032452e+00, 1.1437482e-03, 3.0233257e+00],
      dtype=float32), array([4.359949], dtype=float32))
kwargs_np = {}
args_cp = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6...y([4.1702199e+00, 7.2032452e+00, 1.1437482e-03, 3.0233257e+00],
      dtype=float32), array([4.359949], dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4ce60e20>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
________________ TestIndexingCombination.test_indexing_twice_1 _________________

>   self._memo[key] = history.get_fusion(

cupy/core/fusion.pyx:918: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   return_value = func(*function_args)

cupy/core/fusion.pyx:759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<_FusionVar float32 2-dim array>, <_FusionVar float32 1-dim array>, <_FusionVar float32 1-dim array>)
kwargs = {}

    @cupy.fuse()
    def impl_fuse_cp(*args, **kwargs):
>       return impl_cp(*args, **kwargs)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = <_FusionVar float32 2-dim array>, y = <_FusionVar float32 1-dim array>
z = <_FusionVar float32 1-dim array>

>   return lambda x, y, z: x[0][1]
E   TypeError: '_FusionVarArray' object is not subscriptable

tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:105: TypeError

During handling of the above exception, another exception occurred:

self = <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_twice_1>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
generate_inputs = <bound method TestIndexingCombination.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_twice_1>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6...y([4.1702199e+00, 7.2032452e+00, 1.1437482e-03, 3.0233257e+00],
      dtype=float32), array([4.359949], dtype=float32))
kwargs_np = {}
args_cp = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6...y([4.1702199e+00, 7.2032452e+00, 1.1437482e-03, 3.0233257e+00],
      dtype=float32), array([4.359949], dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:924: in cupy.core.fusion.Fusion.__call__
    return self.new_fusion(*args)
cupy/core/new_fusion.pyx:163: in cupy.core.new_fusion.Fusion.__call__
    return kernel.execute(args, shapes)
cupy/core/_fusion_kernel.pyx:348: in cupy.core._fusion_kernel.FusedKernel.execute
    kern = _cuda_compile(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_fusion_kernel.pyx:52: in cupy.core._fusion_kernel._cuda_compile
    module = compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783e3730>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.float32'>}
________________ TestIndexingCombination.test_indexing_twice_2 _________________

self = <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_twice_2>
generate_inputs_kwargs = {'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.uint8'>}
generate_inputs = <bound method TestIndexingCombination.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_indexing.TestIndexingCombination testMethod=test_indexing_twice_2>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6... 3.8344152, 7.91725  , 5.288949 ]], dtype=float32), array([4, 7, 0, 3], dtype=uint8), array([4.359949], dtype=float32))
kwargs_np = {}
args_cp = (array([[5.488135 , 7.1518936, 6.0276337, 5.448832 ],
       [4.236548 , 6.458941 , 4.375872 , 8.91773  ],
       [9.6... 3.8344152, 7.91725  , 5.288949 ]], dtype=float32), array([4, 7, 0, 3], dtype=uint8), array([4.359949], dtype=float32))
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
>       result_cp = call(impl_cp, args_cp, kwargs_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
tests/cupy_tests/core_tests/fusion_tests/test_indexing.py:111: in <lambda>
    return lambda x, y, z: x[0][1] + x[1][0]
cupy/core/core.pyx:1067: in cupy.core.core.ndarray.__add__
    return _math._add(x, y)
cupy/core/_kernel.pyx:1103: in cupy.core._kernel.ufunc.__call__
    kern = self._get_ufunc_kernel(dev_id, op, arginfos)
cupy/core/_kernel.pyx:1126: in cupy.core._kernel.ufunc._get_ufunc_kernel
    kern = _get_ufunc_kernel(
cupy/core/_kernel.pyx:900: in cupy.core._kernel._get_ufunc_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d0e7940>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.float32'>, 'dtype2': <class 'numpy.uint8'>}
___________________ TestFusionCache.test_dtype_combinations ____________________

self = <cupy_tests.core_tests.fusion_tests.test_kernel_cache.TestFusionCache testMethod=test_dtype_combinations>

    def new_impl(self):
        target = 'cupy.core._fusion_trace.TraceImpl'
        with mock.patch(target, CreateMock(target)) as m:
            numpy_result = impl(self, numpy, m)
        with mock.patch(target, CreateMock(target)) as m:
>           cupy_result = impl(self, cupy, m)

tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py:76: in test_dtype_combinations
    result.append(f(x, y))
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cdfab50>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
________________ TestFusionCache.test_memoryspace_combinations _________________

self = <cupy_tests.core_tests.fusion_tests.test_kernel_cache.TestFusionCache testMethod=test_memoryspace_combinations>

    def new_impl(self):
        target = 'cupy.core._fusion_trace.TraceImpl'
        with mock.patch(target, CreateMock(target)) as m:
            numpy_result = impl(self, numpy, m)
        with mock.patch(target, CreateMock(target)) as m:
>           cupy_result = impl(self, cupy, m)

tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py:159: in test_memoryspace_combinations
    result.append(f(x, y))
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cfb1040>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
_______________________ TestFusionCache.test_same_array ________________________

self = <cupy_tests.core_tests.fusion_tests.test_kernel_cache.TestFusionCache testMethod=test_same_array>

    def new_impl(self):
        target = 'cupy.core._fusion_trace.TraceImpl'
        with mock.patch(target, CreateMock(target)) as m:
            numpy_result = impl(self, numpy, m)
        with mock.patch(target, CreateMock(target)) as m:
>           cupy_result = impl(self, cupy, m)

tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py:57: in test_same_array
    result.append(f(x, y))
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d84cd0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
___________________ TestFusionCache.test_shape_combinations ____________________

self = <cupy_tests.core_tests.fusion_tests.test_kernel_cache.TestFusionCache testMethod=test_shape_combinations>

    def new_impl(self):
        target = 'cupy.core._fusion_trace.TraceImpl'
        with mock.patch(target, CreateMock(target)) as m:
            numpy_result = impl(self, numpy, m)
        with mock.patch(target, CreateMock(target)) as m:
>           cupy_result = impl(self, cupy, m)

tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py:112: in test_shape_combinations
    result.append(f(x, y))
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cdf51f0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
_______________ TestFusionInplaceUpdate.test_iadd_multiple_times _______________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionInplaceUpdate testMethod=test_iadd_multiple_times>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionInplaceUpdate testMethod=test_iadd_multiple_times>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[17.99879518, 28.76162847,  6.03106501, 14.51880901],
       [ 8.63922472,  9.22909897,  9.96367845, 19.284551...385948e-01, 1.86260211e+00, 3.45560727e+00],
       [3.96767474e+00, 5.38816734e+00, 4.19194514e+00, 6.85219500e+00]])]
kwargs_np = {}
args_cp = [array([[17.99879518, 28.76162847,  6.03106501, 14.51880901],
       [ 8.63922472,  9.22909897,  9.96367845, 19.284551...385948e-01, 1.86260211e+00, 3.45560727e+00],
       [3.96767474e+00, 5.38816734e+00, 4.19194514e+00, 6.85219500e+00]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4d017130>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
__________________ TestFusionInplaceUpdate.test_outarg_mixed ___________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionInplaceUpdate testMethod=test_outarg_mixed>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionInplaceUpdate testMethod=test_outarg_mixed>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
   ...16572265,  47.68201601,  27.29876539, 110.34208114],
       [131.09959555,  35.36321052,  95.87153288,  64.21389488]])]
kwargs_np = {}
args_cp = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
   ...16572265,  47.68201601,  27.29876539, 110.34208114],
       [131.09959555,  35.36321052,  95.87153288,  64.21389488]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f20919dbb50>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
________ TestFusionTuple.test_multiple_outputdifferent_type_same_ufunc _________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_multiple_outputdifferent_type_same_ufunc>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_multiple_outputdifferent_type_same_ufunc>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
   ...3],
       [4.20367802, 3.30334821, 2.04648634, 6.19270966],
       [2.99654674, 2.66827275, 6.21133833, 5.29142094]])]
kwargs_np = {}
args_cp = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
   ...3],
       [4.20367802, 3.30334821, 2.04648634, 6.19270966],
       [2.99654674, 2.66827275, 6.21133833, 5.29142094]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
>       result_cp = call(impl_cp, args_cp, kwargs_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
tests/cupy_tests/core_tests/fusion_tests/test_misc.py:75: in func
    x = x.astype('int32')
cupy/core/core.pyx:394: in cupy.core.core.ndarray.astype
    cpdef ndarray astype(
cupy/core/core.pyx:465: in cupy.core.core.ndarray.astype
    elementwise_copy(self, newarray)
cupy/core/_kernel.pyx:1103: in cupy.core._kernel.ufunc.__call__
    kern = self._get_ufunc_kernel(dev_id, op, arginfos)
cupy/core/_kernel.pyx:1126: in cupy.core._kernel.ufunc._get_ufunc_kernel
    kern = _get_ufunc_kernel(
cupy/core/_kernel.pyx:900: in cupy.core._kernel._get_ufunc_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cdfb640>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
___________________ TestFusionTuple.test_return_empty_tuple ____________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_return_empty_tuple>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_return_empty_tuple>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]])]
kwargs_np = {}
args_cp = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cdfaee0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_________________ TestFusionTuple.test_return_singleton_tuple __________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_return_singleton_tuple>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_return_singleton_tuple>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]])]
kwargs_np = {}
args_cp = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44c4c730>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
______________________ TestFusionTuple.test_return_tuple _______________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_return_tuple>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_return_tuple>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
   ...3],
       [4.20367802, 3.30334821, 2.04648634, 6.19270966],
       [2.99654674, 2.66827275, 6.21133833, 5.29142094]])]
kwargs_np = {}
args_cp = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
   ...3],
       [4.20367802, 3.30334821, 2.04648634, 6.19270966],
       [2.99654674, 2.66827275, 6.21133833, 5.29142094]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44bd3790>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
__________________________ TestFusionTuple.test_tuple __________________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_tuple>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionTuple testMethod=test_tuple>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
   ...3],
       [4.20367802, 3.30334821, 2.04648634, 6.19270966],
       [2.99654674, 2.66827275, 6.21133833, 5.29142094]])]
kwargs_np = {}
args_cp = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
   ...3],
       [4.20367802, 3.30334821, 2.04648634, 6.19270966],
       [2.99654674, 2.66827275, 6.21133833, 5.29142094]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44b843a0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
________________________ TestReturnNone.test_iadd_once _________________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestReturnNone testMethod=test_iadd_once>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestReturnNone testMethod=test_iadd_once>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[ 7.48813504,  9.15189366,  8.02763376,  7.44883183],
       [ 6.23654799,  8.45894113,  6.37587211, 10.91773001],
       [11.63662761,  5.83441519,  9.91725038,  7.2889492 ]])]
kwargs_np = {}
args_cp = [array([[ 7.48813504,  9.15189366,  8.02763376,  7.44883183],
       [ 6.23654799,  8.45894113,  6.37587211, 10.91773001],
       [11.63662761,  5.83441519,  9.91725038,  7.2889492 ]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44cc0370>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
________________________ TestReturnNone.test_iadd_twice ________________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestReturnNone testMethod=test_iadd_twice>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestReturnNone testMethod=test_iadd_twice>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[21.95254016, 28.60757465, 24.11053504, 21.79532732],
       [16.94619197, 25.83576452, 17.50348845, 35.67092003],
       [38.54651042, 15.33766075, 31.66900152, 21.15579679]])]
kwargs_np = {}
args_cp = [array([[21.95254016, 28.60757465, 24.11053504, 21.79532732],
       [16.94619197, 25.83576452, 17.50348845, 35.67092003],
       [38.54651042, 15.33766075, 31.66900152, 21.15579679]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b783e09d0>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_______________ TestFusionNoneParams.test_python_none_parameter ________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionNoneParams testMethod=test_python_none_parameter>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_array_equal()
    def test_python_none_parameter(self, xp, dtype):
        @cupy.fuse()
        def f(x, y, z):
            if y is None:
                return x * z
            return x + y + z
    
        x = testing.shaped_arange((10,), xp, dtype)
        y = testing.shaped_arange((10,), xp, dtype)
        z = testing.shaped_arange((10,), xp, dtype)
>       return f(x, None, z) + f(x, y, z)

tests/cupy_tests/core_tests/fusion_tests/test_misc.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:802: in _compile_with_cache_hip
    with tempfile.NamedTemporaryFile(dir=cache_dir, delete=False) as tf:
/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:540: in NamedTemporaryFile
    (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags, output_type)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = '/home/kmaeh/.cupy/kernel_cache', pre = 'tmp', suf = '', flags = 131266
output_type = <class 'str'>

    def _mkstemp_inner(dir, pre, suf, flags, output_type):
        """Code common to mkstemp, TemporaryFile, and NamedTemporaryFile."""
    
        names = _get_candidate_names()
        if output_type is bytes:
            names = map(_os.fsencode, names)
    
        for seq in range(TMP_MAX):
            name = next(names)
            file = _os.path.join(dir, pre + name + suf)
            _sys.audit("tempfile.mkstemp", file)
            try:
>               fd = _os.open(file, flags, 0o600)
E               AssertionError: Only cupy raises error
E               
E               Traceback (most recent call last):
E                 File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E                   result = impl(self, *args, **kw)
E                 File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 153, in test_python_none_parameter
E                   return f(x, None, z) + f(x, y, z)
E                 File "cupy/core/fusion.pyx", line 930, in cupy.core.fusion.Fusion.__call__
E                   return kernel(
E                 File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
E                   kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
E                 File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
E                   kern = _get_elementwise_kernel(
E                 File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
E                   result = f(*args, **kwargs)
E                 File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
E                   return _get_simple_elementwise_kernel(
E                 File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
E                   cpdef function.Function _get_simple_elementwise_kernel(
E                 File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
E                   module = compile_with_cache(module_code, options)
E                 File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
E                   return cuda.compile_with_cache(
E                 File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
E                   return _compile_with_cache_hip(
E                 File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 802, in _compile_with_cache_hip
E                   with tempfile.NamedTemporaryFile(dir=cache_dir, delete=False) as tf:
E                 File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 540, in NamedTemporaryFile
E                   (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags, output_type)
E                 File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 250, in _mkstemp_inner
E                   fd = _os.open(file, flags, 0o600)
E               OSError: [Errno 28] No space left on device: '/home/kmaeh/.cupy/kernel_cache/tmpo44ji50t'

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:250: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
____________________ TestFusionKernelName.test_elementwise _____________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionKernelName testMethod=test_elementwise>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_elementwise(self, xp):
        def func(a, b, c):
            @cupy.fuse()
            def func_a1(x, y, z):
                return (x + y) * z
    
            return func_a1(a, b, c)
    
>       return self.check(xp, func, 'func_a1', True)

tests/cupy_tests/core_tests/fusion_tests/test_misc.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/test_misc.py:192: in check
    func(a, b, c)
tests/cupy_tests/core_tests/fusion_tests/test_misc.py:207: in func
    return func_a1(a, b, c)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d41f70>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       AssertionError: Only cupy raises error
E       
E       Traceback (most recent call last):
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E           result = impl(self, *args, **kw)
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 209, in test_elementwise
E           return self.check(xp, func, 'func_a1', True)
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 192, in check
E           func(a, b, c)
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 207, in func
E           return func_a1(a, b, c)
E         File "cupy/core/fusion.pyx", line 930, in cupy.core.fusion.Fusion.__call__
E           return kernel(
E         File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
E           kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
E         File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
E           kern = _get_elementwise_kernel(
E         File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
E           result = f(*args, **kwargs)
E         File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
E           return _get_simple_elementwise_kernel(
E         File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
E           cpdef function.Function _get_simple_elementwise_kernel(
E         File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
E           module = compile_with_cache(module_code, options)
E         File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
E           return cuda.compile_with_cache(
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
E           return _compile_with_cache_hip(
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
E           temp_path = tf.name
E         File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
E           result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: AssertionError
_______________ TestFusionKernelName.test_elementwise_with_name ________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionKernelName testMethod=test_elementwise_with_name>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_elementwise_with_name(self, xp):
        def func(a, b, c):
            @cupy.fuse(kernel_name='abc')
            def func_a1(x, y, z):
                return (x + y) * z
    
            return func_a1(a, b, c)
    
>       return self.check(xp, func, 'abc', True)

tests/cupy_tests/core_tests/fusion_tests/test_misc.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/test_misc.py:192: in check
    func(a, b, c)
tests/cupy_tests/core_tests/fusion_tests/test_misc.py:218: in func
    return func_a1(a, b, c)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cea6640>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       AssertionError: Only cupy raises error
E       
E       Traceback (most recent call last):
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E           result = impl(self, *args, **kw)
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 220, in test_elementwise_with_name
E           return self.check(xp, func, 'abc', True)
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 192, in check
E           func(a, b, c)
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 218, in func
E           return func_a1(a, b, c)
E         File "cupy/core/fusion.pyx", line 930, in cupy.core.fusion.Fusion.__call__
E           return kernel(
E         File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
E           kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
E         File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
E           kern = _get_elementwise_kernel(
E         File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
E           result = f(*args, **kwargs)
E         File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
E           return _get_simple_elementwise_kernel(
E         File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
E           cpdef function.Function _get_simple_elementwise_kernel(
E         File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
E           module = compile_with_cache(module_code, options)
E         File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
E           return cuda.compile_with_cache(
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
E           return _compile_with_cache_hip(
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
E           temp_path = tf.name
E         File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
E           result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: AssertionError
____________________ TestFusionKernelName.test_reduction_01 ____________________
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([2.74406752, 3.57594683, 3.01381688])
desired = array([  8800.22357671,  39273.84288556, 111762.34757287])
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 3 (100%)
E       Max absolute difference: 111759.33375599
E       Max relative difference: 0.99997303
E        x: array([2.744068, 3.575947, 3.013817])
E        y: array([  8800.223577,  39273.842886, 111762.347573])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 767, in cupy.core._reduction.ReductionKernel._get_function
    return _ReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 795, in cupy.core._reduction._ReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 767, in cupy.core._reduction.ReductionKernel._get_function
    return _ReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 795, in cupy.core._reduction._ReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
_________________ TestFusionKernelName.test_reduction_postmap __________________
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array(0.), desired = 8.717797887081348, rtol = 1e-07, atol = 1e-05
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 8.71779789
E       Max relative difference: 1.
E        x: array(0.)
E        y: array(8.717798)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 767, in cupy.core._reduction.ReductionKernel._get_function
    return _ReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 795, in cupy.core._reduction._ReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 767, in cupy.core._reduction.ReductionKernel._get_function
    return _ReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 795, in cupy.core._reduction._ReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
__________________ TestFusionKernelName.test_reduction_premap __________________
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array(2.31030901e-289), desired = 3838.0, rtol = 1e-07, atol = 1e-05
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 3838.
E       Max relative difference: 1.
E        x: array(2.310309e-289)
E        y: array(3838.)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 767, in cupy.core._reduction.ReductionKernel._get_function
    return _ReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 795, in cupy.core._reduction._ReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 767, in cupy.core._reduction.ReductionKernel._get_function
    return _ReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 795, in cupy.core._reduction._ReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
________________ TestFusionKernelName.test_reduction_with_name _________________
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array(-0.25593248), desired = 3838.0, rtol = 1e-07, atol = 1e-05
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 3838.25593248
E       Max relative difference: 1.00006668
E        x: array(-0.255932)
E        y: array(3838.)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 767, in cupy.core._reduction.ReductionKernel._get_function
    return _ReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 795, in cupy.core._reduction._ReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
Traceback (most recent call last):
  File "cupy/core/_reduction.pyx", line 767, in cupy.core._reduction.ReductionKernel._get_function
    return _ReductionKernel_get_cached_function(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_reduction.pyx", line 795, in cupy.core._reduction._ReductionKernel_get_cached_function
    return _create_reduction_function(
  File "cupy/core/_reduction.pyx", line 122, in cupy.core._reduction._create_reduction_function
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
    temp_path = tf.name
  File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
    result = self.file.__exit__(exc, value, tb)
OSError: [Errno 28] No space left on device
____________________ TestFusionComposition.test_composition ____________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionComposition testMethod=test_composition>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_bool=True)
    @testing.numpy_cupy_array_equal()
    def test_composition(self, xp, dtype):
        @cupy.fuse()
        def f(x, y):
            return x - y * 2, x + y
    
        @cupy.fuse()
        def g(x, y, z):
            a, b = f(x + z, z - x * 3)
            c, d = f(x - y, y - z)
            return a + b * c - d
    
        @cupy.fuse()
        def h(x, y):
            a, b = f(x + y * 2, y * 3)
            return a - b * g(x - 2, x - 3, -y)
    
        x = testing.shaped_arange((3, 3), xp, dtype)
        y = testing.shaped_arange((3, 3), xp, dtype)
>       return h(x, y)

tests/cupy_tests/core_tests/fusion_tests/test_misc.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d86430>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       AssertionError: Only cupy raises error
E       
E       Traceback (most recent call last):
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E           result = impl(self, *args, **kw)
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 289, in test_composition
E           return h(x, y)
E         File "cupy/core/fusion.pyx", line 930, in cupy.core.fusion.Fusion.__call__
E           return kernel(
E         File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
E           kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
E         File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
E           kern = _get_elementwise_kernel(
E         File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
E           result = f(*args, **kwargs)
E         File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
E           return _get_simple_elementwise_kernel(
E         File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
E           cpdef function.Function _get_simple_elementwise_kernel(
E         File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
E           module = compile_with_cache(module_code, options)
E         File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
E           return cuda.compile_with_cache(
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
E           return _compile_with_cache_hip(
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
E           temp_path = tf.name
E         File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
E           result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
______________________ TestFusionCompile.test_clear_cache ______________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionCompile testMethod=test_clear_cache>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_bool=True)
    @testing.numpy_cupy_array_equal()
    def test_clear_cache(self, xp, dtype):
        @cupy.fuse()
        def f(x, y):
            return x - y * 2
    
        x = testing.shaped_arange((3, 3), xp, dtype)
        y = testing.shaped_arange((3, 3), xp, dtype)
        f.clear_cache()
>       return f(x, y)

tests/cupy_tests/core_tests/fusion_tests/test_misc.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44d1a100>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       AssertionError: Only cupy raises error
E       
E       Traceback (most recent call last):
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E           result = impl(self, *args, **kw)
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 304, in test_clear_cache
E           return f(x, y)
E         File "cupy/core/fusion.pyx", line 930, in cupy.core.fusion.Fusion.__call__
E           return kernel(
E         File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
E           kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
E         File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
E           kern = _get_elementwise_kernel(
E         File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
E           result = f(*args, **kwargs)
E         File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
E           return _get_simple_elementwise_kernel(
E         File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
E           cpdef function.Function _get_simple_elementwise_kernel(
E         File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
E           module = compile_with_cache(module_code, options)
E         File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
E           return cuda.compile_with_cache(
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
E           return _compile_with_cache_hip(
E         File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 805, in _compile_with_cache_hip
E           temp_path = tf.name
E         File "/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py", line 491, in __exit__
E           result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
________________ TestFusionGetArrayModule.test_get_array_module ________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionGetArrayModule testMethod=test_get_array_module>
generate_inputs_kwargs = {'dtype': <class 'numpy.float64'>}
generate_inputs = <bound method FusionTestBase.generate_inputs of <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionGetArrayModule testMethod=test_get_array_module>>
impl_fuse_np = <Fusion 'impl_fuse_np'>, impl_fuse_cp = <Fusion 'impl_fuse_cp'>
args_np = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]])]
kwargs_np = {}
args_cp = [array([[5.48813504, 7.15189366, 6.02763376, 5.44883183],
       [4.23654799, 6.45894113, 4.37587211, 8.91773001],
       [9.63662761, 3.83441519, 7.91725038, 5.2889492 ]])]
kwargs_cp = {}

    def wrapper(self, **generate_inputs_kwargs):
        generate_inputs = getattr(self, generate_inputs_name)
    
        impl_np = func(self, numpy, **generate_inputs_kwargs)
        impl_cp = func(self, cupy, **generate_inputs_kwargs)
    
        # TODO(imanishi): Fix these workaround after `cupy.fuse`
        # supports lambda function.
        # If `cupy.fuse` supports lambda function, these lines can be
        # written more simply (as `impl_fuse_np = cupy.fuse(impl_np)`).
        @cupy.fuse()
        def impl_fuse_np(*args, **kwargs):
            return impl_np(*args, **kwargs)
    
        @cupy.fuse()
        def impl_fuse_cp(*args, **kwargs):
            return impl_cp(*args, **kwargs)
    
        args_np, kwargs_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_cp, kwargs_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_np, kwargs_fuse_np = generate_inputs(
            numpy, *generate_inputs_args, **generate_inputs_kwargs)
        args_fuse_cp, kwargs_fuse_cp = generate_inputs(
            cupy, *generate_inputs_args, **generate_inputs_kwargs)
    
        result_np = call(impl_np, args_np, kwargs_np)
        result_cp = call(impl_cp, args_cp, kwargs_cp)
        result_fuse_np = call(impl_fuse_np, args_fuse_np, kwargs_fuse_np)
>       result_fuse_cp = call(impl_fuse_cp, args_fuse_cp, kwargs_fuse_cp)

tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/core_tests/fusion_tests/fusion_utils.py:70: in call
    ret = func(*args, **kwargs)
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b44c9ab50>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_________________________ TestFusionThread.test_thread _________________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionThread testMethod=test_thread>

    def test_thread(self):
        x = testing.shaped_arange((3, 3), cupy, cupy.int64)
        y = testing.shaped_arange((3, 3), cupy, cupy.int64)
        out = [None]
    
        @cupy.fuse()
        def f(x, y):
            return x + y * 2
    
        def _target(x, y):
            cupy.cuda.Device(0).use()
            out[0] = f(x, y)
    
        t = threading.Thread(target=_target, args=(x, y))
        t.daemon = True
        t.start()
        t.join()
>       assert (out[0] == f(x, y)).all()

tests/cupy_tests/core_tests/fusion_tests/test_misc.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/fusion.pyx:930: in cupy.core.fusion.Fusion.__call__
    return kernel(
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:805: in _compile_with_cache_hip
    temp_path = tf.name
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tempfile._TemporaryFileWrapper object at 0x7f2b4cf5f910>, exc = None
value = None, tb = None

    def __exit__(self, exc, value, tb):
>       result = self.file.__exit__(exc, value, tb)
E       OSError: [Errno 28] No space left on device

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/tempfile.py:491: OSError
_________________ TestFusionThread.test_thread_multiple_dtypes _________________

self = <cupy_tests.core_tests.fusion_tests.test_misc.TestFusionThread testMethod=test_thread_multiple_dtypes>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_array_equal()
    def test_thread_multiple_dtypes(self, xp):
        x1 = testing.shaped_arange((3, 3), xp, xp.int64)
        y1 = testing.shaped_arange((3, 3), xp, xp.int64)
        x2 = x1.astype(xp.float64)
        y2 = y1.astype(xp.float64)
        threads = [None] * 100
        out = [None] * 100
    
        @cupy.fuse()
        def f(x, y):
            return x + y * 2
    
        def _target(tid, x, y):
            if xp is cupy:
                xp.cuda.Device(0).use()
            out[tid] = f(x, y).astype(xp.int64)
    
        def run_thread(tid):
            x, y = (x1, y1) if tid % 2 == 0 else (x2, y2)
            t = threading.Thread(target=_target, args=(tid, x, y))
            threads[tid] = t
            t.daemon = True
            t.start()
    
        for tid in range(0, 50):
            run_thread(tid)
    
        for tid in range(0, 50):
            threads[tid].join()
    
        for tid in range(50, 100):
            run_thread(tid)
    
        for tid in range(50, 100):
            threads[tid].join()
    
>       return xp.concatenate(out)

tests/cupy_tests/core_tests/fusion_tests/test_misc.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/_manipulation/join.py:55: in concatenate
    return core.concatenate_method(tup, axis, out)
cupy/core/_routines_manipulation.pyx:538: in cupy.core._routines_manipulation.concatenate_method
    cpdef ndarray concatenate_method(tup, int axis, ndarray out=None):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Only cupy arrays can be concatenated')
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/core_tests/fusion_tests/test_misc.py", line 378, in test_thread_multiple_dtypes
E       return xp.concatenate(out)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/_manipulation/join.py", line 55, in concatenate
E       return core.concatenate_method(tup, axis, out)
E     File "cupy/core/_routines_manipulation.pyx", line 538, in cupy.core._routines_manipulation.concatenate_method
E       cpdef ndarray concatenate_method(tup, int axis, ndarray out=None):
E     File "cupy/core/_routines_manipulation.pyx", line 551, in cupy.core._routines_manipulation.concatenate_method
E       raise TypeError('Only cupy arrays can be concatenated')
E   TypeError: Only cupy arrays can be concatenated

cupy/core/_routines_manipulation.pyx:551: AssertionError
____________ TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)}.test_fft ____________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)} testMethod=test_fft>  parameter: {'shape': (64,)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_fft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)}.test_ifft ____________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)} testMethod=test_ifft>  parameter: {'shape': (64,)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_ifft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)}.test_fft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)} testMethod=test_fft>  parameter: {'shape': (4, 16)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_fft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
__________ TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)}.test_ifft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)} testMethod=test_ifft>  parameter: {'shape': (4, 16)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_ifft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)}.test_fft ____________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)} testMethod=test_fft>  parameter: {'shape': (128,)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_fft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)}.test_ifft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)} testMethod=test_ifft>  parameter: {'shape': (128,)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_ifft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
___________ TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)}.test_fft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)} testMethod=test_fft>  parameter: {'shape': (8, 32)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_fft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
__________ TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)}.test_ifft ___________

self = <<cupy_tests.cuda_tests.test_cufft.TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)} testMethod=test_ifft>  parameter: {'shape': (8, 32)}>
dtype = <class 'numpy.complex64'>

    @multi_gpu_config(gpu_configs=[[0, 1], [1, 0]])
    @testing.for_complex_dtypes()
    def test_ifft(self, dtype):
        _skip_multi_gpu_bug(self.shape, self.gpus)
    
        a = testing.shaped_random(self.shape, numpy, dtype)
    
        if len(self.shape) == 1:
            batch = 1
            nx = self.shape[0]
        elif len(self.shape) == 2:
            batch = self.shape[0]
            nx = self.shape[1]
    
        # compute via cuFFT
        cufft_type = _convert_fft_type(a.dtype, 'C2C')
>       plan = cufft.Plan1d(nx, cufft_type, batch, devices=config._devices)

tests/cupy_tests/cuda_tests/test_cufft.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/cufft.pyx:299: in cupy.cuda.cufft.Plan1d.__init__
    self._multi_gpu_get_plan(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise RuntimeError('hipFFT/rocFFT does not support multi-GPU FFT')
E   RuntimeError: hipFFT/rocFFT does not support multi-GPU FFT

cupy/cuda/cufft.pyx:357: RuntimeError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
GPU config is: [0, 1]
____________________ TestDeviceHandles.test_cusparse_handle ____________________

self = <cupy_tests.cuda_tests.test_device.TestDeviceHandles testMethod=test_cusparse_handle>

    def test_cusparse_handle(self):
>       self._check_handle(cuda.device.get_cusparse_handle)

tests/cupy_tests/cuda_tests/test_device.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy_tests.cuda_tests.test_device.TestDeviceHandles testMethod=test_cusparse_handle>
func = <built-in function get_cusparse_handle>

    def _check_handle(self, func):
        handles = [func(), None, None]
    
        def _subthread():
            handles[1] = func()
            handles[2] = func()
    
        t = threading.Thread(target=_subthread)
        t.start()
        t.join()
        assert handles[0] is not None
>       assert handles[0] != handles[1]
E       AssertionError: assert 139815617277216 != 139815617277216

tests/cupy_tests/cuda_tests/test_device.py:136: AssertionError
_ TestCUDAarray_param_0_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_0_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_1_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_1_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_2_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_2_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_3_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_3_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_4_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_4_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_5_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_5_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_6_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_6_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_7_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_7_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_8_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_8_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_9_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_9_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_10_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_10_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, strea...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_11_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_11_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_12_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_12_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_13_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_13_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, strea...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_14_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_14_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, strea...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_15_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_15_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_16_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_16_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_17_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_17_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, strea...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_18_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_18_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, strea...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_19_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_19_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_20_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_20_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_21_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_21_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, strea...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_22_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_22_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, strea...rameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_23_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_23_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, strea...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_24_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_24_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=T...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_25_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_25_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=T...>  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_26_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_26_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=F... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_27_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_27_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=F...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_28_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_28_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=T...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_29_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_29_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=T...>  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_30_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_30_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=F... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_31_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_31_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=F...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_32_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_32_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=T...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_33_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_33_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=T...>  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_34_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_34_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=F... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_35_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_35_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=F...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_36_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_36_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_37_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_37_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_38_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_38_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_39_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_39_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_40_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_40_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_41_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_41_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_42_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_42_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_43_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_43_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_44_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_44_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_45_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_45_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_46_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_46_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_47_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_47_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_48_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_48_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_49_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_49_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_50_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_50_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_51_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_51_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_52_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_52_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_53_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_53_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_54_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_54_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_55_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_55_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_56_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_56_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_57_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_57_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_58_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_58_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_59_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_59_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_60_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_60_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_61_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_61_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_62_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_62_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_63_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_63_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_64_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_64_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_65_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_65_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_66_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_66_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_67_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_67_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_68_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_68_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_69_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_69_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=...  parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_70_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_70_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_71_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_71_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_72_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_72_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_73_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_73_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_74_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_74_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_75_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_75_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_76_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_76_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_77_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_77_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_78_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_78_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_79_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_79_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_80_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_80_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_81_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_81_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_82_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_82_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_83_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_83_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_84_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_84_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_85_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_85_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_86_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_86_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_87_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_87_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_88_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_88_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_89_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_89_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_90_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_90_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_91_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_91_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_92_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_92_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_93_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_93_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream... parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_94_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_94_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream...arameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_95_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_95_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream...parameter: {'dimensions': (67, 0, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_96_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_96_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_97_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_97_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_98_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_98_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stre...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_99_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_99_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_100_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_100_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_101_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_101_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_102_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_102_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_103_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_103_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_104_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_104_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_105_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_105_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_106_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_106_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_107_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_107_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_108_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_108_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_109_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_109_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_110_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_110_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_111_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_111_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_112_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_112_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_113_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_113_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_114_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_114_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_115_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_115_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_116_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_116_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_117_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_117_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, str...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_118_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_118_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, str...ameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_119_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_119_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, str...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_120_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_120_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_121_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_121_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream...  parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_122_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_122_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_123_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_123_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_124_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_124_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_125_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_125_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream...  parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_126_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_126_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_127_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_127_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_128_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_128_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_129_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_129_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream...  parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_130_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_130_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_131_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_131_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_132_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_132_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_133_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_133_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_134_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_134_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_135_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_135_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_136_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_136_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_137_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_137_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_138_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_138_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_139_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_139_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_140_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_140_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_141_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_141_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_142_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_142_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_143_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_143_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_144_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_144_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_145_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_145_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_146_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_146_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_147_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_147_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_148_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_148_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_149_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_149_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_150_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_150_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_151_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_151_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_152_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_152_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_153_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_153_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_154_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_154_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_155_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_155_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_156_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_156_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_157_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_157_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_158_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_158_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_159_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_159_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_160_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_160_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_161_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_161_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_162_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_162_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_163_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_163_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_164_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_164_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_165_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_165_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, strea... parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_166_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_166_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, strea...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_167_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_167_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, strea...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_168_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_168_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_169_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_169_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_170_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_170_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_171_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_171_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_172_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_172_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_173_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_173_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_174_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_174_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_175_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_175_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_176_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_176_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_177_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_177_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_178_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_178_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_179_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_179_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_180_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_180_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_181_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_181_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_182_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_182_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_183_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_183_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_184_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_184_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_185_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_185_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_186_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_186_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_187_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_187_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_188_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_188_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_189_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_189_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stre...parameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_190_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_190_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stre...rameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_191_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_191_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stre...arameter: {'dimensions': (67, 19, 0), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_192_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_192_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_193_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_193_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_194_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_194_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_195_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_195_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_196_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_196_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_197_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_197_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_198_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_198_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_199_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_199_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_200_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_200_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_201_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_201_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_202_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_202_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_203_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_203_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_204_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_204_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_205_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_205_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_206_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_206_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_207_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_207_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_208_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_208_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_209_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_209_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_210_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_210_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_211_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_211_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_212_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_212_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_213_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_213_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, st...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_214_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_214_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, st...meter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_215_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_215_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, st...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.float32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_216_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_216_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_217_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_217_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, strea... parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_218_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_218_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, strea...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_219_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_219_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_220_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_220_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_221_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_221_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, strea... parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_222_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_222_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, strea...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_223_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_223_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_224_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_224_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_225_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_225_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, strea... parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_226_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_226_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, strea...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_227_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_227_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, strea...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_228_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_228_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_229_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_229_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_230_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_230_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_231_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_231_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_232_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_232_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_233_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_233_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_234_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_234_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_235_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_235_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_236_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_236_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_237_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_237_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_238_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_238_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_239_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_239_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_240_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_240_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_241_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_241_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_242_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_242_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_243_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_243_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_244_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_244_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_245_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_245_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_246_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_246_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_247_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_247_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_248_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_248_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_249_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_249_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_250_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_250_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_251_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_251_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.int32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_252_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_252_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_253_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_253_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_254_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_254_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_255_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_255_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_256_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_256_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_257_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_257_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_258_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_258_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_259_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_259_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_260_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_260_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_261_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_261_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stre...parameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_262_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_262_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stre...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_263_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_263_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stre...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint8'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_264_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_264_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_265_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_265_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_266_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_266_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_267_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_267_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_268_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_268_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_269_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_269_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_270_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_270_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_271_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_271_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_272_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_272_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_273_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_273_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_274_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_274_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_275_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_275_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint16'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_276_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_276_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_277_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_277_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_278_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_278_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_279_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_279_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 1, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_280_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_280_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_281_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_281_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_282_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_282_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_283_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_283_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 2, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_284_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=True, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_284_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_285_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=True, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_285_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, str...arameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': True, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_286_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=False, xp='numpy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_286_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, str...ameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'numpy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestCUDAarray_param_287_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=False, xp='cupy'}.test_array_gen_cpy _

self = <<cupy_tests.cuda_tests.test_texture.TestCUDAarray_param_287_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, str...rameter: {'dimensions': (67, 19, 31), 'dtype': <class 'numpy.uint32'>, 'n_channels': 4, 'stream': False, 'xp': 'cupy'}>

    def test_array_gen_cpy(self):
        xp = numpy if self.xp == 'numpy' else cupy
        stream = None if not self.stream else cupy.cuda.Stream()
        width, height, depth = self.dimensions
        n_channel = self.n_channels
    
        dim = 3 if depth != 0 else 2 if height != 0 else 1
        shape = (depth, height, n_channel*width) if dim == 3 else \
                (height, n_channel*width) if dim == 2 else \
                (n_channel*width,)
    
        # generate input data and allocate output buffer
        if self.dtype in (numpy.float16, numpy.float32):
            arr = xp.random.random(shape).astype(self.dtype)
            kind = runtime.cudaChannelFormatKindFloat
        else:  # int
            # randint() in NumPy <= 1.10 does not have the dtype argument...
            arr = xp.random.randint(100, size=shape).astype(self.dtype)
            if self.dtype in (numpy.int8, numpy.int16, numpy.int32):
                kind = runtime.cudaChannelFormatKindSigned
            else:
                kind = runtime.cudaChannelFormatKindUnsigned
        arr2 = xp.zeros_like(arr)
    
        assert arr.flags['C_CONTIGUOUS']
        assert arr2.flags['C_CONTIGUOUS']
    
        # create a CUDA array
        ch_bits = [0, 0, 0, 0]
        for i in range(n_channel):
            ch_bits[i] = arr.dtype.itemsize*8
        # unpacking arguments using *ch_bits is not supported before PY35...
        ch = ChannelFormatDescriptor(ch_bits[0], ch_bits[1], ch_bits[2],
                                     ch_bits[3], kind)
>       cu_arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_0_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='object'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_0_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='object'...stMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 0, 0), 'mem_type': 'CUDAarray', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_1_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='reference'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_1_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='referen...ethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 0, 0), 'mem_type': 'CUDAarray', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_2_{dimensions=(64, 0, 0), mem_type='linear', target='object'}.test_fetch_float_texture _

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f208ced63d0>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
>           nvrtc.compileProgram(self.ptr, options)

cupy/cuda/compiler.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   cpdef compileProgram(intptr_t prog, options):

cupy_backends/cuda/libs/nvrtc.pyx:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   check_status(status)

cupy_backends/cuda/libs/nvrtc.pyx:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise NVRTCError(status)
E   cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

cupy_backends/cuda/libs/nvrtc.pyx:62: NVRTCError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_2_{dimensions=(64, 0, 0), mem_type='linear', target='object'} testMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 0, 0), 'mem_type': 'linear', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
            arr = CUDAarray(ch, width, height, depth)
            expected_output = cupy.zeros_like(tex_data)
            assert expected_output.flags['C_CONTIGUOUS']
            # test bidirectional copy
            arr.copy_from(tex_data)
            arr.copy_to(expected_output)
        else:  # linear are pitch2D are backed by ndarray
            arr = tex_data
            expected_output = tex_data
    
        # create resource and texture descriptors
        if self.mem_type == 'CUDAarray':
            res = ResourceDescriptor(runtime.cudaResourceTypeArray, cuArr=arr)
        elif self.mem_type == 'linear':
            res = ResourceDescriptor(runtime.cudaResourceTypeLinear,
                                     arr=arr,
                                     chDesc=ch,
                                     sizeInBytes=arr.size*arr.dtype.itemsize)
        else:  # pitch2D
            # In this case, we rely on the fact that the hand-picked array
            # shape meets the alignment requirement. This is CUDA's limitation,
            # see CUDA Runtime API reference guide. "TexturePitchAlignment" is
            # assumed to be 32, which should be applicable for most devices.
            res = ResourceDescriptor(runtime.cudaResourceTypePitch2D,
                                     arr=arr,
                                     chDesc=ch,
                                     width=width,
                                     height=height,
                                     pitchInBytes=width*arr.dtype.itemsize)
        address_mode = (runtime.cudaAddressModeClamp,
                        runtime.cudaAddressModeClamp)
        tex = TextureDescriptor(address_mode, runtime.cudaFilterModePoint,
                                runtime.cudaReadModeElementType)
    
        if self.target == 'object':
            # create a texture object
            texobj = TextureObject(res, tex)
            mod = cupy.RawModule(code=source_texobj)
        else:  # self.target == 'reference'
            mod = cupy.RawModule(code=source_texref)
            texref_name = 'texref'
            texref_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
            texrefPtr = mod.get_texref(texref_name)
            # bind texture ref to resource
            texref = TextureReference(texrefPtr, res, tex)  # noqa
    
        # get and launch the kernel
        ker_name = 'copyKernel'
        ker_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
        ker_name += 'fetch' if self.mem_type == 'linear' else ''
>       ker = mod.get_function(ker_name)

tests/cupy_tests/cuda_tests/test_texture.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/raw.pyx:485: in cupy.core.raw.RawModule.get_function
    func = ker.kernel  # noqa
cupy/core/raw.pyx:96: in cupy.core.raw.RawKernel.kernel.__get__
    return self._kernel()
cupy/core/raw.pyx:113: in cupy.core.raw.RawKernel._kernel
    mod = _get_raw_module(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/raw.pyx:547: in cupy.core.raw._get_raw_module
    mod = cupy.core.core.compile_with_cache(
cupy/core/core.pyx:1956: in cupy.core.core.compile_with_cache
    cpdef function.Module compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f208ced63d0>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           cupy.cuda.compiler.CompileException: /tmp/comgr-78802f/input/CompileSource:5357:35: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                             cudaTextureObject_t texObj,
E                                             ^~~~~~~~~~~~~~~~~~~
E                                             hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-78802f/input/CompileSource:5368:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-78802f/input/CompileSource:5380:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-78802f/input/CompileSource:5394:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-78802f/input/CompileSource:5413:34: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                            cudaTextureObject_t texObj,
E                                            ^~~~~~~~~~~~~~~~~~~
E                                            hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           5 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: CompileException
_ TestTexture_param_3_{dimensions=(64, 0, 0), mem_type='linear', target='reference'}.test_fetch_float_texture _

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f2acf50dca0>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
>           nvrtc.compileProgram(self.ptr, options)

cupy/cuda/compiler.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   cpdef compileProgram(intptr_t prog, options):

cupy_backends/cuda/libs/nvrtc.pyx:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   check_status(status)

cupy_backends/cuda/libs/nvrtc.pyx:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise NVRTCError(status)
E   cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

cupy_backends/cuda/libs/nvrtc.pyx:62: NVRTCError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_3_{dimensions=(64, 0, 0), mem_type='linear', target='reference'...stMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 0, 0), 'mem_type': 'linear', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
            arr = CUDAarray(ch, width, height, depth)
            expected_output = cupy.zeros_like(tex_data)
            assert expected_output.flags['C_CONTIGUOUS']
            # test bidirectional copy
            arr.copy_from(tex_data)
            arr.copy_to(expected_output)
        else:  # linear are pitch2D are backed by ndarray
            arr = tex_data
            expected_output = tex_data
    
        # create resource and texture descriptors
        if self.mem_type == 'CUDAarray':
            res = ResourceDescriptor(runtime.cudaResourceTypeArray, cuArr=arr)
        elif self.mem_type == 'linear':
            res = ResourceDescriptor(runtime.cudaResourceTypeLinear,
                                     arr=arr,
                                     chDesc=ch,
                                     sizeInBytes=arr.size*arr.dtype.itemsize)
        else:  # pitch2D
            # In this case, we rely on the fact that the hand-picked array
            # shape meets the alignment requirement. This is CUDA's limitation,
            # see CUDA Runtime API reference guide. "TexturePitchAlignment" is
            # assumed to be 32, which should be applicable for most devices.
            res = ResourceDescriptor(runtime.cudaResourceTypePitch2D,
                                     arr=arr,
                                     chDesc=ch,
                                     width=width,
                                     height=height,
                                     pitchInBytes=width*arr.dtype.itemsize)
        address_mode = (runtime.cudaAddressModeClamp,
                        runtime.cudaAddressModeClamp)
        tex = TextureDescriptor(address_mode, runtime.cudaFilterModePoint,
                                runtime.cudaReadModeElementType)
    
        if self.target == 'object':
            # create a texture object
            texobj = TextureObject(res, tex)
            mod = cupy.RawModule(code=source_texobj)
        else:  # self.target == 'reference'
            mod = cupy.RawModule(code=source_texref)
            texref_name = 'texref'
            texref_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
>           texrefPtr = mod.get_texref(texref_name)

tests/cupy_tests/cuda_tests/test_texture.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/raw.pyx:497: in cupy.core.raw.RawModule.get_texref
    return self.module.get_texref(name)
cupy/core/raw.pyx:394: in cupy.core.raw.RawModule.module.__get__
    return self._module()
cupy/core/raw.pyx:402: in cupy.core.raw.RawModule._module
    mod = _get_raw_module(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/raw.pyx:547: in cupy.core.raw._get_raw_module
    mod = cupy.core.core.compile_with_cache(
cupy/core/core.pyx:1956: in cupy.core.core.compile_with_cache
    cpdef function.Module compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f2acf50dca0>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           cupy.cuda.compiler.CompileException: /tmp/comgr-3ac847/input/CompileSource:5356:16: error: use of undeclared identifier 'cudaTextureType1D'
E           texture<float, cudaTextureType1D, cudaReadModeElementType> texref1D;
E                          ^
E           /tmp/comgr-3ac847/input/CompileSource:5357:16: error: use of undeclared identifier 'cudaTextureType2D'
E           texture<float, cudaTextureType2D, cudaReadModeElementType> texref2D;
E                          ^
E           /tmp/comgr-3ac847/input/CompileSource:5358:16: error: use of undeclared identifier 'cudaTextureType3D'
E           texture<float, cudaTextureType3D, cudaReadModeElementType> texref3D;
E                          ^
E           /tmp/comgr-3ac847/input/CompileSource:5359:17: error: use of undeclared identifier 'cudaTextureType3D'
E           texture<float4, cudaTextureType3D, cudaReadModeElementType> texref3Df4;
E                           ^
E           4 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: CompileException
_ TestTexture_param_6_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='object'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_6_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='object...tMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 0), 'mem_type': 'CUDAarray', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_7_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='reference'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_7_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='refere...thod=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 0), 'mem_type': 'CUDAarray', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_10_{dimensions=(64, 32, 0), mem_type='pitch2D', target='object'}.test_fetch_float_texture _

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f208d8bb670>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
>           nvrtc.compileProgram(self.ptr, options)

cupy/cuda/compiler.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   cpdef compileProgram(intptr_t prog, options):

cupy_backends/cuda/libs/nvrtc.pyx:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   check_status(status)

cupy_backends/cuda/libs/nvrtc.pyx:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise NVRTCError(status)
E   cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

cupy_backends/cuda/libs/nvrtc.pyx:62: NVRTCError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_10_{dimensions=(64, 32, 0), mem_type='pitch2D', target='object'} testMethod=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 0), 'mem_type': 'pitch2D', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
            arr = CUDAarray(ch, width, height, depth)
            expected_output = cupy.zeros_like(tex_data)
            assert expected_output.flags['C_CONTIGUOUS']
            # test bidirectional copy
            arr.copy_from(tex_data)
            arr.copy_to(expected_output)
        else:  # linear are pitch2D are backed by ndarray
            arr = tex_data
            expected_output = tex_data
    
        # create resource and texture descriptors
        if self.mem_type == 'CUDAarray':
            res = ResourceDescriptor(runtime.cudaResourceTypeArray, cuArr=arr)
        elif self.mem_type == 'linear':
            res = ResourceDescriptor(runtime.cudaResourceTypeLinear,
                                     arr=arr,
                                     chDesc=ch,
                                     sizeInBytes=arr.size*arr.dtype.itemsize)
        else:  # pitch2D
            # In this case, we rely on the fact that the hand-picked array
            # shape meets the alignment requirement. This is CUDA's limitation,
            # see CUDA Runtime API reference guide. "TexturePitchAlignment" is
            # assumed to be 32, which should be applicable for most devices.
            res = ResourceDescriptor(runtime.cudaResourceTypePitch2D,
                                     arr=arr,
                                     chDesc=ch,
                                     width=width,
                                     height=height,
                                     pitchInBytes=width*arr.dtype.itemsize)
        address_mode = (runtime.cudaAddressModeClamp,
                        runtime.cudaAddressModeClamp)
        tex = TextureDescriptor(address_mode, runtime.cudaFilterModePoint,
                                runtime.cudaReadModeElementType)
    
        if self.target == 'object':
            # create a texture object
            texobj = TextureObject(res, tex)
            mod = cupy.RawModule(code=source_texobj)
        else:  # self.target == 'reference'
            mod = cupy.RawModule(code=source_texref)
            texref_name = 'texref'
            texref_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
            texrefPtr = mod.get_texref(texref_name)
            # bind texture ref to resource
            texref = TextureReference(texrefPtr, res, tex)  # noqa
    
        # get and launch the kernel
        ker_name = 'copyKernel'
        ker_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
        ker_name += 'fetch' if self.mem_type == 'linear' else ''
>       ker = mod.get_function(ker_name)

tests/cupy_tests/cuda_tests/test_texture.py:319: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/raw.pyx:485: in cupy.core.raw.RawModule.get_function
    func = ker.kernel  # noqa
cupy/core/raw.pyx:96: in cupy.core.raw.RawKernel.kernel.__get__
    return self._kernel()
cupy/core/raw.pyx:113: in cupy.core.raw.RawKernel._kernel
    mod = _get_raw_module(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/raw.pyx:547: in cupy.core.raw._get_raw_module
    mod = cupy.core.core.compile_with_cache(
cupy/core/core.pyx:1956: in cupy.core.core.compile_with_cache
    cpdef function.Module compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f208d8bb670>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           cupy.cuda.compiler.CompileException: /tmp/comgr-0b1849/input/CompileSource:5357:35: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                             cudaTextureObject_t texObj,
E                                             ^~~~~~~~~~~~~~~~~~~
E                                             hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-0b1849/input/CompileSource:5368:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-0b1849/input/CompileSource:5380:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-0b1849/input/CompileSource:5394:30: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                        cudaTextureObject_t texObj,
E                                        ^~~~~~~~~~~~~~~~~~~
E                                        hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           /tmp/comgr-0b1849/input/CompileSource:5413:34: error: unknown type name 'cudaTextureObject_t'; did you mean 'hipTextureObject_t'?
E                                            cudaTextureObject_t texObj,
E                                            ^~~~~~~~~~~~~~~~~~~
E                                            hipTextureObject_t
E           /opt/rocm/hip/include/hip/hcc_detail/texture_types.h:49:31: note: 'hipTextureObject_t' declared here
E           typedef struct __hip_texture* hipTextureObject_t;
E                                         ^
E           5 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: CompileException
_ TestTexture_param_11_{dimensions=(64, 32, 0), mem_type='pitch2D', target='reference'}.test_fetch_float_texture _

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f208c5e35b0>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
>           nvrtc.compileProgram(self.ptr, options)

cupy/cuda/compiler.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   cpdef compileProgram(intptr_t prog, options):

cupy_backends/cuda/libs/nvrtc.pyx:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   check_status(status)

cupy_backends/cuda/libs/nvrtc.pyx:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise NVRTCError(status)
E   cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

cupy_backends/cuda/libs/nvrtc.pyx:62: NVRTCError

During handling of the above exception, another exception occurred:

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_11_{dimensions=(64, 32, 0), mem_type='pitch2D', target='referen...Method=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 0), 'mem_type': 'pitch2D', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
            arr = CUDAarray(ch, width, height, depth)
            expected_output = cupy.zeros_like(tex_data)
            assert expected_output.flags['C_CONTIGUOUS']
            # test bidirectional copy
            arr.copy_from(tex_data)
            arr.copy_to(expected_output)
        else:  # linear are pitch2D are backed by ndarray
            arr = tex_data
            expected_output = tex_data
    
        # create resource and texture descriptors
        if self.mem_type == 'CUDAarray':
            res = ResourceDescriptor(runtime.cudaResourceTypeArray, cuArr=arr)
        elif self.mem_type == 'linear':
            res = ResourceDescriptor(runtime.cudaResourceTypeLinear,
                                     arr=arr,
                                     chDesc=ch,
                                     sizeInBytes=arr.size*arr.dtype.itemsize)
        else:  # pitch2D
            # In this case, we rely on the fact that the hand-picked array
            # shape meets the alignment requirement. This is CUDA's limitation,
            # see CUDA Runtime API reference guide. "TexturePitchAlignment" is
            # assumed to be 32, which should be applicable for most devices.
            res = ResourceDescriptor(runtime.cudaResourceTypePitch2D,
                                     arr=arr,
                                     chDesc=ch,
                                     width=width,
                                     height=height,
                                     pitchInBytes=width*arr.dtype.itemsize)
        address_mode = (runtime.cudaAddressModeClamp,
                        runtime.cudaAddressModeClamp)
        tex = TextureDescriptor(address_mode, runtime.cudaFilterModePoint,
                                runtime.cudaReadModeElementType)
    
        if self.target == 'object':
            # create a texture object
            texobj = TextureObject(res, tex)
            mod = cupy.RawModule(code=source_texobj)
        else:  # self.target == 'reference'
            mod = cupy.RawModule(code=source_texref)
            texref_name = 'texref'
            texref_name += '3D' if dim == 3 else '2D' if dim == 2 else '1D'
>           texrefPtr = mod.get_texref(texref_name)

tests/cupy_tests/cuda_tests/test_texture.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/raw.pyx:497: in cupy.core.raw.RawModule.get_texref
    return self.module.get_texref(name)
cupy/core/raw.pyx:394: in cupy.core.raw.RawModule.module.__get__
    return self._module()
cupy/core/raw.pyx:402: in cupy.core.raw.RawModule._module
    mod = _get_raw_module(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/raw.pyx:547: in cupy.core.raw._get_raw_module
    mod = cupy.core.core.compile_with_cache(
cupy/core/core.pyx:1956: in cupy.core.core.compile_with_cache
    cpdef function.Module compile_with_cache(
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f208c5e35b0>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           cupy.cuda.compiler.CompileException: /tmp/comgr-a65e12/input/CompileSource:5356:16: error: use of undeclared identifier 'cudaTextureType1D'
E           texture<float, cudaTextureType1D, cudaReadModeElementType> texref1D;
E                          ^
E           /tmp/comgr-a65e12/input/CompileSource:5357:16: error: use of undeclared identifier 'cudaTextureType2D'
E           texture<float, cudaTextureType2D, cudaReadModeElementType> texref2D;
E                          ^
E           /tmp/comgr-a65e12/input/CompileSource:5358:16: error: use of undeclared identifier 'cudaTextureType3D'
E           texture<float, cudaTextureType3D, cudaReadModeElementType> texref3D;
E                          ^
E           /tmp/comgr-a65e12/input/CompileSource:5359:17: error: use of undeclared identifier 'cudaTextureType3D'
E           texture<float4, cudaTextureType3D, cudaReadModeElementType> texref3Df4;
E                           ^
E           4 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: CompileException
_ TestTexture_param_12_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='object'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_12_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='obje...Method=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 19), 'mem_type': 'CUDAarray', 'target': 'object'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTexture_param_13_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='reference'}.test_fetch_float_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTexture_param_13_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='refe...hod=test_fetch_float_texture>  parameter: {'dimensions': (64, 32, 19), 'mem_type': 'CUDAarray', 'target': 'reference'}>

    def test_fetch_float_texture(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        if (self.mem_type == 'linear' and dim != 1) or \
           (self.mem_type == 'pitch2D' and dim != 2):
            pytest.skip('The test case {0} is inapplicable for {1} and thus '
                        'skipped.'.format(self.dimensions, self.mem_type))
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(shape, dtype=cupy.float32)
        real_output = cupy.zeros_like(tex_data)
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        assert tex_data.flags['C_CONTIGUOUS']
        assert real_output.flags['C_CONTIGUOUS']
        if self.mem_type == 'CUDAarray':
>           arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
__ TestTextureVectorType_param_0_{target='object'}.test_fetch_float4_texture ___

self = <<cupy_tests.cuda_tests.test_texture.TestTextureVectorType_param_0_{target='object'} testMethod=test_fetch_float4_texture>  parameter: {'target': 'object'}>

    def test_fetch_float4_texture(self):
        width = 47
        height = 39
        depth = 11
        n_channel = 4
    
        # generate input data and allocate output buffer
        in_shape = (depth, height, n_channel*width)
        out_shape = (depth, height, width)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(in_shape, dtype=cupy.float32)
        real_output_x = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_y = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_z = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_w = cupy.zeros(out_shape, dtype=cupy.float32)
        ch = ChannelFormatDescriptor(32, 32, 32, 32,
                                     runtime.cudaChannelFormatKindFloat)
>       arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:366: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_ TestTextureVectorType_param_1_{target='reference'}.test_fetch_float4_texture _

self = <<cupy_tests.cuda_tests.test_texture.TestTextureVectorType_param_1_{target='reference'} testMethod=test_fetch_float4_texture>  parameter: {'target': 'reference'}>

    def test_fetch_float4_texture(self):
        width = 47
        height = 39
        depth = 11
        n_channel = 4
    
        # generate input data and allocate output buffer
        in_shape = (depth, height, n_channel*width)
        out_shape = (depth, height, width)
    
        # prepare input, output, and texture memory
        tex_data = cupy.random.random(in_shape, dtype=cupy.float32)
        real_output_x = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_y = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_z = cupy.zeros(out_shape, dtype=cupy.float32)
        real_output_w = cupy.zeros(out_shape, dtype=cupy.float32)
        ch = ChannelFormatDescriptor(32, 32, 32, 32,
                                     runtime.cudaChannelFormatKindFloat)
>       arr = CUDAarray(ch, width, height, depth)

tests/cupy_tests/cuda_tests/test_texture.py:366: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
_____ TestSurface_param_0_{dimensions=(64, 0, 0)}.test_write_float_surface _____

self = <<cupy_tests.cuda_tests.test_texture.TestSurface_param_0_{dimensions=(64, 0, 0)} testMethod=test_write_float_surface>  parameter: {'dimensions': (64, 0, 0)}>

    def test_write_float_surface(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and surface memory
        real_output = cupy.zeros(shape, dtype=cupy.float32)
        assert real_output.flags['C_CONTIGUOUS']
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        expected_output = cupy.arange(numpy.prod(shape), dtype=cupy.float32)
        expected_output = expected_output.reshape(shape) * 3.0
        assert expected_output.flags['C_CONTIGUOUS']
    
        # create resource descriptor
        # note that surface memory only support CUDA array
>       arr = CUDAarray(ch, width, height, depth,
                        runtime.cudaArraySurfaceLoadStore)

tests/cupy_tests/cuda_tests/test_texture.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
____ TestSurface_param_1_{dimensions=(64, 32, 0)}.test_write_float_surface _____

self = <<cupy_tests.cuda_tests.test_texture.TestSurface_param_1_{dimensions=(64, 32, 0)} testMethod=test_write_float_surface>  parameter: {'dimensions': (64, 32, 0)}>

    def test_write_float_surface(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and surface memory
        real_output = cupy.zeros(shape, dtype=cupy.float32)
        assert real_output.flags['C_CONTIGUOUS']
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        expected_output = cupy.arange(numpy.prod(shape), dtype=cupy.float32)
        expected_output = expected_output.reshape(shape) * 3.0
        assert expected_output.flags['C_CONTIGUOUS']
    
        # create resource descriptor
        # note that surface memory only support CUDA array
>       arr = CUDAarray(ch, width, height, depth,
                        runtime.cudaArraySurfaceLoadStore)

tests/cupy_tests/cuda_tests/test_texture.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
____ TestSurface_param_2_{dimensions=(64, 32, 32)}.test_write_float_surface ____

self = <<cupy_tests.cuda_tests.test_texture.TestSurface_param_2_{dimensions=(64, 32, 32)} testMethod=test_write_float_surface>  parameter: {'dimensions': (64, 32, 32)}>

    def test_write_float_surface(self):
        width, height, depth = self.dimensions
        dim = 3 if depth != 0 else 2 if height != 0 else 1
    
        # generate input data and allocate output buffer
        shape = (depth, height, width) if dim == 3 else \
                (height, width) if dim == 2 else \
                (width,)
    
        # prepare input, output, and surface memory
        real_output = cupy.zeros(shape, dtype=cupy.float32)
        assert real_output.flags['C_CONTIGUOUS']
        ch = ChannelFormatDescriptor(32, 0, 0, 0,
                                     runtime.cudaChannelFormatKindFloat)
        expected_output = cupy.arange(numpy.prod(shape), dtype=cupy.float32)
        expected_output = expected_output.reshape(shape) * 3.0
        assert expected_output.flags['C_CONTIGUOUS']
    
        # create resource descriptor
        # note that surface memory only support CUDA array
>       arr = CUDAarray(ch, width, height, depth,
                        runtime.cudaArraySurfaceLoadStore)

tests/cupy_tests/cuda_tests/test_texture.py:478: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/cuda/texture.pyx:293: in cupy.cuda.texture.CUDAarray.__init__
    self.ptr = runtime.malloc3DArray(desc.ptr, width, height, depth,
cupy_backends/cuda/api/runtime.pyx:580: in cupy_backends.cuda.api.runtime.malloc3DArray
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUDARuntimeError(status)
E   cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown

cupy_backends/cuda/api/runtime.pyx:257: CUDARuntimeError
----------------------------- Captured stderr call -----------------------------
Traceback (most recent call last):
  File "cupy_backends/cuda/api/runtime.pyx", line 639, in cupy_backends.cuda.api.runtime.freeArray
    check_status(status)
  File "cupy_backends/cuda/api/runtime.pyx", line 257, in cupy_backends.cuda.api.runtime.check_status
    raise CUDARuntimeError(status)
cupy_backends.cuda.api.runtime.CUDARuntimeError: hipErrorUnknown: hipErrorUnknown
___________________________ TestIX_.test_ix_ndarray ____________________________
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[0],
       [1]], dtype=int32)
y = array([[0],
       [1]], dtype=int32), err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 2 (50%)
E       Max absolute difference: 1065353215
E       Max relative difference: 1.06535322e+09
E        x: array([[         0],
E              [1065353216]], dtype=int32)
E        y: array([[0],
E              [1]], dtype=int32)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int32'>
_ TestPoly1dMathArithmetic_param_0_{fname='add', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_0_{fname='add', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'add', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_1_{fname='add', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_1_{fname='add', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'add', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_2_{fname='add', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_2_{fname='add', type_l='python_scalar', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'add', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_3_{fname='add', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_3_{fname='add', type_l='numpy_scalar', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'add', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_4_{fname='subtract', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_4_{fname='subtract', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'subtract', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_5_{fname='subtract', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_5_{fname='subtract', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'subtract', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_6_{fname='subtract', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_6_{fname='subtract', type_l='python_scalar', typ...'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'subtract', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_7_{fname='subtract', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_7_{fname='subtract', type_l='numpy_scalar', type...d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'subtract', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_8_{fname='multiply', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_8_{fname='multiply', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'multiply', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_9_{fname='multiply', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_9_{fname='multiply', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'multiply', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_10_{fname='multiply', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_10_{fname='multiply', type_l='python_scalar', ty...'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'multiply', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_11_{fname='multiply', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_11_{fname='multiply', type_l='numpy_scalar', typ...d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'multiply', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_12_{fname='divide', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_12_{fname='divide', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'divide', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_13_{fname='divide', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_13_{fname='divide', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'divide', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_14_{fname='divide', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_14_{fname='divide', type_l='python_scalar', type...1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'divide', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_15_{fname='divide', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_15_{fname='divide', type_l='numpy_scalar', type_...y1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'divide', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_16_{fname='power', type_l='poly1d', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_16_{fname='power', type_l='poly1d', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'power', 'type_l': 'poly1d', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_17_{fname='power', type_l='ndarray', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_17_{fname='power', type_l='ndarray', type_r='poly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'power', 'type_l': 'ndarray', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_18_{fname='power', type_l='python_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_18_{fname='power', type_l='python_scalar', type_...y1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'power', 'type_l': 'python_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPoly1dMathArithmetic_param_19_{fname='power', type_l='numpy_scalar', type_r='poly1d'}.test_poly1d_arithmetic _

self = <<cupy_tests.lib_tests.test_polynomial.TestPoly1dMathArithmetic_param_19_{fname='power', type_l='numpy_scalar', type_r...ly1d'} testMethod=test_poly1d_arithmetic>  parameter: {'fname': 'power', 'type_l': 'numpy_scalar', 'type_r': 'poly1d'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-5)
    def test_poly1d_arithmetic(self, xp, dtype):
        func = getattr(xp, self.fname)
        a1 = self._get_input(xp, self.type_l, dtype)
        a2 = self._get_input(xp, self.type_r, dtype)
>       return func(a1, a2)

tests/cupy_tests/lib_tests/test_polynomial.py:330: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1060: in cupy.core._kernel.ufunc.__call__
    arg_list = _preprocess_args(dev_id, args, False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise TypeError('Unsupported type %s' % type(arg))
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 330, in test_poly1d_arithmetic
E       return func(a1, a2)
E     File "cupy/core/_kernel.pyx", line 1060, in cupy.core._kernel.ufunc.__call__
E       arg_list = _preprocess_args(dev_id, args, False)
E     File "cupy/core/_kernel.pyx", line 109, in cupy.core._kernel._preprocess_args
E       raise TypeError('Unsupported type %s' % type(arg))
E   TypeError: Unsupported type <class 'cupy.lib._polynomial.poly1d'>

cupy/core/_kernel.pyx:109: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyArithmeticDiffTypes_param_2_{fname='polymul'}.test_polyroutine_diff_types_array _
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([ 1.74386169e-05  +1.999987j, -8.70033273e-06  +8.000005j,
        3.22509732e-05 +20.j      , -1.31668885e-05 +...,  1.34253614e-05+211.99995j ,
        1.82537897e-05+169.99998j ,  7.00168357e-06 +99.99997j ],
      dtype=complex64)
desired = array([0.  +2.j, 0.  +8.j, 0. +20.j, 0. +40.j, 0. +70.j, 0.+100.j,
       0.+130.j, 0.+160.j, 0.+190.j, 0.+220.j, 0.+228.j, 0.+212.j,
       0.+170.j, 0.+100.j], dtype=complex64)
rtol = 1e-05, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 14 (7.14%)
E       Max absolute difference: 6.121e-05
E       Max relative difference: 1.0873644e-05
E        x: array([ 1.743862e-05  +1.999987j, -8.700333e-06  +8.000005j,
E               3.225097e-05 +20.j      , -1.316689e-05 +40.00001j ,
E               1.074560e-05 +69.999985j,  5.520945e-07 +99.99997j ,...
E        y: array([0.  +2.j, 0.  +8.j, 0. +20.j, 0. +40.j, 0. +70.j, 0.+100.j,
E              0.+130.j, 0.+160.j, 0.+190.j, 0.+220.j, 0.+228.j, 0.+212.j,
E              0.+170.j, 0.+100.j], dtype=complex64)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.complex64'>, 'dtype2': <class 'numpy.complex64'>}
_ TestPolyArithmeticDiffTypes_param_2_{fname='polymul'}.test_polyroutine_diff_types_poly1d _
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([ 1.74386169e-05  +1.999987j, -8.70033273e-06  +8.000005j,
        3.22509732e-05 +20.j      , -1.31668885e-05 +...,  1.34253614e-05+211.99995j ,
        1.82537897e-05+169.99998j ,  7.00168357e-06 +99.99997j ],
      dtype=complex64)
desired = array([0.  +2.j, 0.  +8.j, 0. +20.j, 0. +40.j, 0. +70.j, 0.+100.j,
       0.+130.j, 0.+160.j, 0.+190.j, 0.+220.j, 0.+228.j, 0.+212.j,
       0.+170.j, 0.+100.j], dtype=complex64)
rtol = 1e-05, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 14 (7.14%)
E       Max absolute difference: 6.121e-05
E       Max relative difference: 1.0873644e-05
E        x: array([ 1.743862e-05  +1.999987j, -8.700333e-06  +8.000005j,
E               3.225097e-05 +20.j      , -1.316689e-05 +40.00001j ,
E               1.074560e-05 +69.999985j,  5.520945e-07 +99.99997j ,...
E        y: array([0.  +2.j, 0.  +8.j, 0. +20.j, 0. +40.j, 0. +70.j, 0.+100.j,
E              0.+130.j, 0.+160.j, 0.+190.j, 0.+220.j, 0.+228.j, 0.+212.j,
E              0.+170.j, 0.+100.j], dtype=complex64)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.complex64'>, 'dtype2': <class 'numpy.complex64'>}
_ TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shap... testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': None, 'shape1': (3,), 'shape2': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shap...testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': None, 'shape1': (3,), 'shape2': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shap...estMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': None, 'shape1': (3,), 'shape2': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shap...stMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': None, 'shape1': (3,), 'shape2': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape...} testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 0.5, 'shape1': (3,), 'shape2': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape... testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 0.5, 'shape1': (3,), 'shape2': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape...testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 0.5, 'shape1': (3,), 'shape2': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape...estMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 0.5, 'shape1': (3,), 'shape2': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), sha...testMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 1e-15, 'shape1': (3,), 'shape2': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.57142857]), desired = array([2.57142857]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 5.14285714
E       Max relative difference: 2.
E        x: array([-2.571429])
E        y: array([2.571429])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), sha...estMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 1e-15, 'shape1': (3,), 'shape2': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=True}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), sh...stMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 1e-15, 'shape1': (3,), 'shape2': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-4.14285714, -5.14285714]])
desired = array([[4.14285714, 5.14285714]]), rtol = 1e-07, atol = 1e-09
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 10.28571429
E       Max relative difference: 2.
E        x: array([[-4.142857, -5.142857]])
E        y: array([[4.142857, 5.142857]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_default _
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=False}.test_polyfit_full _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), sh...tMethod=test_polyfit_full>  parameter: {'deg': 0, 'rcond': 1e-15, 'shape1': (3,), 'shape2': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True)
    def test_polyfit_full(self, dtype):
        cp_c, cp_resids, cp_rank, cp_s, cp_rcond = self._full_fit(cupy, dtype)
        np_c, np_resids, np_rank, np_s, np_rcond = self._full_fit(numpy, dtype)
    
>       testing.assert_allclose(cp_c, np_c, atol=1e-9)

tests/cupy_tests/lib_tests/test_polynomial.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-07
atol = 1e-09, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-09
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_0_{cov='unscaled', deg=0, rcond=None, shape=(3,), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_0_{cov='unscaled', deg=0, rcond=None, shape=(3,), weig...testMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': None, 'shape': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.41388175]), desired = array([2.41388175]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.8277635
E       Max relative difference: 2.
E        x: array([-2.413882])
E        y: array([2.413882])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_1_{cov='unscaled', deg=0, rcond=None, shape=(3,), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_1_{cov='unscaled', deg=0, rcond=None, shape=(3,), weig...estMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': None, 'shape': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_2_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_2_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), we...stMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': None, 'shape': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3.8277635, -4.8277635]])
desired = array([[3.8277635, 4.8277635]]), rtol = 1e-05, atol = 0, err_msg = ''
verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 9.65552699
E       Max relative difference: 2.
E        x: array([[-3.827763, -4.827763]])
E        y: array([[3.827763, 4.827763]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_3_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_3_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), we...tMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': None, 'shape': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_4_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_4_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), wei...estMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': 1e-15, 'shape': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.41388175]), desired = array([2.41388175]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.8277635
E       Max relative difference: 2.
E        x: array([-2.413882])
E        y: array([2.413882])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_5_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_5_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), wei...stMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': 1e-15, 'shape': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_6_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_6_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), w...tMethod=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': 1e-15, 'shape': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3.8277635, -4.8277635]])
desired = array([[3.8277635, 4.8277635]]), rtol = 1e-05, atol = 0, err_msg = ''
verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 9.65552699
E       Max relative difference: 2.
E        x: array([[-3.827763, -4.827763]])
E        y: array([[3.827763, 4.827763]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_7_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_7_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), w...Method=test_polyfit_cov>  parameter: {'cov': 'unscaled', 'deg': 0, 'rcond': 1e-15, 'shape': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_16_{cov=True, deg=0, rcond=None, shape=(3,), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_16_{cov=True, deg=0, rcond=None, shape=(3,), weighted=True} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': None, 'shape': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.41388175]), desired = array([2.41388175]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.8277635
E       Max relative difference: 2.
E        x: array([-2.413882])
E        y: array([2.413882])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_17_{cov=True, deg=0, rcond=None, shape=(3,), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_17_{cov=True, deg=0, rcond=None, shape=(3,), weighted=False} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': None, 'shape': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_18_{cov=True, deg=0, rcond=None, shape=(3, 2), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_18_{cov=True, deg=0, rcond=None, shape=(3, 2), weighte...ue} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': None, 'shape': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3.8277635, -4.8277635]])
desired = array([[3.8277635, 4.8277635]]), rtol = 1e-05, atol = 0, err_msg = ''
verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 9.65552699
E       Max relative difference: 2.
E        x: array([[-3.827763, -4.827763]])
E        y: array([[3.827763, 4.827763]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_19_{cov=True, deg=0, rcond=None, shape=(3, 2), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_19_{cov=True, deg=0, rcond=None, shape=(3, 2), weighte...e} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': None, 'shape': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_20_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_20_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=True} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': 1e-15, 'shape': (3,), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.41388175]), desired = array([2.41388175]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.8277635
E       Max relative difference: 2.
E        x: array([-2.413882])
E        y: array([2.413882])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_21_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_21_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted...se} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': 1e-15, 'shape': (3,), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([-2.]), desired = array([2.]), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4.
E       Max relative difference: 2.
E        x: array([-2.])
E        y: array([2.])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_22_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weighted=True}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_22_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weight...e} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': 1e-15, 'shape': (3, 2), 'weighted': True}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3.8277635, -4.8277635]])
desired = array([[3.8277635, 4.8277635]]), rtol = 1e-05, atol = 0, err_msg = ''
verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 9.65552699
E       Max relative difference: 2.
E        x: array([[-3.827763, -4.827763]])
E        y: array([[3.827763, 4.827763]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestPolyfitCovMode_param_23_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weighted=False}.test_polyfit_cov _

self = <<cupy_tests.lib_tests.test_polynomial.TestPolyfitCovMode_param_23_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weight...} testMethod=test_polyfit_cov>  parameter: {'cov': True, 'deg': 0, 'rcond': 1e-15, 'shape': (3, 2), 'weighted': False}>
dtype = <class 'numpy.float64'>

    @testing.for_float_dtypes(no_float16=True)
    def test_polyfit_cov(self, dtype):
        cp_c, cp_cov = self._cov_fit(cupy, dtype)
        np_c, np_cov = self._cov_fit(numpy, dtype)
>       testing.assert_allclose(cp_c, np_c, rtol=1e-5)

tests/cupy_tests/lib_tests/test_polynomial.py:522: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[-3., -4.]]), desired = array([[3., 4.]]), rtol = 1e-05
atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 8.
E       Max relative difference: 2.
E        x: array([[-3., -4.]])
E        y: array([[3., 4.]])

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
__________ TestRootsReal_param_0_{input=[2, -1, -2]}.test_roots_array __________

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsReal_param_0_{input=[2, -1, -2]} testMethod=test_roots_array>  parameter: {'input': [2, -1, -2]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_array(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(a)

tests/cupy_tests/lib_tests/test_polynomial.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3089: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3098: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 764, in test_roots_array
E       out = xp.roots(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3089, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3098, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________ TestRootsReal_param_0_{input=[2, -1, -2]}.test_roots_poly1d __________

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsReal_param_0_{input=[2, -1, -2]} testMethod=test_roots_poly1d>  parameter: {'input': [2, -1, -2]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_poly1d(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(xp.poly1d(a))

tests/cupy_tests/lib_tests/test_polynomial.py:771: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3089: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3098: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 771, in test_roots_poly1d
E       out = xp.roots(xp.poly1d(a))
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3089, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3098, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
__________ TestRootsReal_param_1_{input=[-4, 10, 4]}.test_roots_array __________

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsReal_param_1_{input=[-4, 10, 4]} testMethod=test_roots_array>  parameter: {'input': [-4, 10, 4]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_array(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(a)

tests/cupy_tests/lib_tests/test_polynomial.py:764: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3089: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3098: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 764, in test_roots_array
E       out = xp.roots(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3089, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3098, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________ TestRootsReal_param_1_{input=[-4, 10, 4]}.test_roots_poly1d __________

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsReal_param_1_{input=[-4, 10, 4]} testMethod=test_roots_poly1d>  parameter: {'input': [-4, 10, 4]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_poly1d(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(xp.poly1d(a))

tests/cupy_tests/lib_tests/test_polynomial.py:771: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3089: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3098: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 771, in test_roots_poly1d
E       out = xp.roots(xp.poly1d(a))
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3089, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3098, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
____ TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]}.test_roots_array _____

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]} testMethod=test_roots_array>  parameter: {'input': [3j, 1.5j, (-0-3j)]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_complex_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_array(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(a)

tests/cupy_tests/lib_tests/test_polynomial.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3101: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3110: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 785, in test_roots_array
E       out = xp.roots(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3101, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3110, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
____ TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]}.test_roots_poly1d ____

self = <<cupy_tests.lib_tests.test_polynomial.TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]} testMethod=test_roots_poly1d>  parameter: {'input': [3j, 1.5j, (-0-3j)]}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_complex_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_roots_poly1d(self, xp, dtype):
        a = xp.array(self.input, dtype)
>       out = xp.roots(xp.poly1d(a))

tests/cupy_tests/lib_tests/test_polynomial.py:792: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3101: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3110: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 792, in test_roots_poly1d
E       out = xp.roots(xp.poly1d(a))
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3101, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3110, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
_________________________ TestPoly1d.test_poly1d_roots _________________________

self = <cupy_tests.lib_tests.test_polynomial.TestPoly1d testMethod=test_poly1d_roots>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_signed_dtypes()
    @testing.numpy_cupy_allclose(rtol=1e-6)
    def test_poly1d_roots(self, xp, dtype):
        a = xp.array([-3, -2.5, 3], dtype)
>       out = xp.poly1d(a).roots

tests/cupy_tests/lib_tests/test_polynomial.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/lib/_polynomial.pyx:63: in cupy.lib._polynomial.poly1d.roots.__get__
    return _routines_poly.roots(self._coeffs)
cupy/lib/_routines_poly.py:326: in roots
    out = cupy.linalg.eigvalsh(cmatrix)
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3089: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3098: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/lib_tests/test_polynomial.py", line 133, in test_poly1d_roots
E       out = xp.poly1d(a).roots
E     File "cupy/lib/_polynomial.pyx", line 63, in cupy.lib._polynomial.poly1d.roots.__get__
E       return _routines_poly.roots(self._coeffs)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/lib/_routines_poly.py", line 326, in roots
E       out = cupy.linalg.eigvalsh(cmatrix)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3089, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3098, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________________ TestEigenvalue_param_0_{UPLO='U'}.test_eigh __________________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_0_{UPLO='U'} testMethod=test_eigh>  parameter: {'UPLO': 'U'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True, no_complex=True)
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigh(self, xp, dtype):
        a = xp.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], dtype)
>       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3089: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3098: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 19, in test_eigh
E       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 133, in eigh
E       return _syevd(a, UPLO, True)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3089, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3098, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_____________ TestEigenvalue_param_0_{UPLO='U'}.test_eigh_complex ______________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_0_{UPLO='U'} testMethod=test_eigh_complex>  parameter: {'UPLO': 'U'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_dtypes('FD')
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigh_complex(self, xp, dtype):
        a = xp.array([[1, 2j, 3], [4j, 5, 6j], [7, 8j, 9]], dtype)
>       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3101: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3110: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 46, in test_eigh_complex
E       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 133, in eigh
E       return _syevd(a, UPLO, True)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3101, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3110, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is F
_____________ TestEigenvalue_param_0_{UPLO='U'}.test_eigh_float16 ______________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_0_{UPLO='U'} testMethod=test_eigh_float16>  parameter: {'UPLO': 'U'}>

    def test_eigh_float16(self):
        # NumPy's eigh deos not support float16
        a = cupy.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], 'e')
>       w, v = cupy.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3077: in cupy_backends.cuda.libs.cusolver.ssyevd_bufferSize
    cpdef int ssyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3086: in cupy_backends.cuda.libs.cusolver.ssyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: CUSOLVERError
_______________ TestEigenvalue_param_0_{UPLO='U'}.test_eigvalsh ________________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_0_{UPLO='U'} testMethod=test_eigvalsh>  parameter: {'UPLO': 'U'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True, no_complex=True)
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigvalsh(self, xp, dtype):
        a = xp.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], dtype)
>       w = xp.linalg.eigvalsh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3089: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3098: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 59, in test_eigvalsh
E       w = xp.linalg.eigvalsh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3089, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3098, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_________________ TestEigenvalue_param_1_{UPLO='L'}.test_eigh __________________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_1_{UPLO='L'} testMethod=test_eigh>  parameter: {'UPLO': 'L'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True, no_complex=True)
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigh(self, xp, dtype):
        a = xp.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], dtype)
>       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3089: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3098: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 19, in test_eigh
E       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 133, in eigh
E       return _syevd(a, UPLO, True)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3089, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3098, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_____________ TestEigenvalue_param_1_{UPLO='L'}.test_eigh_complex ______________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_1_{UPLO='L'} testMethod=test_eigh_complex>  parameter: {'UPLO': 'L'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_dtypes('FD')
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigh_complex(self, xp, dtype):
        a = xp.array([[1, 2j, 3], [4j, 5, 6j], [7, 8j, 9]], dtype)
>       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3101: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3110: in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 46, in test_eigh_complex
E       w, v = xp.linalg.eigh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 133, in eigh
E       return _syevd(a, UPLO, True)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3101, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       cpdef int cheevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3110, in cupy_backends.cuda.libs.cusolver.cheevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is F
_____________ TestEigenvalue_param_1_{UPLO='L'}.test_eigh_float16 ______________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_1_{UPLO='L'} testMethod=test_eigh_float16>  parameter: {'UPLO': 'L'}>

    def test_eigh_float16(self):
        # NumPy's eigh deos not support float16
        a = cupy.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], 'e')
>       w, v = cupy.linalg.eigh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:133: in eigh
    return _syevd(a, UPLO, True)
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3077: in cupy_backends.cuda.libs.cusolver.ssyevd_bufferSize
    cpdef int ssyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3086: in cupy_backends.cuda.libs.cusolver.ssyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: CUSOLVERError
_______________ TestEigenvalue_param_1_{UPLO='L'}.test_eigvalsh ________________

self = <<cupy_tests.linalg_tests.test_eigenvalue.TestEigenvalue_param_1_{UPLO='L'} testMethod=test_eigvalsh>  parameter: {'UPLO': 'L'}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.float64'>

    @testing.for_all_dtypes(no_float16=True, no_complex=True)
    @testing.numpy_cupy_allclose(rtol=1e-3, atol=1e-4)
    def test_eigvalsh(self, xp, dtype):
        a = xp.array([[1, 0, 3], [0, 5, 0], [7, 0, 9]], dtype)
>       w = xp.linalg.eigvalsh(a, UPLO=self.UPLO)

tests/cupy_tests/linalg_tests/test_eigenvalue.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/linalg/_eigenvalue.py:176: in eigvalsh
    return _syevd(a, UPLO, False)[0]
cupy/linalg/_eigenvalue.py:79: in _syevd
    work_size = buffer_size(
cupy_backends/cuda/libs/cusolver.pyx:3089: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
cupy_backends/cuda/libs/cusolver.pyx:3098: in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/linalg_tests/test_eigenvalue.py", line 59, in test_eigvalsh
E       w = xp.linalg.eigvalsh(a, UPLO=self.UPLO)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 176, in eigvalsh
E       return _syevd(a, UPLO, False)[0]
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/linalg/_eigenvalue.py", line 79, in _syevd
E       work_size = buffer_size(
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3089, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       cpdef int dsyevd_bufferSize(intptr_t handle, int jobz, int uplo, int n,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 3098, in cupy_backends.cuda.libs.cusolver.dsyevd_bufferSize
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestEinSumUnaryOperation_param_34_{_raw_params={'orig': {'shape_a': (3, 3, 3), 'subscripts': 'iji->ij'}, 'dec': 0, 'drop': True}, shape_a=(1, 1, 1), subscripts='iji->ij'}.test_einsum_unary_dtype _
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1]], dtype=uint64), desired = array([[1]], dtype=uint64)
rtol = 1e-07, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 4575657222473777152
E       Max relative difference: 4.57565722e+18
E        x: array([[4575657222473777153]], dtype=uint64)
E        y: array([[1]], dtype=uint64)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
skipped: dtype_a = <class 'numpy.longlong'>, dtype_out = <class 'numpy.float16'> ()
skipped: dtype_a = <class 'numpy.uint16'>, dtype_out = <class 'numpy.bool_'> ()
skipped: dtype_a = <class 'numpy.int64'>, dtype_out = <class 'numpy.float32'> ()
{'dtype_a': <class 'numpy.uint64'>, 'dtype_out': <class 'numpy.uint64'>}
______ TestBroadcast_param_2_{shapes=[(1,), (1,)]}.test_broadcast_arrays _______
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([1.], dtype=float16), y = array([1.], dtype=float16), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 1.
E       Max relative difference: 1.
E        x: array([0.], dtype=float16)
E        y: array([1.], dtype=float16)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float16'>
______ TestBroadcast_param_3_{shapes=[(2,), (2,)]}.test_broadcast_arrays _______
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:648: in check_func
    array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([1, 2], dtype=int8), y = array([1, 2], dtype=int8), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 2
E       Max relative difference: 1.
E        x: array([0, 0], dtype=int8)
E        y: array([1, 2], dtype=int8)

cupy/testing/array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________ TestConvolve_param_0_{mode='valid'}.test_convolve_diff_types _________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([1045,  867, 1025,  808,  989, 1042,  917, 1103, 1068, 1295, 1296,
       1352, 1270, 1202, 1091, 1106,  910, 11... 1291, 1280,
       1286, 1284, 1311, 1245, 1263, 1260, 1205, 1202, 1305, 1124, 1140,
       1117, 1081], dtype=uint16)
desired = array([1712, 1595, 1954, 1583, 1842, 1710, 1580, 1848, 1666, 1882, 1782,
       1942, 1900, 1759, 1665, 1742, 1656, 18... 1953, 2078,
       2088, 1992, 2065, 1919, 2018, 1950, 1988, 2033, 2120, 2024, 1898,
       1863, 1881], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 101 / 101 (100%)
E       Max absolute difference: 65050
E       Max relative difference: 41.05886076
E        x: array([1045,  867, 1025,  808,  989, 1042,  917, 1103, 1068, 1295, 1296,
E              1352, 1270, 1202, 1091, 1106,  910, 1102,  924, 1085,  979, 1132,
E              1031, 1250, 1172, 1272, 1243, 1302, 1165, 1182, 1138, 1243,  973,...
E        y: array([1712, 1595, 1954, 1583, 1842, 1710, 1580, 1848, 1666, 1882, 1782,
E              1942, 1900, 1759, 1665, 1742, 1656, 1899, 1655, 1886, 1717, 1834,
E              1810, 1965, 1786, 1984, 1836, 1857, 1729, 1906, 1814, 1875, 1770,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
_________ TestConvolve_param_1_{mode='same'}.test_convolve_diff_types __________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([ 725,  700,  567,  719,  629,  666,  695,  750,  769,  896,  944,
        878,  755,  799,  766,  734,  792,  6...  686,  724,
        704,  628,  570,  453,  523,  387,  476,  279,  436,  434,  509,
        432,  436], dtype=uint16)
desired = array([1186, 1250, 1116, 1291, 1128, 1205, 1250, 1297, 1302, 1412, 1310,
       1248, 1164, 1305, 1302, 1266, 1254, 11... 1155, 1070,
       1184, 1005, 1062,  886,  978,  810,  859,  788,  874,  807,  865,
        799,  738], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 200 / 200 (100%)
E       Max absolute difference: 65234
E       Max relative difference: 88.39295393
E        x: array([ 725,  700,  567,  719,  629,  666,  695,  750,  769,  896,  944,
E               878,  755,  799,  766,  734,  792,  674,  645,  618,  815,  730,
E               829,  931, 1056, 1006, 1144, 1060, 1098, 1025, 1079,  940,  976,...
E        y: array([1186, 1250, 1116, 1291, 1128, 1205, 1250, 1297, 1302, 1412, 1310,
E              1248, 1164, 1305, 1302, 1266, 1254, 1179, 1226, 1226, 1478, 1354,
E              1412, 1416, 1612, 1478, 1652, 1487, 1546, 1446, 1618, 1433, 1540,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
_________ TestConvolve_param_2_{mode='full'}.test_convolve_diff_types __________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([  25,   70,  109,  134,  146,  176,  197,  248,  326,  340,  368,
        386,  393,  406,  371,  371,  310,  3...  129,  102,
         48,   38,   48,   12,   24,    0,    0,    0,    0,    0,    0,
          0,    0], dtype=uint16)
desired = array([  25,   70,  109,  134,  146,  176,  197,  248,  326,  340,  368,
        386,  418,  486,  464,  450,  375,  4...  228,  180,
        193,  144,  130,  104,   89,  102,   96,   50,   20,   36,    0,
         32,    0], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 285 / 299 (95.3%)
E       Max absolute difference: 65516
E       Max relative difference: 3275.8
E        x: array([  25,   70,  109,  134,  146,  176,  197,  248,  326,  340,  368,
E               386,  393,  406,  371,  371,  310,  312,  380,  345,  424,  477,
E               449,  494,  483,  522,  515,  639,  734,  624,  638,  584,  564,...
E        y: array([  25,   70,  109,  134,  146,  176,  197,  248,  326,  340,  368,
E               386,  418,  486,  464,  450,  375,  418,  545,  558,  679,  688,
E               627,  688,  693,  772,  747,  788,  872,  850,  960,  888,  874,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
__________________ TestRational.test_lcm_check_boundary_cases __________________

self = <cupy_tests.math_tests.test_rational.TestRational testMethod=test_lcm_check_boundary_cases>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>
dtype = <class 'numpy.int8'>

    @testing.for_int_dtypes(no_bool=True)
    @testing.numpy_cupy_array_equal()
    def test_lcm_check_boundary_cases(self, xp, dtype):
        a = xp.array([0, -10, -5, 10, 410, 1, 6, 33])
        b = xp.array([0, 5, -10, -5, 20, 51, 6, 42])
>       return xp.lcm(a, b)

tests/cupy_tests/math_tests/test_rational.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/core/_kernel.pyx:1103: in cupy.core._kernel.ufunc.__call__
    kern = self._get_ufunc_kernel(dev_id, op, arginfos)
cupy/core/_kernel.pyx:1126: in cupy.core._kernel.ufunc._get_ufunc_kernel
    kern = _get_ufunc_kernel(
cupy/core/_kernel.pyx:900: in cupy.core._kernel._get_ufunc_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2019: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:406: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:787: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:249: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:233: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f1f8d9a6a00>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/core/include', '-I/opt/rocm/include', '-arch=compute_gfx906')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           AssertionError: Only cupy raises error
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 601, in compile
E               nvrtc.compileProgram(self.ptr, options)
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 116, in cupy_backends.cuda.libs.nvrtc.compileProgram
E               cpdef compileProgram(intptr_t prog, options):
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 128, in cupy_backends.cuda.libs.nvrtc.compileProgram
E               check_status(status)
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 62, in cupy_backends.cuda.libs.nvrtc.check_status
E               raise NVRTCError(status)
E           cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)
E           
E           During handling of the above exception, another exception occurred:
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E               result = impl(self, *args, **kw)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/math_tests/test_rational.py", line 38, in test_lcm_check_boundary_cases
E               return xp.lcm(a, b)
E             File "cupy/core/_kernel.pyx", line 1103, in cupy.core._kernel.ufunc.__call__
E               kern = self._get_ufunc_kernel(dev_id, op, arginfos)
E             File "cupy/core/_kernel.pyx", line 1126, in cupy.core._kernel.ufunc._get_ufunc_kernel
E               kern = _get_ufunc_kernel(
E             File "cupy/core/_kernel.pyx", line 900, in cupy.core._kernel._get_ufunc_kernel
E               return _get_simple_elementwise_kernel(
E             File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
E               module = compile_with_cache(module_code, options)
E             File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
E               return cuda.compile_with_cache(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
E               return _compile_with_cache_hip(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 787, in _compile_with_cache_hip
E               binary, mapping = compile_using_nvrtc(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 249, in compile_using_nvrtc
E               return _compile(source, options, cu_path,
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 233, in _compile
E               ptx, mapping = prog.compile(options, log_stream)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/cuda/compiler.py", line 613, in compile
E               raise CompileException(log, self.src, self.name, options,
E           cupy.cuda.compiler.CompileException: /tmp/comgr-d5df14/input/CompileSource:5361:9: error: call to function 'gcd' that is neither visible in the template definition nor found by argument-dependent lookup
E             T r = gcd(in0, in1);
E                   ^
E           /tmp/comgr-d5df14/input/CompileSource:5389:8: note: in instantiation of function template specialization 'lcm<long long>' requested here
E           out0 = lcm(in0, in1);
E                  ^
E           /tmp/comgr-d5df14/input/CompileSource:5370:43: note: 'gcd' should be declared prior to the call site
E           template <typename T> inline __device__ T gcd(T in0, T in1) {
E                                                     ^
E           1 error generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:613: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
_________________________ TestRandomState.test_methods _________________________

self = <cupy_tests.random_tests.test_generator.TestRandomState testMethod=test_methods>

    def test_methods(self):
        methods = [
            cuda.curand.CURAND_RNG_PSEUDO_DEFAULT,
            cuda.curand.CURAND_RNG_PSEUDO_MRG32K3A,
            cupy.cuda.curand.CURAND_RNG_PSEUDO_MT19937,
            cupy.cuda.curand.CURAND_RNG_PSEUDO_PHILOX4_32_10,
            cupy.cuda.curand.CURAND_RNG_PSEUDO_MTGP32,
            cupy.cuda.curand.CURAND_RNG_PSEUDO_XORWOW
        ]
    
        for method in methods:
>           rs = cupy.random.RandomState(method=method)

tests/cupy_tests/random_tests/test_generator.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/random/_generator.py:57: in __init__
    self._generator = curand.createGenerator(method)
cupy_backends/cuda/libs/curand.pyx:93: in cupy_backends.cuda.libs.curand.createGenerator
    cpdef size_t createGenerator(int rng_type) except? 0:
cupy_backends/cuda/libs/curand.pyx:97: in cupy_backends.cuda.libs.curand.createGenerator
    check_status(status)
cupy_backends/cuda/libs/curand.pyx:86: in cupy_backends.cuda.libs.curand.check_status
    raise CURANDError(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   super(CURANDError, self).__init__(STATUS[status])
E   KeyError: 1000

cupy_backends/cuda/libs/curand.pyx:77: KeyError
_____________________ TestChoiceChi.test_goodness_of_fit_2 _____________________
cupy/testing/condition.py:79: in wrapper
    fail()
cupy/testing/condition.py:50: in fail
    instance.fail(msg)
E   AssertionError: 
E   Fail: 1, Success: 4
E   
E   The first error message:
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/condition.py", line 59, in <lambda>
E       lambda: f(ins, *args[1:], **kwargs),
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/random_tests/test_generator.py", line 1080, in test_goodness_of_fit_2
E       assert hypothesis.chi_square_test(counts, expected)
E   AssertionError: assert False
E    +  where False = <function chi_square_test at 0x7f20d3023430>(array([17, 33, 50]), array([30, 30, 40]))
E    +    where <function chi_square_test at 0x7f20d3023430> = hypothesis.chi_square_test
_____________________ TestRandint2.test_goodness_of_fit_2 ______________________
cupy/testing/condition.py:79: in wrapper
    fail()
cupy/testing/condition.py:50: in fail
    instance.fail(msg)
E   AssertionError: 
E   Fail: 1, Success: 3
E   
E   The first error message:
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/condition.py", line 59, in <lambda>
E       lambda: f(ins, *args[1:], **kwargs),
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/random_tests/test_sample.py", line 106, in test_goodness_of_fit_2
E       assert hypothesis.chi_square_test(counts, expected)
E   AssertionError: assert False
E    +  where False = <function chi_square_test at 0x7f20d3023430>(array([21, 21, 11, 30, 17]), array([20., 20., 20., 20., 20.]))
E    +    where <function chi_square_test at 0x7f20d3023430> = hypothesis.chi_square_test
__________________ TestRandomIntegers2.test_goodness_of_fit_2 __________________
cupy/testing/condition.py:79: in wrapper
    fail()
cupy/testing/condition.py:50: in fail
    instance.fail(msg)
E   AssertionError: 
E   Fail: 1, Success: 3
E   
E   The first error message:
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/condition.py", line 59, in <lambda>
E       lambda: f(ins, *args[1:], **kwargs),
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/random_tests/test_sample.py", line 201, in test_goodness_of_fit_2
E       assert hypothesis.chi_square_test(counts, expected)
E   AssertionError: assert False
E    +  where False = <function chi_square_test at 0x7f20d3023430>(array([21, 21, 11, 30, 17]), array([20., 20., 20., 20., 20.]))
E    +    where <function chi_square_test at 0x7f20d3023430> = hypothesis.chi_square_test
________ TestCorrelate_param_0_{mode='valid'}.test_correlate_diff_types ________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([1191,  651,  779,  562,  751,  745,  693,  862,  864,  936, 1027,
        988,  962,  827,  937,  817,  832,  8...  888,  891,
        942, 1035, 1029, 1037, 1013, 1027,  923, 1029,  944,  889,  908,
        874,  863], dtype=uint16)
desired = array([2592, 1718, 1987, 1649, 1849, 1731, 1795, 1760, 1768, 1660, 1897,
       1677, 1809, 1717, 1837, 1735, 1847, 18... 1964, 1901,
       1937, 2021, 2012, 2070, 2067, 2075, 1921, 2122, 1994, 2076, 2045,
       2048, 1965], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 101 / 101 (100%)
E       Max absolute difference: 64847
E       Max relative difference: 42.19661458
E        x: array([1191,  651,  779,  562,  751,  745,  693,  862,  864,  936, 1027,
E               988,  962,  827,  937,  817,  832,  837,  814,  740,  794,  842,
E               771,  822,  895,  956,  943,  996,  946,  983,  890,  912,  824,...
E        y: array([2592, 1718, 1987, 1649, 1849, 1731, 1795, 1760, 1768, 1660, 1897,
E              1677, 1809, 1717, 1837, 1735, 1847, 1829, 1986, 1817, 1897, 1825,
E              1697, 1752, 1698, 1794, 1725, 1754, 1791, 1757, 1813, 1836, 1871,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
________ TestCorrelate_param_1_{mode='full'}.test_correlate_diff_types _________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([   0,   40,   56,   73,   80,   79,  128,  123,  187,  204,  215,
        299,  242,  279,  284,  208,  256,  1...  150,  135,
         76,   44,   46,   12,   36,    0,    0,    0,    0,    0,    0,
          0,    0], dtype=uint16)
desired = array([   0,   40,   56,   73,   80,   79,  128,  123,  187,  204,  215,
        299,  242,  304,  329,  277,  358,  3...  326,  352,
        289,  246,  209,  168,  178,  182,  152,  109,   62,   44,   34,
         28,   20], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 286 / 299 (95.7%)
E       Max absolute difference: 65516
E       Max relative difference: 3275.8
E        x: array([   0,   40,   56,   73,   80,   79,  128,  123,  187,  204,  215,
E               299,  242,  279,  284,  208,  256,  198,  294,  247,  241,  281,
E               241,  295,  252,  230,  347,  386,  508,  431,  419,  397,  372,...
E        y: array([   0,   40,   56,   73,   80,   79,  128,  123,  187,  204,  215,
E               299,  242,  304,  329,  277,  358,  300,  413,  372,  388,  436,
E               369,  465,  394,  362,  529,  498,  640,  599,  581,  613,  610,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
______ TestCorrelate_param_1_{mode='full'}.test_correlate_non_contiguous _______
cupy/testing/helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([   81., 16290.,  2210.], dtype=float16)
desired = array([   81., 16290.,  2212.], dtype=float16), rtol = 1e-05, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=0
E       
E       Mismatched elements: 1 / 3 (33.3%)
E       Max absolute difference: 2.
E       Max relative difference: 0.000904
E        x: array([   81., 16290.,  2210.], dtype=float16)
E        y: array([   81., 16290.,  2212.], dtype=float16)

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float16'>
________ TestCorrelate_param_2_{mode='same'}.test_correlate_diff_types _________
cupy/testing/helper.py:1068: in test_func
    impl(self, *args, **kw_copy)
cupy/testing/helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/helper.py:495: in check_func
    array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([ 433,  490,  366,  409,  436,  493,  492,  480,  470,  565,  534,
        624,  543,  675,  595,  583,  563,  5...  630,  677,
        696,  535,  532,  515,  451,  370,  561,  359,  416,  370,  467,
        401,  460], dtype=uint16)
desired = array([ 830,  945,  881,  917,  878, 1017,  923,  963,  887, 1009,  869,
       1113,  956, 1121, 1006, 1164, 1110, 11... 1371, 1450,
       1441, 1328, 1307, 1264, 1253, 1280, 1404, 1213, 1263, 1154, 1182,
       1070, 1101], dtype=uint16)
rtol = 0.01, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.01, atol=0
E       
E       Mismatched elements: 200 / 200 (100%)
E       Max absolute difference: 65201
E       Max relative difference: 78.48072289
E        x: array([ 433,  490,  366,  409,  436,  493,  492,  480,  470,  565,  534,
E               624,  543,  675,  595,  583,  563,  521,  511,  502,  507,  487,
E               611,  663,  662,  740,  800,  852,  778,  827,  800,  709,  739,...
E        y: array([ 830,  945,  881,  917,  878, 1017,  923,  963,  887, 1009,  869,
E              1113,  956, 1121, 1006, 1164, 1110, 1166, 1208, 1237, 1192, 1168,
E              1257, 1258, 1229, 1331, 1295, 1301, 1283, 1427, 1478, 1466, 1603,...

cupy/testing/array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
{'dtype1': <class 'numpy.uint16'>, 'dtype2': <class 'numpy.uint16'>}
______________ TestInvh_param_0_{dtype=float32, size=5}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_0_{dtype=float32, size=5} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float32'>, 'size': 5}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1233: in cupy_backends.cuda.libs.cusolver.spotrs
    cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1241: in cupy_backends.cuda.libs.cusolver.spotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1233, in cupy_backends.cuda.libs.cusolver.spotrs
E       cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1241, in cupy_backends.cuda.libs.cusolver.spotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
______________ TestInvh_param_1_{dtype=float32, size=9}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_1_{dtype=float32, size=9} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float32'>, 'size': 9}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1233: in cupy_backends.cuda.libs.cusolver.spotrs
    cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1241: in cupy_backends.cuda.libs.cusolver.spotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1233, in cupy_backends.cuda.libs.cusolver.spotrs
E       cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1241, in cupy_backends.cuda.libs.cusolver.spotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_2_{dtype=float32, size=17}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_2_{dtype=float32, size=17} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float32'>, 'size': 17}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1233: in cupy_backends.cuda.libs.cusolver.spotrs
    cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1241: in cupy_backends.cuda.libs.cusolver.spotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1233, in cupy_backends.cuda.libs.cusolver.spotrs
E       cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1241, in cupy_backends.cuda.libs.cusolver.spotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_3_{dtype=float32, size=33}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_3_{dtype=float32, size=33} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float32'>, 'size': 33}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1233: in cupy_backends.cuda.libs.cusolver.spotrs
    cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1241: in cupy_backends.cuda.libs.cusolver.spotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1233, in cupy_backends.cuda.libs.cusolver.spotrs
E       cpdef spotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1241, in cupy_backends.cuda.libs.cusolver.spotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
______________ TestInvh_param_4_{dtype=float64, size=5}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_4_{dtype=float64, size=5} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float64'>, 'size': 5}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1243: in cupy_backends.cuda.libs.cusolver.dpotrs
    cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1251: in cupy_backends.cuda.libs.cusolver.dpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1243, in cupy_backends.cuda.libs.cusolver.dpotrs
E       cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1251, in cupy_backends.cuda.libs.cusolver.dpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
______________ TestInvh_param_5_{dtype=float64, size=9}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_5_{dtype=float64, size=9} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float64'>, 'size': 9}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1243: in cupy_backends.cuda.libs.cusolver.dpotrs
    cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1251: in cupy_backends.cuda.libs.cusolver.dpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1243, in cupy_backends.cuda.libs.cusolver.dpotrs
E       cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1251, in cupy_backends.cuda.libs.cusolver.dpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_6_{dtype=float64, size=17}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_6_{dtype=float64, size=17} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float64'>, 'size': 17}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1243: in cupy_backends.cuda.libs.cusolver.dpotrs
    cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1251: in cupy_backends.cuda.libs.cusolver.dpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1243, in cupy_backends.cuda.libs.cusolver.dpotrs
E       cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1251, in cupy_backends.cuda.libs.cusolver.dpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_7_{dtype=float64, size=33}.test_invh ______________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_7_{dtype=float64, size=33} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.float64'>, 'size': 33}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1243: in cupy_backends.cuda.libs.cusolver.dpotrs
    cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1251: in cupy_backends.cuda.libs.cusolver.dpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1243, in cupy_backends.cuda.libs.cusolver.dpotrs
E       cpdef dpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1251, in cupy_backends.cuda.libs.cusolver.dpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_8_{dtype=complex64, size=5}.test_invh _____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_8_{dtype=complex64, size=5} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex64'>, 'size': 5}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1253: in cupy_backends.cuda.libs.cusolver.cpotrs
    cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1261: in cupy_backends.cuda.libs.cusolver.cpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1253, in cupy_backends.cuda.libs.cusolver.cpotrs
E       cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1261, in cupy_backends.cuda.libs.cusolver.cpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestInvh_param_9_{dtype=complex64, size=9}.test_invh _____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_9_{dtype=complex64, size=9} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex64'>, 'size': 9}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1253: in cupy_backends.cuda.libs.cusolver.cpotrs
    cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1261: in cupy_backends.cuda.libs.cusolver.cpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1253, in cupy_backends.cuda.libs.cusolver.cpotrs
E       cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1261, in cupy_backends.cuda.libs.cusolver.cpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
____________ TestInvh_param_10_{dtype=complex64, size=17}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_10_{dtype=complex64, size=17} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex64'>, 'size': 17}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1253: in cupy_backends.cuda.libs.cusolver.cpotrs
    cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1261: in cupy_backends.cuda.libs.cusolver.cpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1253, in cupy_backends.cuda.libs.cusolver.cpotrs
E       cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1261, in cupy_backends.cuda.libs.cusolver.cpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
____________ TestInvh_param_11_{dtype=complex64, size=33}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_11_{dtype=complex64, size=33} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex64'>, 'size': 33}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1253: in cupy_backends.cuda.libs.cusolver.cpotrs
    cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1261: in cupy_backends.cuda.libs.cusolver.cpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1253, in cupy_backends.cuda.libs.cusolver.cpotrs
E       cpdef cpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1261, in cupy_backends.cuda.libs.cusolver.cpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
____________ TestInvh_param_12_{dtype=complex128, size=5}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_12_{dtype=complex128, size=5} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex128'>, 'size': 5}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1263: in cupy_backends.cuda.libs.cusolver.zpotrs
    cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1271: in cupy_backends.cuda.libs.cusolver.zpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1263, in cupy_backends.cuda.libs.cusolver.zpotrs
E       cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1271, in cupy_backends.cuda.libs.cusolver.zpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
____________ TestInvh_param_13_{dtype=complex128, size=9}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_13_{dtype=complex128, size=9} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex128'>, 'size': 9}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1263: in cupy_backends.cuda.libs.cusolver.zpotrs
    cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1271: in cupy_backends.cuda.libs.cusolver.zpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1263, in cupy_backends.cuda.libs.cusolver.zpotrs
E       cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1271, in cupy_backends.cuda.libs.cusolver.zpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
___________ TestInvh_param_14_{dtype=complex128, size=17}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_14_{dtype=complex128, size=17} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex128'>, 'size': 17}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1263: in cupy_backends.cuda.libs.cusolver.zpotrs
    cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1271: in cupy_backends.cuda.libs.cusolver.zpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1263, in cupy_backends.cuda.libs.cusolver.zpotrs
E       cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1271, in cupy_backends.cuda.libs.cusolver.zpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
___________ TestInvh_param_15_{dtype=complex128, size=33}.test_invh ____________

self = <<cupyx_tests.linalg_tests.test_solve.TestInvh_param_15_{dtype=complex128, size=33} testMethod=test_invh>  parameter: {'dtype': <class 'numpy.complex128'>, 'size': 33}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_allclose(atol=1e-5)
    def test_invh(self, xp):
        a = self._create_symmetric_matrix(xp, self.size, self.dtype)
        if xp == cupy:
>           return cupyx.linalg.invh(a)

tests/cupyx_tests/linalg_tests/test_solve.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/linalg/_solve.py:31: in invh
    return lapack.posv(a, b)
cupyx/lapack.py:335: in posv
    potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
cupy_backends/cuda/libs/cusolver.pyx:1263: in cupy_backends.cuda.libs.cusolver.zpotrs
    cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
cupy_backends/cuda/libs/cusolver.pyx:1271: in cupy_backends.cuda.libs.cusolver.zpotrs
    check_status(status)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise CUSOLVERError(status)
E   AssertionError: Only cupy raises error
E   
E   Traceback (most recent call last):
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupy/testing/helper.py", line 47, in _call_func
E       result = impl(self, *args, **kw)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupyx_tests/linalg_tests/test_solve.py", line 23, in test_invh
E       return cupyx.linalg.invh(a)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/linalg/_solve.py", line 31, in invh
E       return lapack.posv(a, b)
E     File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/cupyx/lapack.py", line 335, in posv
E       potrs(handle, uplo, n, nrhs, a.data.ptr, lda, b.data.ptr, ldb,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1263, in cupy_backends.cuda.libs.cusolver.zpotrs
E       cpdef zpotrs(intptr_t handle, int uplo, int n, int nrhs,
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1271, in cupy_backends.cuda.libs.cusolver.zpotrs
E       check_status(status)
E     File "cupy_backends/cuda/libs/cusolver.pyx", line 1050, in cupy_backends.cuda.libs.cusolver.check_status
E       raise CUSOLVERError(status)
E   cupy_backends.cuda.libs.cusolver.CUSOLVERError: rocblas_status_not_implemented

cupy_backends/cuda/libs/cusolver.pyx:1050: AssertionError
_____________ TestVstack_param_0_{dtype=float32}.test_basic_vstack _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_0_{dtype=float32} testMethod=test_basic_vstack>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_basic_vstack(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A, B]).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/base.py:524: in todense
    return self.toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 94,662,786,669,568 bytes (allocated so far: 132,170,752 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________________ TestVstack_param_0_{dtype=float32}.test_csr __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_0_{dtype=float32} testMethod=test_csr>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_csr(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A.tocsr(), B.tocsr()]).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
____________ TestVstack_param_0_{dtype=float32}.test_csr_with_dtype ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_0_{dtype=float32} testMethod=test_csr_with_dtype>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_csr_with_dtype(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A.tocsr(), B.tocsr()],
                                  dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____________ TestVstack_param_1_{dtype=float64}.test_basic_vstack _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_1_{dtype=float64} testMethod=test_basic_vstack>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_basic_vstack(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A, B]).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/base.py:524: in todense
    return self.toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_________________ TestVstack_param_1_{dtype=float64}.test_csr __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_1_{dtype=float64} testMethod=test_csr>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_csr(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A.tocsr(), B.tocsr()]).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
____________ TestVstack_param_1_{dtype=float64}.test_csr_with_dtype ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestVstack_param_1_{dtype=float64} testMethod=test_csr_with_dtype>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_csr_with_dtype(self):
    
        A, B = self.data()
    
>       actual = construct.vstack([A.tocsr(), B.tocsr()],
                                  dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____________ TestHstack_param_0_{dtype=float32}.test_basic_hstack _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_0_{dtype=float32} testMethod=test_basic_hstack>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_basic_hstack(self):
    
        A, B = self.data()
>       actual = construct.hstack([A, B], dtype=self.dtype).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/base.py:524: in todense
    return self.toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_________________ TestHstack_param_0_{dtype=float32}.test_csc __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_0_{dtype=float32} testMethod=test_csc>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_csc(self):
        A, B = self.data()
>       actual = construct.hstack([A.tocsc(), B.tocsc()],
                                  dtype=self.dtype).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
____________ TestHstack_param_0_{dtype=float32}.test_csc_with_dtype ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_0_{dtype=float32} testMethod=test_csc_with_dtype>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_csc_with_dtype(self):
    
        A, B = self.data()
    
>       actual = construct.hstack([A.tocsc(), B.tocsc()],
                                  dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____________ TestHstack_param_1_{dtype=float64}.test_basic_hstack _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_1_{dtype=float64} testMethod=test_basic_hstack>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_basic_hstack(self):
    
        A, B = self.data()
>       actual = construct.hstack([A, B], dtype=self.dtype).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/base.py:524: in todense
    return self.toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_________________ TestHstack_param_1_{dtype=float64}.test_csc __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_1_{dtype=float64} testMethod=test_csc>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_csc(self):
        A, B = self.data()
>       actual = construct.hstack([A.tocsc(), B.tocsc()],
                                  dtype=self.dtype).todense()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
____________ TestHstack_param_1_{dtype=float64}.test_csc_with_dtype ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestHstack_param_1_{dtype=float64} testMethod=test_csc_with_dtype>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_csc_with_dtype(self):
    
        A, B = self.data()
    
>       actual = construct.hstack([A.tocsc(), B.tocsc()],
                                  dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
______________ TestBmat_param_0_{dtype=float32}.test_basic_inputs ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_0_{dtype=float32} testMethod=test_basic_inputs>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_basic_inputs(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:174: in data
    B = sparse.csr_matrix(cupy.asarray([[5], [6]],
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f1f8c19b820>
arg1 = (array([-0.372549, -0.372549, -0.372549, ..., -0.372549, -0.372549,
       -0.372549], dtype=float32), (array([-109479...nt32), array([-1094795586, -1094795586, -1094795586, ..., -1094795586,
       -1094795586, -1094795586], dtype=int32)))
shape = (2, 1), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
                raise ValueError('column index exceeds matrix dimensions')
            if row.min() < 0:
>               raise ValueError('negative row index found')
E               ValueError: negative row index found

cupyx/scipy/sparse/coo.py:161: ValueError
_______________ TestBmat_param_0_{dtype=float32}.test_edge_cases _______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_0_{dtype=float32} testMethod=test_edge_cases>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_edge_cases(self):
        """Catch-all for small edge cases"""
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:174: in data
    B = sparse.csr_matrix(cupy.asarray([[5], [6]],
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f2af636d670>
arg1 = (array([-0.372549, -0.372549, -0.372549, ..., -0.372549, -0.372549,
       -0.372549], dtype=float32), (array([-109479...nt32), array([-1094795586, -1094795586, -1094795586, ..., -1094795586,
       -1094795586, -1094795586], dtype=int32)))
shape = (2, 1), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
                raise ValueError('column index exceeds matrix dimensions')
            if row.min() < 0:
>               raise ValueError('negative row index found')
E               ValueError: negative row index found

cupyx/scipy/sparse/coo.py:161: ValueError
_________________ TestBmat_param_0_{dtype=float32}.test_empty __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_0_{dtype=float32} testMethod=test_empty>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_empty(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:174: in data
    B = sparse.csr_matrix(cupy.asarray([[5], [6]],
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f20c3930d60>
arg1 = (array([-0.372549, -0.372549, -0.372549, ..., -0.372549, -0.372549,
       -0.372549], dtype=float32), (array([-109479...nt32), array([-1094795586, -1094795586, -1094795586, ..., -1094795586,
       -1094795586, -1094795586], dtype=int32)))
shape = (2, 1), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
>               raise ValueError('column index exceeds matrix dimensions')
E               ValueError: column index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:159: ValueError
_____________ TestBmat_param_0_{dtype=float32}.test_failure_cases ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_0_{dtype=float32} testMethod=test_failure_cases>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_failure_cases(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:174: in data
    B = sparse.csr_matrix(cupy.asarray([[5], [6]],
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f2af6264670>
arg1 = (array([-0.372549, -0.372549, -0.372549, ..., -0.372549, -0.372549,
       -0.372549], dtype=float32), (array([-109479...nt32), array([-1094795586, -1094795586, -1094795586, ..., -1094795586,
       -1094795586, -1094795586], dtype=int32)))
shape = (2, 1), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
                raise ValueError('column index exceeds matrix dimensions')
            if row.min() < 0:
>               raise ValueError('negative row index found')
E               ValueError: negative row index found

cupyx/scipy/sparse/coo.py:161: ValueError
______________ TestBmat_param_1_{dtype=float64}.test_basic_inputs ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_1_{dtype=float64} testMethod=test_basic_inputs>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_basic_inputs(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:172: in data
    A = sparse.csr_matrix(cupy.asarray([[1, 2], [3, 4]],
cupyx/scipy/sparse/compressed.py:389: in __init__
    data, indices, indptr = self._convert_dense(arg1)
cupyx/scipy/sparse/csr.py:76: in _convert_dense
    m = dense2csr(x)
cupyx/scipy/sparse/csr.py:1117: in dense2csr
    return cusparse.dense2csr(a)
cupy/cusparse.py:1132: in dense2csr
    data = _cupy.empty(nnz, x.dtype)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise ValueError('Negative dimensions are not allowed')
E   ValueError: Negative dimensions are not allowed

cupy/core/core.pyx:142: ValueError
_______________ TestBmat_param_1_{dtype=float64}.test_edge_cases _______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_1_{dtype=float64} testMethod=test_edge_cases>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_edge_cases(self):
        """Catch-all for small edge cases"""
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:172: in data
    A = sparse.csr_matrix(cupy.asarray([[1, 2], [3, 4]],
cupyx/scipy/sparse/compressed.py:389: in __init__
    data, indices, indptr = self._convert_dense(arg1)
cupyx/scipy/sparse/csr.py:76: in _convert_dense
    m = dense2csr(x)
cupyx/scipy/sparse/csr.py:1117: in dense2csr
    return cusparse.dense2csr(a)
cupy/cusparse.py:1132: in dense2csr
    data = _cupy.empty(nnz, x.dtype)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise ValueError('Negative dimensions are not allowed')
E   ValueError: Negative dimensions are not allowed

cupy/core/core.pyx:142: ValueError
_________________ TestBmat_param_1_{dtype=float64}.test_empty __________________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_1_{dtype=float64} testMethod=test_empty>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_empty(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:172: in data
    A = sparse.csr_matrix(cupy.asarray([[1, 2], [3, 4]],
cupyx/scipy/sparse/compressed.py:389: in __init__
    data, indices, indptr = self._convert_dense(arg1)
cupyx/scipy/sparse/csr.py:76: in _convert_dense
    m = dense2csr(x)
cupyx/scipy/sparse/csr.py:1117: in dense2csr
    return cusparse.dense2csr(a)
cupy/cusparse.py:1132: in dense2csr
    data = _cupy.empty(nnz, x.dtype)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise ValueError('Negative dimensions are not allowed')
E   ValueError: Negative dimensions are not allowed

cupy/core/core.pyx:142: ValueError
_____________ TestBmat_param_1_{dtype=float64}.test_failure_cases ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestBmat_param_1_{dtype=float64} testMethod=test_failure_cases>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_failure_cases(self):
    
>       A, B, C, D = self.data()

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:172: in data
    A = sparse.csr_matrix(cupy.asarray([[1, 2], [3, 4]],
cupyx/scipy/sparse/compressed.py:389: in __init__
    data, indices, indptr = self._convert_dense(arg1)
cupyx/scipy/sparse/csr.py:76: in _convert_dense
    m = dense2csr(x)
cupyx/scipy/sparse/csr.py:1117: in dense2csr
    return cusparse.dense2csr(a)
cupy/cusparse.py:1132: in dense2csr
    data = _cupy.empty(nnz, x.dtype)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise ValueError('Negative dimensions are not allowed')
E   ValueError: Negative dimensions are not allowed

cupy/core/core.pyx:142: ValueError
_ TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_0_{dtype=float32, format='csr', random_method='...m'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}.test_random_with_data_rvs _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_0_{dtype=float32, format='csr', random_method='...=test_random_with_data_rvs>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_data_rvs(self):
        if self.random_method == 'rand':
            pytest.skip('cupyx.scipy.sparse.rand does not support data_rvs')
        data_rvs = mock.MagicMock(side_effect=cupy.zeros)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1, data_rvs=data_rvs,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_0_{dtype=float32, format='csr', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_0_{dtype=float32, format='csr', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_1_{dtype=float32, format='csr', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_1_{dtype=float32, format='csr', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_2_{dtype=float32, format='csc', random_method='...m'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}.test_random_with_data_rvs _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_2_{dtype=float32, format='csc', random_method='...=test_random_with_data_rvs>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_data_rvs(self):
        if self.random_method == 'rand':
            pytest.skip('cupyx.scipy.sparse.rand does not support data_rvs')
        data_rvs = mock.MagicMock(side_effect=cupy.zeros)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1, data_rvs=data_rvs,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_2_{dtype=float32, format='csc', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_2_{dtype=float32, format='csc', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_3_{dtype=float32, format='csc', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_3_{dtype=float32, format='csc', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_4_{dtype=float32, format='coo', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_4_{dtype=float32, format='coo', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'coo', 'random_method': 'random'}>

    def test_random_with_seed(self):
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_4_{dtype=float32, format='coo', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_4_{dtype=float32, format='coo', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'coo', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        state2 = cupy.random.RandomState(1)
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state2)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_5_{dtype=float32, format='coo', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_5_{dtype=float32, format='coo', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'coo', 'random_method': 'rand'}>

    def test_random_with_seed(self):
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_5_{dtype=float32, format='coo', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_5_{dtype=float32, format='coo', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float32'>, 'format': 'coo', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        state2 = cupy.random.RandomState(1)
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state2)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_6_{dtype=float64, format='csr', random_method='...m'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}.test_random_with_data_rvs _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_6_{dtype=float64, format='csr', random_method='...=test_random_with_data_rvs>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_data_rvs(self):
        if self.random_method == 'rand':
            pytest.skip('cupyx.scipy.sparse.rand does not support data_rvs')
        data_rvs = mock.MagicMock(side_effect=cupy.zeros)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1, data_rvs=data_rvs,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_6_{dtype=float64, format='csr', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_6_{dtype=float64, format='csr', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_7_{dtype=float64, format='csr', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_7_{dtype=float64, format='csr', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csr', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_8_{dtype=float64, format='csc', random_method='...m'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}.test_random_with_data_rvs _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_8_{dtype=float64, format='csc', random_method='...=test_random_with_data_rvs>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_data_rvs(self):
        if self.random_method == 'rand':
            pytest.skip('cupyx.scipy.sparse.rand does not support data_rvs')
        data_rvs = mock.MagicMock(side_effect=cupy.zeros)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1, data_rvs=data_rvs,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_8_{dtype=float64, format='csc', random_method='...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_8_{dtype=float64, format='csc', random_method='...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}.test_random _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'} testMethod=test_random>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_9_{dtype=float64, format='csc', random_method='...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random_with_seed(self):
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_9_{dtype=float64, format='csc', random_method='...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'csc', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
>       x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/construct.py:400: in rand
    return random(m, n, density, format, dtype, random_state)
cupyx/scipy/sparse/construct.py:371: in random
    return coo.coo_matrix(
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_10_{dtype=float64, format='coo', random_method='random'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_10_{dtype=float64, format='coo', random_method=...thod=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'coo', 'random_method': 'random'}>

    def test_random_with_seed(self):
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_10_{dtype=float64, format='coo', random_method='random'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_10_{dtype=float64, format='coo', random_method=...hod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'coo', 'random_method': 'random'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        state2 = cupy.random.RandomState(1)
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state2)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_11_{dtype=float64, format='coo', random_method='rand'}.test_random_with_seed _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_11_{dtype=float64, format='coo', random_method=...Method=test_random_with_seed>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'coo', 'random_method': 'rand'}>

    def test_random_with_seed(self):
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=1)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_ TestRandom_param_11_{dtype=float64, format='coo', random_method='rand'}.test_random_with_state _

self = <<cupyx_tests.scipy_tests.sparse_tests.test_construct.TestRandom_param_11_{dtype=float64, format='coo', random_method=...ethod=test_random_with_state>  parameter: {'dtype': <class 'numpy.float64'>, 'format': 'coo', 'random_method': 'rand'}>

    def test_random_with_state(self):
        state1 = cupy.random.RandomState(1)
        x = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state1)
        assert x.shape == (3, 4)
        assert x.dtype == self.dtype
        assert x.format == self.format
    
        state2 = cupy.random.RandomState(1)
        y = getattr(sparse, self.random_method)(
            3, 4, density=0.1,
            format=self.format, dtype=self.dtype,
            random_state=state2)
    
>       testing.assert_array_equal(x.toarray(), y.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____________ TestCooMatrix_param_0_{dtype=float32}.test_init_copy _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_0_{dtype=float32} testMethod=test_init_copy>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_copy(self):
        n = sparse.coo_matrix(self.m)
        assert n is not self.m
>       cupy.testing.assert_array_equal(n.toarray(), self.m.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
______ TestCooMatrix_param_0_{dtype=float32}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_0_{dtype=float32} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.coo_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
______________ TestCooMatrix_param_0_{dtype=float32}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_0_{dtype=float32} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____________ TestCooMatrix_param_1_{dtype=float64}.test_init_copy _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_1_{dtype=float64} testMethod=test_init_copy>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_copy(self):
        n = sparse.coo_matrix(self.m)
        assert n is not self.m
>       cupy.testing.assert_array_equal(n.toarray(), self.m.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
______ TestCooMatrix_param_1_{dtype=float64}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_1_{dtype=float64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.coo_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
______________ TestCooMatrix_param_1_{dtype=float64}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_1_{dtype=float64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
____________ TestCooMatrix_param_2_{dtype=complex64}.test_init_copy ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_2_{dtype=complex64} testMethod=test_init_copy>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_copy(self):
        n = sparse.coo_matrix(self.m)
        assert n is not self.m
>       cupy.testing.assert_array_equal(n.toarray(), self.m.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____ TestCooMatrix_param_2_{dtype=complex64}.test_init_copy_other_sparse ______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_2_{dtype=complex64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.coo_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____________ TestCooMatrix_param_2_{dtype=complex64}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_2_{dtype=complex64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
___________ TestCooMatrix_param_3_{dtype=complex128}.test_init_copy ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_3_{dtype=complex128} testMethod=test_init_copy>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_copy(self):
        n = sparse.coo_matrix(self.m)
        assert n is not self.m
>       cupy.testing.assert_array_equal(n.toarray(), self.m.toarray())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____ TestCooMatrix_param_3_{dtype=complex128}.test_init_copy_other_sparse _____

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_3_{dtype=complex128} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.coo_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
____________ TestCooMatrix_param_3_{dtype=complex128}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_coo.TestCooMatrix_param_3_{dtype=complex128} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/coo.py:335: in toarray
    return self.tocsr().toarray(order=order, out=out)
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
______ TestCscMatrix_param_0_{dtype=float32}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csc_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:267: in tocsr
    return csc2csr(self)
cupy/cusparse.py:1054: in csc2csrEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 139,824,806,043,648 bytes (allocated so far: 25,573,383,168 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________ TestCscMatrix_param_0_{dtype=float32}.test_init_data_row_col _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_data_row_col(self):
        o = self.m.tocoo()
>       n = sparse.csc_matrix((o.data, (o.row, o.col)))

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/compressed.py:366: in __init__
    sp_compressed = sp_coo.asformat(self.format)
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
____________ TestCscMatrix_param_0_{dtype=float32}.test_init_dense _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 0, 3]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af41ea100>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:158: AssertionError
_________ TestCscMatrix_param_0_{dtype=float32}.test_init_dense_empty __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([7, 0, 8, 0, 0], dtype=int32), y = [0, 0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 5 (40%)
E       Max absolute difference: 8
E       Max relative difference: inf
E        x: array([7, 0, 8, 0, 0], dtype=int32)
E        y: array([0, 0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
________ TestCscMatrix_param_0_{dtype=float32}.test_init_dense_one_dim _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af4213cd0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:178: AssertionError
________ TestCscMatrix_param_0_{dtype=float32}.test_init_dense_zero_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 1065353216 == 1
E        +  where 1065353216 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f20c7fb43d0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:187: AssertionError
_________ TestCscMatrix_param_0_{dtype=float32}.test_pickle_roundtrip __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94662794414224 != 94662794414224
E        +  where 94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f20c7ce7910>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f20c7ce7910> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f20c7cdcfd0>._descr
E        +  and   94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f20c7d7ccd0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f20c7d7ccd0> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f20c7ce7c10>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:272: AssertionError
______________ TestCscMatrix_param_0_{dtype=float32}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_0_{dtype=float32} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csc.py:229: in tocoo
    return cusparse.csc2coo(self, data, indices)
cupy/cusparse.py:1005: in csc2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f2af601a670>
arg1 = (array([0., 1., 3., 2.], dtype=float32), (array([0, 0, 2, 1], dtype=int32), array([-546805144, 1070564516,          0,          0], dtype=int32)))
shape = (3, 4), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
>               raise ValueError('column index exceeds matrix dimensions')
E               ValueError: column index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:159: ValueError
______ TestCscMatrix_param_1_{dtype=float64}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csc_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:267: in tocsr
    return csc2csr(self)
cupy/cusparse.py:1054: in csc2csrEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 139,824,806,043,648 bytes (allocated so far: 8,527,731,712 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________ TestCscMatrix_param_1_{dtype=float64}.test_init_data_row_col _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_data_row_col(self):
>       o = self.m.tocoo()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:229: in tocoo
    return cusparse.csc2coo(self, data, indices)
cupy/cusparse.py:1005: in csc2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f2af4111280>
arg1 = (array([0., 1., 3., 2.]), (array([0, 0, 2, 1], dtype=int32), array([1065353216,          0, 1073741824, 1077936128], dtype=int32)))
shape = (3, 4), dtype = dtype('float64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
                raise ValueError('row index exceeds matrix dimensions')
            if col.max() >= shape[1]:
>               raise ValueError('column index exceeds matrix dimensions')
E               ValueError: column index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:159: ValueError
____________ TestCscMatrix_param_1_{dtype=float64}.test_init_dense _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 0, 3]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af45d8430>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:158: AssertionError
_________ TestCscMatrix_param_1_{dtype=float64}.test_init_dense_empty __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([         0, 1065353216, 1077936128, 1073741824,          0],
      dtype=int32)
y = [0, 0, 0, 0, 0], err_msg = '', verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 5 (60%)
E       Max absolute difference: 1077936128
E       Max relative difference: inf
E        x: array([         0, 1065353216, 1077936128, 1073741824,          0],
E             dtype=int32)
E        y: array([0, 0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
________ TestCscMatrix_param_1_{dtype=float64}.test_init_dense_one_dim _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af63d21c0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:178: AssertionError
________ TestCscMatrix_param_1_{dtype=float64}.test_init_dense_zero_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af66dfaf0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:187: AssertionError
_________ TestCscMatrix_param_1_{dtype=float64}.test_pickle_roundtrip __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94662794414224 != 94662794414224
E        +  where 94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af6797d60>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af6797d60> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af67975e0>._descr
E        +  and   94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af6797b20>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af6797b20> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af6797070>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:272: AssertionError
______________ TestCscMatrix_param_1_{dtype=float64}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_1_{dtype=float64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____ TestCscMatrix_param_2_{dtype=complex64}.test_init_copy_other_sparse ______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csc_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:267: in tocsr
    return csc2csr(self)
cupy/cusparse.py:1054: in csc2csrEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 139,824,806,043,648 bytes (allocated so far: 4,905,984 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
________ TestCscMatrix_param_2_{dtype=complex64}.test_init_data_row_col ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_data_row_col(self):
        o = self.m.tocoo()
>       n = sparse.csc_matrix((o.data, (o.row, o.col)))

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/compressed.py:366: in __init__
    sp_compressed = sp_coo.asformat(self.format)
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
___________ TestCscMatrix_param_2_{dtype=complex64}.test_init_dense ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 0, 3]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 3
        assert n.shape == (3, 4)
>       cupy.testing.assert_array_equal(n.data, [1, 2, 3])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([1.e-45+1.e-45j, 3.e-45+1.e-45j, 0.e+00+0.e+00j], dtype=complex64)
y = [1, 2, 3], err_msg = '', verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 3 (100%)
E       Max absolute difference: 3.
E       Max relative difference: 1.
E        x: array([1.e-45+1.e-45j, 3.e-45+1.e-45j, 0.e+00+0.e+00j], dtype=complex64)
E        y: array([1, 2, 3])

cupy/testing/array.py:91: AssertionError
________ TestCscMatrix_param_2_{dtype=complex64}.test_init_dense_empty _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 0, 2, 1, 0], dtype=int32), y = [0, 0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 5 (40%)
E       Max absolute difference: 2
E       Max relative difference: inf
E        x: array([0, 0, 2, 1, 0], dtype=int32)
E        y: array([0, 0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
_______ TestCscMatrix_param_2_{dtype=complex64}.test_init_dense_one_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af655e0d0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:178: AssertionError
_______ TestCscMatrix_param_2_{dtype=complex64}.test_init_dense_zero_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af6168310>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:187: AssertionError
________ TestCscMatrix_param_2_{dtype=complex64}.test_pickle_roundtrip _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94662794414224 != 94662794414224
E        +  where 94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af3f930a0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af3f930a0> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af3f938e0>._descr
E        +  and   94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f20c80511c0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f20c80511c0> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af3f933d0>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:272: AssertionError
_____________ TestCscMatrix_param_2_{dtype=complex64}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_2_{dtype=complex64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____ TestCscMatrix_param_3_{dtype=complex128}.test_init_copy_other_sparse _____

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csc_matrix(self.m.tocsr())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:267: in tocsr
    return csc2csr(self)
cupy/cusparse.py:1054: in csc2csrEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 139,824,806,043,648 bytes (allocated so far: 4,905,984 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_______ TestCscMatrix_param_3_{dtype=complex128}.test_init_data_row_col ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_data_row_col(self):
        o = self.m.tocoo()
>       n = sparse.csc_matrix((o.data, (o.row, o.col)))

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/compressed.py:366: in __init__
    sp_compressed = sp_coo.asformat(self.format)
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 94,662,786,669,568 bytes (allocated so far: 4,905,984 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
___________ TestCscMatrix_param_3_{dtype=complex128}.test_init_dense ___________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 0, 3]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 2 == 3
E        +  where 2 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af46353d0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:158: AssertionError
________ TestCscMatrix_param_3_{dtype=complex128}.test_init_dense_empty ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 0
E       AssertionError: assert 2 == 0
E        +  where 2 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af6361b50>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:169: AssertionError
_______ TestCscMatrix_param_3_{dtype=complex128}.test_init_dense_one_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csc_matrix(m)
        assert n.nnz == 2
        assert n.shape == (1, 4)
>       cupy.testing.assert_array_equal(n.data, [1, 2])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0.00000000e+000+5.26354425e-315j, 5.30498948e-315+5.32571209e-315j])
y = [1, 2], err_msg = '', verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 2.
E       Max relative difference: 1.
E        x: array([0.000000e+000+5.263544e-315j, 5.304989e-315+5.325712e-315j])
E        y: array([1, 2])

cupy/testing/array.py:91: AssertionError
______ TestCscMatrix_param_3_{dtype=complex128}.test_init_dense_zero_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csc_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 2 == 1
E        +  where 2 = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af6272f10>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:187: AssertionError
________ TestCscMatrix_param_3_{dtype=complex128}.test_pickle_roundtrip ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94662794414224 != 94662794414224
E        +  where 94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af66d94c0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af66d94c0> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af66d9d60>._descr
E        +  and   94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af66d9e50>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af66d9e50> = <cupyx.scipy.sparse.csc.csc_matrix object at 0x7f2af66d9400>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:272: AssertionError
____________ TestCscMatrix_param_3_{dtype=complex128}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csc.TestCscMatrix_param_3_{dtype=complex128} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py:260: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
______ TestCsrMatrix_param_0_{dtype=float32}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csr_matrix(self.m.tocsc())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:447: in tocsc
    return csr2csc(self)
cupy/cusparse.py:976: in csr2cscEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 139,824,806,043,648 bytes (allocated so far: 4,905,984 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________ TestCsrMatrix_param_0_{dtype=float32}.test_init_data_row_col _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_data_row_col(self):
        o = self.m.tocoo()
>       n = sparse.csr_matrix((o.data, (o.row, o.col)))

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/compressed.py:366: in __init__
    sp_compressed = sp_coo.asformat(self.format)
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:394: in tocsr
    cusparse.coosort(x, 'r')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
____________ TestCsrMatrix_param_0_{dtype=float32}.test_init_dense _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 3, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af3a285e0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:202: AssertionError
_________ TestCsrMatrix_param_0_{dtype=float32}.test_init_dense_empty __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 0, 1, 1], dtype=int32), y = [0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 4 (50%)
E       Max absolute difference: 1
E       Max relative difference: inf
E        x: array([0, 0, 1, 1], dtype=int32)
E        y: array([0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
________ TestCsrMatrix_param_0_{dtype=float32}.test_init_dense_one_dim _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af4037850>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:222: AssertionError
________ TestCsrMatrix_param_0_{dtype=float32}.test_init_dense_zero_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 1065353216 == 1
E        +  where 1065353216 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f20c7582730>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:231: AssertionError
_________ TestCsrMatrix_param_0_{dtype=float32}.test_pickle_roundtrip __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
    
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94662794414224 != 94662794414224
E        +  where 94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f20c7c0c0d0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f20c7c0c0d0> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f20c7c0c190>._descr
E        +  and   94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af64c49a0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af64c49a0> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af63eb280>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:317: AssertionError
______________ TestCsrMatrix_param_0_{dtype=float32}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_0_{dtype=float32} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:393: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f20c75f17f0>
arg1 = (array([0., 1., 2., 3.], dtype=float32), (array([0, 1, 2, 3], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('float32'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
______ TestCsrMatrix_param_1_{dtype=float64}.test_init_copy_other_sparse _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csr_matrix(self.m.tocsc())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:447: in tocsc
    return csr2csc(self)
cupy/cusparse.py:976: in csr2cscEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 139,824,806,043,648 bytes (allocated so far: 8,527,731,712 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_________ TestCsrMatrix_param_1_{dtype=float64}.test_init_data_row_col _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_data_row_col(self):
>       o = self.m.tocoo()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f2af3f46ca0>
arg1 = (array([0., 1., 2., 3.]), (array([0, 2, 3, 4], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('float64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
____________ TestCsrMatrix_param_1_{dtype=float64}.test_init_dense _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 3, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af4049ac0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:202: AssertionError
_________ TestCsrMatrix_param_1_{dtype=float64}.test_init_dense_empty __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 0, 2, 1], dtype=int32), y = [0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 4 (50%)
E       Max absolute difference: 2
E       Max relative difference: inf
E        x: array([0, 0, 2, 1], dtype=int32)
E        y: array([0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
________ TestCsrMatrix_param_1_{dtype=float64}.test_init_dense_one_dim _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f20c7de13d0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:222: AssertionError
________ TestCsrMatrix_param_1_{dtype=float64}.test_init_dense_zero_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f20c8b081f0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:231: AssertionError
_________ TestCsrMatrix_param_1_{dtype=float64}.test_pickle_roundtrip __________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
    
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94662794414224 != 94662794414224
E        +  where 94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f20c80d18b0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f20c80d18b0> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f20c80d1f70>._descr
E        +  and   94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f20c91218e0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f20c91218e0> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af656c8e0>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:317: AssertionError
______________ TestCsrMatrix_param_1_{dtype=float64}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_1_{dtype=float64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:393: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f20c75f8190>
arg1 = (array([0., 1., 2., 3.]), (array([0, 2, 3, 4], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('float64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
_____ TestCsrMatrix_param_2_{dtype=complex64}.test_init_copy_other_sparse ______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csr_matrix(self.m.tocsc())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:447: in tocsc
    return csr2csc(self)
cupy/cusparse.py:976: in csr2cscEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 139,824,806,043,648 bytes (allocated so far: 4,905,984 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
________ TestCsrMatrix_param_2_{dtype=complex64}.test_init_data_row_col ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_data_row_col(self):
>       o = self.m.tocoo()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f2af4768b20>
arg1 = (array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j], dtype=complex64), (array([         0,          0,          0, 1072693248], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('complex64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
___________ TestCsrMatrix_param_2_{dtype=complex64}.test_init_dense ____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 3, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af405e2e0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:202: AssertionError
________ TestCsrMatrix_param_2_{dtype=complex64}.test_init_dense_empty _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 1, 3, 2], dtype=int32), y = [0, 0, 0, 0], err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 3 / 4 (75%)
E       Max absolute difference: 3
E       Max relative difference: inf
E        x: array([0, 1, 3, 2], dtype=int32)
E        y: array([0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
_______ TestCsrMatrix_param_2_{dtype=complex64}.test_init_dense_one_dim ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af66b59d0>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:222: AssertionError
_______ TestCsrMatrix_param_2_{dtype=complex64}.test_init_dense_zero_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af3b0a910>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:231: AssertionError
________ TestCsrMatrix_param_2_{dtype=complex64}.test_pickle_roundtrip _________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
    
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94662794414224 != 94662794414224
E        +  where 94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af3fb8d00>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af3fb8d00> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af3fb8ee0>._descr
E        +  and   94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af6562520>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af6562520> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af3fb8af0>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:317: AssertionError
_____________ TestCsrMatrix_param_2_{dtype=complex64}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_2_{dtype=complex64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:393: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f2af46cb340>
arg1 = (array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j], dtype=complex64), (array([0, 1, 3, 2], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('complex64'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
_____ TestCsrMatrix_param_3_{dtype=complex128}.test_init_copy_other_sparse _____

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_copy_other_sparse>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_copy_other_sparse(self):
>       n = sparse.csr_matrix(self.m.tocsc())

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:447: in tocsc
    return csr2csc(self)
cupy/cusparse.py:976: in csr2cscEx2
    buffer = _cupy.empty(buffer_size, _numpy.int8)
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
cupy/core/core.pyx:163: in cupy.core.core.ndarray.__init__
    self.data = memory.alloc(self.size * itemsize)
cupy/cuda/memory.pyx:697: in cupy.cuda.memory.alloc
    return get_allocator()(size)
cupy/cuda/memory.pyx:1371: in cupy.cuda.memory.MemoryPool.malloc
    cpdef MemoryPointer malloc(self, size_t size):
cupy/cuda/memory.pyx:1392: in cupy.cuda.memory.MemoryPool.malloc
    return mp.malloc(size)
cupy/cuda/memory.pyx:1060: in cupy.cuda.memory.SingleDeviceMemoryPool.malloc
    return self._malloc(rounded_size)
cupy/cuda/memory.pyx:1080: in cupy.cuda.memory.SingleDeviceMemoryPool._malloc
    mem = self._try_malloc(size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   raise OutOfMemoryError(
E   cupy.cuda.memory.OutOfMemoryError: Out of memory allocating 139,824,806,043,648 bytes (allocated so far: 4,905,984 bytes).

cupy/cuda/memory.pyx:1331: OutOfMemoryError
_______ TestCsrMatrix_param_3_{dtype=complex128}.test_init_data_row_col ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_data_row_col>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_data_row_col(self):
>       o = self.m.tocoo()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f2af3e860a0>
arg1 = (array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j]), (array([0, 1, 3, 2], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('complex128'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
___________ TestCsrMatrix_param_3_{dtype=complex128}.test_init_dense ___________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_dense>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense(self):
        m = cupy.array([[0, 1, 0, 2],
                        [0, 0, 0, 0],
                        [0, 0, 3, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 3
E       AssertionError: assert 0 == 3
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af3e2de50>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:202: AssertionError
________ TestCsrMatrix_param_3_{dtype=complex128}.test_init_dense_empty ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_empty>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_empty(self):
        m = cupy.array([[0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]], dtype=self.dtype)
        n = sparse.csr_matrix(m)
        assert n.nnz == 0
        assert n.shape == (3, 4)
        cupy.testing.assert_array_equal(n.data, [])
        cupy.testing.assert_array_equal(n.indices, [])
>       cupy.testing.assert_array_equal(n.indptr, [0, 0, 0, 0])

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([         0,          0, 1065353216,          0], dtype=int32)
y = [0, 0, 0, 0], err_msg = '', verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 4 (25%)
E       Max absolute difference: 1065353216
E       Max relative difference: inf
E        x: array([         0,          0, 1065353216,          0], dtype=int32)
E        y: array([0, 0, 0, 0])

cupy/testing/array.py:91: AssertionError
_______ TestCsrMatrix_param_3_{dtype=complex128}.test_init_dense_one_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_one_dim>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_one_dim(self):
        m = cupy.array([0, 1, 0, 2], dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 2
E       AssertionError: assert 0 == 2
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af40f6160>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:222: AssertionError
______ TestCsrMatrix_param_3_{dtype=complex128}.test_init_dense_zero_dim _______

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_init_dense_zero_dim>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_init_dense_zero_dim(self):
        m = cupy.array(1, dtype=self.dtype)
        n = sparse.csr_matrix(m)
>       assert n.nnz == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af627fd00>.nnz

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:231: AssertionError
________ TestCsrMatrix_param_3_{dtype=complex128}.test_pickle_roundtrip ________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_pickle_roundtrip>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_pickle_roundtrip(self):
        s = _make(cupy, sparse, self.dtype)
    
        s2 = pickle.loads(pickle.dumps(s))
>       assert s._descr.descriptor != s2._descr.descriptor
E       AssertionError: assert 94662794414224 != 94662794414224
E        +  where 94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af66d9070>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af66d9070> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af66d9430>._descr
E        +  and   94662794414224 = <cupy.cusparse.MatDescriptor object at 0x7f2af66d93d0>.descriptor
E        +    where <cupy.cusparse.MatDescriptor object at 0x7f2af66d93d0> = <cupyx.scipy.sparse.csr.csr_matrix object at 0x7f2af66d9220>._descr

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:317: AssertionError
____________ TestCsrMatrix_param_3_{dtype=complex128}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_csr.TestCsrMatrix_param_3_{dtype=complex128} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/csr.py:393: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:904: in sum_duplicates
    coo = self.tocoo()
cupyx/scipy/sparse/csr.py:425: in tocoo
    return cusparse.csr2coo(self, data, indices)
cupy/cusparse.py:927: in csr2coo
    return cupyx.scipy.sparse.coo_matrix(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupyx.scipy.sparse.coo.coo_matrix object at 0x7f2af3a3b9a0>
arg1 = (array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j]), (array([0, 2, 3, 4], dtype=int32), array([0, 1, 3, 2], dtype=int32)))
shape = (3, 4), dtype = dtype('complex128'), copy = False

    def __init__(self, arg1, shape=None, dtype=None, copy=False):
        if shape is not None and len(shape) != 2:
            raise ValueError(
                'Only two-dimensional sparse arrays are supported.')
    
        if base.issparse(arg1):
            x = arg1.asformat(self.format)
            data = x.data
            row = x.row
            col = x.col
    
            if arg1.format != self.format:
                # When formats are differnent, all arrays are already copied
                copy = False
    
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif _util.isshape(arg1):
            m, n = arg1
            m, n = int(m), int(n)
            data = cupy.zeros(0, dtype if dtype else 'd')
            row = cupy.zeros(0, dtype='i')
            col = cupy.zeros(0, dtype='i')
            # shape and copy argument is ignored
            shape = (m, n)
            copy = False
    
            self.has_canonical_format = True
    
        elif _scipy_available and scipy.sparse.issparse(arg1):
            # Convert scipy.sparse to cupyx.scipy.sparse
            x = arg1.tocoo()
            data = cupy.array(x.data)
            row = cupy.array(x.row, dtype='i')
            col = cupy.array(x.col, dtype='i')
            copy = False
            if shape is None:
                shape = arg1.shape
    
            self.has_canonical_format = x.has_canonical_format
    
        elif isinstance(arg1, tuple) and len(arg1) == 2:
            try:
                data, (row, col) = arg1
            except (TypeError, ValueError):
                raise TypeError('invalid input format')
    
            if not (base.isdense(data) and data.ndim == 1 and
                    base.isdense(row) and row.ndim == 1 and
                    base.isdense(col) and col.ndim == 1):
                raise ValueError('row, column, and data arrays must be 1-D')
            if not (len(data) == len(row) == len(col)):
                raise ValueError(
                    'row, column, and data array must all be the same length')
    
            self.has_canonical_format = False
    
        elif base.isdense(arg1):
            if arg1.ndim > 2:
                raise TypeError('expected dimension <= 2 array or matrix')
            dense = cupy.atleast_2d(arg1)
            row, col = dense.nonzero()
            data = dense[row, col]
            shape = dense.shape
    
            self.has_canonical_format = True
    
        else:
            raise TypeError('invalid input format')
    
        if dtype is None:
            dtype = data.dtype
        else:
            dtype = numpy.dtype(dtype)
    
        if dtype != 'f' and dtype != 'd' and dtype != 'F' and dtype != 'D':
            raise ValueError(
                'Only float32, float64, complex64 and complex128'
                ' are supported')
    
        data = data.astype(dtype, copy=copy)
        row = row.astype('i', copy=copy)
        col = col.astype('i', copy=copy)
    
        if shape is None:
            if len(row) == 0 or len(col) == 0:
                raise ValueError(
                    'cannot infer dimensions from zero sized index arrays')
            shape = (int(row.max()) + 1, int(col.max()) + 1)
    
        if len(data) > 0:
            if row.max() >= shape[0]:
>               raise ValueError('row index exceeds matrix dimensions')
E               ValueError: row index exceeds matrix dimensions

cupyx/scipy/sparse/coo.py:157: ValueError
______________ TestDiaMatrix_param_0_{dtype=float32}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_dia.TestDiaMatrix_param_0_{dtype=float32} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float32'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/dia.py:136: in toarray
    return self.tocsc().toarray(order=order, out=out)
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
______________ TestDiaMatrix_param_1_{dtype=float64}.test_toarray ______________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_dia.TestDiaMatrix_param_1_{dtype=float64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.float64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/dia.py:136: in toarray
    return self.tocsc().toarray(order=order, out=out)
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_____________ TestDiaMatrix_param_2_{dtype=complex64}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_dia.TestDiaMatrix_param_2_{dtype=complex64} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex64'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/dia.py:136: in toarray
    return self.tocsc().toarray(order=order, out=out)
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
____________ TestDiaMatrix_param_3_{dtype=complex128}.test_toarray _____________

self = <<cupyx_tests.scipy_tests.sparse_tests.test_dia.TestDiaMatrix_param_3_{dtype=complex128} testMethod=test_toarray>  parameter: {'dtype': <class 'numpy.complex128'>}>

    def test_toarray(self):
>       m = self.m.toarray()

tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupyx/scipy/sparse/dia.py:136: in toarray
    return self.tocsc().toarray(order=order, out=out)
cupyx/scipy/sparse/csc.py:187: in toarray
    x.sum_duplicates()
cupyx/scipy/sparse/compressed.py:906: in sum_duplicates
    self.__init__(coo.asformat(self.format))
cupyx/scipy/sparse/base.py:247: in asformat
    return getattr(self, 'to' + format)()
cupyx/scipy/sparse/coo.py:371: in tocsc
    cusparse.coosort(x, 'c')
cupy/cusparse.py:852: in coosort
    buf = _cupy.empty(buffer_size, 'b')
cupy/_creation/basic.py:22: in empty
    return cupy.ndarray(shape, dtype, order=order)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   for x in s:
E   OverflowError: Python int too large to convert to C ssize_t

cupy/core/core.pyx:140: OverflowError
_______________________ TestMonteCarlo.test_monte_carlo ________________________

self = <example_tests.test_finance.TestMonteCarlo testMethod=test_monte_carlo>

    def test_monte_carlo(self):
>       output = example_test.run_example(
            'finance/monte_carlo.py', '--n-options', '10',
            '--n-samples-per-thread', '10',
            '--n-threads-per-option', '10')

tests/example_tests/test_finance.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/example_tests/example_test.py:12: in run_example
    return subprocess.check_output(
/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:411: in check_output
    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/...tests/example_tests/../../examples/finance/monte_carlo.py', '--n-options', '10', '--n-samples-per-thread', '10', ...),)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7f1fa8111e50>
stdout = b'initializing...\nstart computation\n    # of options: 10\n    # of samples per option: 100\nTraceback (most recent c...r generated when compiling for gfx906.\nError: Failed to compile opencl source (from CL or HIP source to LLVM IR).\n\n'
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/example_tests/../../examples/finance/monte_carlo.py', '--n-options', '10', '--n-samples-per-thread', '10', '--n-threads-per-option', '10')' returned non-zero exit status 1.

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:512: CalledProcessError
----------------------------- Captured stdout call -----------------------------
Original error message:
initializing...
start computation
    # of options: 10
    # of samples per option: 100
Traceback (most recent call last):
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 601, in compile
    nvrtc.compileProgram(self.ptr, options)
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 116, in cupy_backends.cuda.libs.nvrtc.compileProgram
    cpdef compileProgram(intptr_t prog, options):
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 128, in cupy_backends.cuda.libs.nvrtc.compileProgram
    check_status(status)
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 62, in cupy_backends.cuda.libs.nvrtc.check_status
    raise NVRTCError(status)
cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/example_tests/../../examples/finance/monte_carlo.py", line 159, in <module>
    sys.exit(main())
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/example_tests/../../examples/finance/monte_carlo.py", line 145, in main
    call_mc = compute_option_prices(
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/example_tests/../../examples/finance/monte_carlo.py", line 104, in compute_option_prices
    monte_carlo_kernel(
  File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
  File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
  File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
  File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 787, in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 249, in compile_using_nvrtc
    return _compile(source, options, cu_path,
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 233, in _compile
    ptx, mapping = prog.compile(options, log_stream)
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 613, in compile
    raise CompileException(log, self.src, self.name, options,
cupy.cuda.compiler.CompileException: /tmp/comgr-ab22ba/input/CompileSource:5358:32: error: typedef redefinition with different types ('unsigned long long' vs '__uint64_t' (aka 'unsigned long'))
    typedef unsigned long long uint64_t;
                               ^
/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h:27:20: note: previous definition is here
typedef __uint64_t uint64_t;
                   ^
/tmp/comgr-ab22ba/input/CompileSource:5388:25: warning: integer literal is too large to be represented in a signed integer type, interpreting as unsigned [-Wimplicitly-unsigned-literal]
        return T(x) / T(18446744073709551615);
                        ^
1 warning and 1 error generated when compiling for gfx906.
Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).


_____________ TestMonteCarloWithMultiGPU.test_monte_carlo_multigpu _____________

self = <example_tests.test_finance.TestMonteCarloWithMultiGPU testMethod=test_monte_carlo_multigpu>

    @testing.multi_gpu(2)
    def test_monte_carlo_multigpu(self):
>       output = example_test.run_example(
            'finance/monte_carlo_multigpu.py', '--gpus', '0', '1',
            '--n-options', '10',
            '--n-samples-per-thread', '10',
            '--n-threads-per-option', '10')

tests/example_tests/test_finance.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/example_tests/example_test.py:12: in run_example
    return subprocess.check_output(
/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:411: in check_output
    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/example_tests/../../examples/finance/monte_carlo_multigpu.py', '--gpus', '0', '1', '--n-options', ...),)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7f1fa9d36310>
stdout = b'initializing...\nstart computation\n    # of gpus: 2\n    # of options: 10\n    # of samples per option: 200\nTraceb...r generated when compiling for gfx906.\nError: Failed to compile opencl source (from CL or HIP source to LLVM IR).\n\n'
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/example_tests/../../examples/finance/monte_carlo_multigpu.py', '--gpus', '0', '1', '--n-options', '10', '--n-samples-per-thread', '10', '--n-threads-per-option', '10')' returned non-zero exit status 1.

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:512: CalledProcessError
----------------------------- Captured stdout call -----------------------------
Original error message:
initializing...
start computation
    # of gpus: 2
    # of options: 10
    # of samples per option: 200
Traceback (most recent call last):
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 601, in compile
    nvrtc.compileProgram(self.ptr, options)
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 116, in cupy_backends.cuda.libs.nvrtc.compileProgram
    cpdef compileProgram(intptr_t prog, options):
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 128, in cupy_backends.cuda.libs.nvrtc.compileProgram
    check_status(status)
  File "cupy_backends/cuda/libs/nvrtc.pyx", line 62, in cupy_backends.cuda.libs.nvrtc.check_status
    raise NVRTCError(status)
cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/example_tests/../../examples/finance/monte_carlo_multigpu.py", line 74, in <module>
    monte_carlo_kernel(
  File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
  File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
  File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
  File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
  File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
  File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
  File "cupy/core/core.pyx", line 2019, in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 406, in compile_with_cache
    return _compile_with_cache_hip(
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 787, in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 249, in compile_using_nvrtc
    return _compile(source, options, cu_path,
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 233, in _compile
    ptx, mapping = prog.compile(options, log_stream)
  File "/home/kmaeh/CuPy_CI/pr-4619/2021-02-05.OQiwdKfPWH/cupy/cupy/cuda/compiler.py", line 613, in compile
    raise CompileException(log, self.src, self.name, options,
cupy.cuda.compiler.CompileException: /tmp/comgr-510738/input/CompileSource:5358:32: error: typedef redefinition with different types ('unsigned long long' vs '__uint64_t' (aka 'unsigned long'))
    typedef unsigned long long uint64_t;
                               ^
/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h:27:20: note: previous definition is here
typedef __uint64_t uint64_t;
                   ^
/tmp/comgr-510738/input/CompileSource:5388:25: warning: integer literal is too large to be represented in a signed integer type, interpreting as unsigned [-Wimplicitly-unsigned-literal]
        return T(x) / T(18446744073709551615);
                        ^
1 warning and 1 error generated when compiling for gfx906.
Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).


___________________ TestCheckVersion.test_check_cuda_version ___________________

self = <install_tests.test_build.TestCheckVersion testMethod=test_check_cuda_version>

    @pytest.mark.gpu
    def test_check_cuda_version(self):
        with self.assertRaises(RuntimeError):
            build.get_cuda_version()
>       assert build.check_cuda_version(
            self.compiler, self.settings)
E       AssertionError: assert False
E        +  where False = <function check_cuda_version at 0x7f20c393fa60>(<distutils.unixccompiler.UnixCCompiler object at 0x7f1fa80d6c70>, {'define_macros': [], 'extra_compile_args': [], 'include_dirs': ['/home/kmaeh/Development/cupy-rocm-ci-report/tools/tm...kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/install/../cupy/core/include'], 'language': 'c++', ...})
E        +    where <function check_cuda_version at 0x7f20c393fa60> = build.check_cuda_version
E        +    and   <distutils.unixccompiler.UnixCCompiler object at 0x7f1fa80d6c70> = <install_tests.test_build.TestCheckVersion testMethod=test_check_cuda_version>.compiler
E        +    and   {'define_macros': [], 'extra_compile_args': [], 'include_dirs': ['/home/kmaeh/Development/cupy-rocm-ci-report/tools/tm...kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/install/../cupy/core/include'], 'language': 'c++', ...} = <install_tests.test_build.TestCheckVersion testMethod=test_check_cuda_version>.settings

tests/install_tests/test_build.py:21: AssertionError
----------------------------- Captured stdout call -----------------------------
**************************************************
*** WARNING: Cannot check CUDA version
*** WARNING: command 'gcc' failed with exit status 1
**************************************************
----------------------------- Captured stderr call -----------------------------
/tmp/tmp_jbxfd74/a.cpp:2:18: fatal error: cuda.h: No such file or directory
         #include <cuda.h>
                  ^~~~~~~~
compilation terminated.
__________________ TestCheckVersion.test_check_cudnn_version ___________________

self = <install_tests.test_build.TestCheckVersion testMethod=test_check_cudnn_version>

    @pytest.mark.gpu
    @pytest.mark.cudnn
    def test_check_cudnn_version(self):
        with self.assertRaises(RuntimeError):
            build.get_cudnn_version()
>       assert build.check_cudnn_version(
            self.compiler, self.settings)
E       AssertionError: assert False
E        +  where False = <function check_cudnn_version at 0x7f20c393fee0>(<distutils.unixccompiler.UnixCCompiler object at 0x7f1fa80d6310>, {'define_macros': [], 'extra_compile_args': [], 'include_dirs': ['/home/kmaeh/Development/cupy-rocm-ci-report/tools/tm...kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/install/../cupy/core/include'], 'language': 'c++', ...})
E        +    where <function check_cudnn_version at 0x7f20c393fee0> = build.check_cudnn_version
E        +    and   <distutils.unixccompiler.UnixCCompiler object at 0x7f1fa80d6310> = <install_tests.test_build.TestCheckVersion testMethod=test_check_cudnn_version>.compiler
E        +    and   {'define_macros': [], 'extra_compile_args': [], 'include_dirs': ['/home/kmaeh/Development/cupy-rocm-ci-report/tools/tm...kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/install/../cupy/core/include'], 'language': 'c++', ...} = <install_tests.test_build.TestCheckVersion testMethod=test_check_cudnn_version>.settings

tests/install_tests/test_build.py:31: AssertionError
----------------------------- Captured stdout call -----------------------------
**************************************************
*** WARNING: Cannot check cuDNN version
command 'gcc' failed with exit status 1
**************************************************
----------------------------- Captured stderr call -----------------------------
/tmp/tmpl0gr5iun/a.cpp:2:18: fatal error: cudnn.h: No such file or directory
         #include <cudnn.h>
                  ^~~~~~~~~
compilation terminated.
=============================== warnings summary ===============================
tests/cupy_tests/core_tests/fusion_tests/test_routines.py::TestFusionNumericalReduction_param_1_{func='prod'}::test_reduction
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: overflow encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/functional_tests/test_vectorize.py::TestVectorize::test_vectorize_arithmetic_ops
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/functional_tests/test_vectorize.py:359: RuntimeWarning: overflow encountered in byte_scalars
    y = x1 + x2 * x3 ** x1

tests/cupy_tests/functional_tests/test_vectorize.py::TestVectorize::test_vectorize_arithmetic_ops
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/functional_tests/test_vectorize.py:359: RuntimeWarning: overflow encountered in ubyte_scalars
    y = x1 + x2 * x3 ** x1

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_0_{type_l='poly1d', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_3_{type_l='ndarray', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_array
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in multiply
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in half_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in byte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in short_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ubyte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ushort_scalars
    y = y * x + p[i]

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in power
    absx **= ord

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in reciprocal
    absx **= ord

tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf
tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf_nan
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/numeric.py:2276: RuntimeWarning: overflow encountered in absolute
    return less_equal(abs(x-y), atol + rtol * abs(y))

tests/cupy_tests/math_tests/test_sumprod.py: 19 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: overflow encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/math_tests/test_sumprod.py: 15 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: invalid value encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: invalid value encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/math_tests/test_sumprod.py: 32 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/math_tests/test_sumprod.py:799: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all_transposed2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes4
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axis_transposed2
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:47: RuntimeWarning: overflow encountered in reduce
    return umr_sum(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/statistics_tests/test_meanvar.py: 28 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.q2Yui1WrVM/cupy/tests/cupy_tests/statistics_tests/test_meanvar.py:114: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_4_{axis=0, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_5_{axis=0, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_6_{axis=0, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_7_{axis=0, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_8_{axis=1, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_9_{axis=1, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_10_{axis=1, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_11_{axis=1, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/nanfunctions.py:1113: RuntimeWarning: All-NaN slice encountered
    r, k = function_base._ureduce(a, func=_nanmedian, axis=axis, out=out,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_3_{func='mean', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_5_{func='mean', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3372: RuntimeWarning: Mean of empty slice.
    return _methods._mean(a, axis=axis, dtype=dtype,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:168: RuntimeWarning: invalid value encountered in true_divide
    ret = arr.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_9_{func='std', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_11_{func='std', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:233: RuntimeWarning: Degrees of freedom <= 0 for slice
    ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:194: RuntimeWarning: invalid value encountered in true_divide
    arrmean = um.true_divide(

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_15_{func='var', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_17_{func='var', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3621: RuntimeWarning: Degrees of freedom <= 0 for slice
    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

-- Docs: https://docs.pytest.org/en/stable/warnings.html
=========================== short test summary info ============================
FAILED tests/cupy_tests/test_cublas.py::TestDgmm_param_5_{ordera='C', orderc='F', shape=(9, 10), side='R'}::test_dgmm_incx_minus_one
FAILED tests/cupy_tests/test_cublas.py::TestDgmm_param_7_{ordera='C', orderc='F', shape=(10, 9), side='R'}::test_dgmm_incx_minus_one
FAILED tests/cupy_tests/test_cublas.py::TestDgmm_param_12_{ordera='F', orderc='F', shape=(9, 10), side='L'}::test_dgmm_incx_minus_one
FAILED tests/cupy_tests/test_cublas.py::TestDgmm_param_14_{ordera='F', orderc='F', shape=(10, 9), side='L'}::test_dgmm_incx_minus_one
FAILED tests/cupy_tests/test_cusparse.py::TestMatDescriptor::test_pickle - As...
FAILED tests/cupy_tests/core_tests/test_ndarray_conversion.py::TestNdarrayToBytes_param_1_{shape=(1,)}::test_item
FAILED tests/cupy_tests/core_tests/test_ndarray_conversion.py::TestNdarrayToBytes_param_2_{shape=(2, 3)}::test_item
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_0_{indexes=(1, 0, 2), shape=(2, 3, 4), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_1_{indexes=(-1, 0, -2), shape=(2, 3, 4), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_2_{indexes=(1, 0, 2), shape=(2, 3, 4), transpose=(2, 0, 1)}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_3_{indexes=(-1, 0, -2), shape=(2, 3, 4), transpose=(2, 0, 1)}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_14_{indexes=(slice(None, None, None), None), shape=(2,), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_18_{indexes=(slice(-9, -10, -1),), shape=(10,), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_27_{indexes=(slice(-4, -5, -1),), shape=(10,), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_indexing.py::TestArrayIndexingParameterized_param_38_{indexes=(slice(-5, -6, -1),), shape=(10,), transpose=None}::test_getitem
FAILED tests/cupy_tests/core_tests/test_ndarray_unary_op.py::TestArrayBoolOp::test_bool_one_element
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_30_{func=<lambda>, left_value='array', name='eq', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_31_{func=<lambda>, left_value='array', name='eq', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_32_{func=<lambda>, left_value='array', name='eq', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_33_{func=<lambda>, left_value='scalar', name='eq', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_34_{func=<lambda>, left_value='primitive', name='eq', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_35_{func=<lambda>, left_value='array', name='ne', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_36_{func=<lambda>, left_value='array', name='ne', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_37_{func=<lambda>, left_value='array', name='ne', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_38_{func=<lambda>, left_value='scalar', name='ne', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_39_{func=<lambda>, left_value='primitive', name='ne', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_40_{func=<lambda>, left_value='array', name='lt', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_41_{func=<lambda>, left_value='array', name='lt', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_42_{func=<lambda>, left_value='array', name='lt', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_43_{func=<lambda>, left_value='scalar', name='lt', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_44_{func=<lambda>, left_value='primitive', name='lt', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_45_{func=<lambda>, left_value='array', name='le', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_46_{func=<lambda>, left_value='array', name='le', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_47_{func=<lambda>, left_value='array', name='le', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_48_{func=<lambda>, left_value='scalar', name='le', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_49_{func=<lambda>, left_value='primitive', name='le', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_50_{func=<lambda>, left_value='array', name='gt', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_51_{func=<lambda>, left_value='array', name='gt', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_52_{func=<lambda>, left_value='array', name='gt', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_53_{func=<lambda>, left_value='scalar', name='gt', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_54_{func=<lambda>, left_value='primitive', name='gt', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_55_{func=<lambda>, left_value='array', name='ge', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_56_{func=<lambda>, left_value='array', name='ge', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_57_{func=<lambda>, left_value='array', name='ge', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_58_{func=<lambda>, left_value='scalar', name='ge', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayOperator_param_59_{func=<lambda>, left_value='primitive', name='ge', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_0_{func=<lambda>, left_value='array', name='lshift', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_1_{func=<lambda>, left_value='array', name='lshift', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_2_{func=<lambda>, left_value='array', name='lshift', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_3_{func=<lambda>, left_value='scalar', name='lshift', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_4_{func=<lambda>, left_value='primitive', name='lshift', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_5_{func=<lambda>, left_value='array', name='rshift', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_6_{func=<lambda>, left_value='array', name='rshift', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_7_{func=<lambda>, left_value='array', name='rshift', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_8_{func=<lambda>, left_value='scalar', name='rshift', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_9_{func=<lambda>, left_value='primitive', name='rshift', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_10_{func=<lambda>, left_value='array', name='and', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_11_{func=<lambda>, left_value='array', name='and', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_12_{func=<lambda>, left_value='array', name='and', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_13_{func=<lambda>, left_value='scalar', name='and', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_14_{func=<lambda>, left_value='primitive', name='and', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_15_{func=<lambda>, left_value='array', name='or', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_16_{func=<lambda>, left_value='array', name='or', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_17_{func=<lambda>, left_value='array', name='or', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_18_{func=<lambda>, left_value='scalar', name='or', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_19_{func=<lambda>, left_value='primitive', name='or', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_20_{func=<lambda>, left_value='array', name='xor', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_21_{func=<lambda>, left_value='array', name='xor', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_22_{func=<lambda>, left_value='array', name='xor', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_23_{func=<lambda>, left_value='scalar', name='xor', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_24_{func=<lambda>, left_value='primitive', name='xor', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_25_{func=<lambda>, left_value='array', name='invert', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_26_{func=<lambda>, left_value='array', name='invert', right_value='scalar'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_27_{func=<lambda>, left_value='array', name='invert', right_value='primitive'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_28_{func=<lambda>, left_value='scalar', name='invert', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayBitwiseOperator_param_29_{func=<lambda>, left_value='primitive', name='invert', right_value='array'}::test_operator
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayFloorDivide_param_0_{left_value='array', right_value='array'}::test_floor_divide
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayFloorDivide_param_1_{left_value='array', right_value='scalar'}::test_floor_divide
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayFloorDivide_param_2_{left_value='array', right_value='primitive'}::test_floor_divide
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayFloorDivide_param_3_{left_value='scalar', right_value='array'}::test_floor_divide
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayFloorDivide_param_4_{left_value='primitive', right_value='array'}::test_floor_divide
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_iadd
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_iand
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_ilshift
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_imod
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_imul
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_ior
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_ipow
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_irshift
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_isub
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_itruediv_py3
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_0_{left_value='array', right_value='array'}::test_ixor
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_iadd
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_iand
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_ilshift
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_imod
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_imul
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_ior
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_ipow
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_irshift
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_isub
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_itruediv_py3
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_1_{left_value='array', right_value='scalar'}::test_ixor
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_iadd
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_iand
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_ilshift
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_imod
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_imul
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_ior
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_ipow
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_irshift
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_isub
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_itruediv_py3
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayInplaceOperator_param_2_{left_value='array', right_value='primitive'}::test_ixor
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArraySetItem::test_setitem_ellipsis
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArraySetItem::test_setitem_non_slice
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayMethods::test_all
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayMethods::test_any
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayMethods::test_copy
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayMethods::test_max
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayMethods::test_min
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayMethods::test_prod
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayMethods::test_sum
FAILED tests/cupy_tests/core_tests/fusion_tests/test_array.py::TestFusionArrayAsType::test_astype
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_0_{indices=1, shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_1_{indices=-1, shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_2_{indices=(1,), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_3_{indices=(1, 0), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_4_{indices=(1, 0, 2), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_5_{indices=(-1, 0, -2), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_6_{indices=slice(None, None, None), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_7_{indices=slice(None, None, 1), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_8_{indices=slice(None, None, -1), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_9_{indices=(slice(None, None, None), slice(None, None, -1)), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_10_{indices=Ellipsis, shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_11_{indices=(Ellipsis,), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_12_{indices=None, shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_13_{indices=(None,), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_14_{indices=(None, None, None), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_15_{indices=(slice(None, None, None), 0, slice(None, None, -1)), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_16_{indices=(1, None, slice(None, None, -1), None, 2), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_17_{indices=(slice(None, None, None), None), shape=(2,)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_18_{indices=(Ellipsis, 2), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_19_{indices=(1, Ellipsis), shape=(2, 3, 4)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexing_param_20_{indices=(1, Ellipsis, 3), shape=(2, 3, 4, 5)}::test_getitem
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexingCombination::test_indexing_and_add_1
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexingCombination::test_indexing_and_add_2
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexingCombination::test_indexing_and_add_3
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexingCombination::test_indexing_and_add_4
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexingCombination::test_indexing_twice_1
FAILED tests/cupy_tests/core_tests/fusion_tests/test_indexing.py::TestIndexingCombination::test_indexing_twice_2
FAILED tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py::TestFusionCache::test_dtype_combinations
FAILED tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py::TestFusionCache::test_memoryspace_combinations
FAILED tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py::TestFusionCache::test_same_array
FAILED tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py::TestFusionCache::test_shape_combinations
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionInplaceUpdate::test_iadd_multiple_times
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionInplaceUpdate::test_outarg_mixed
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionTuple::test_multiple_outputdifferent_type_same_ufunc
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionTuple::test_return_empty_tuple
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionTuple::test_return_singleton_tuple
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionTuple::test_return_tuple
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionTuple::test_tuple
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestReturnNone::test_iadd_once
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestReturnNone::test_iadd_twice
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionNoneParams::test_python_none_parameter
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionKernelName::test_elementwise
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionKernelName::test_elementwise_with_name
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionKernelName::test_reduction_01
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionKernelName::test_reduction_postmap
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionKernelName::test_reduction_premap
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionKernelName::test_reduction_with_name
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionComposition::test_composition
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionCompile::test_clear_cache
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionGetArrayModule::test_get_array_module
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionThread::test_thread
FAILED tests/cupy_tests/core_tests/fusion_tests/test_misc.py::TestFusionThread::test_thread_multiple_dtypes
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)}::test_fft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_0_{shape=(64,)}::test_ifft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)}::test_fft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_1_{shape=(4, 16)}::test_ifft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)}::test_fft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_2_{shape=(128,)}::test_ifft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)}::test_fft
FAILED tests/cupy_tests/cuda_tests/test_cufft.py::TestMultiGpuPlan1dNumPy_param_3_{shape=(8, 32)}::test_ifft
FAILED tests/cupy_tests/cuda_tests/test_device.py::TestDeviceHandles::test_cusparse_handle
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_0_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_1_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_2_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_3_{dimensions=(67, 0, 0), dtype=float16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_4_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_5_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_6_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_7_{dimensions=(67, 0, 0), dtype=float16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_8_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_9_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_10_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_11_{dimensions=(67, 0, 0), dtype=float16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_12_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_13_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_14_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_15_{dimensions=(67, 0, 0), dtype=float32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_16_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_17_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_18_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_19_{dimensions=(67, 0, 0), dtype=float32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_20_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_21_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_22_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_23_{dimensions=(67, 0, 0), dtype=float32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_24_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_25_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_26_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_27_{dimensions=(67, 0, 0), dtype=int8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_28_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_29_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_30_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_31_{dimensions=(67, 0, 0), dtype=int8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_32_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_33_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_34_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_35_{dimensions=(67, 0, 0), dtype=int8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_36_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_37_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_38_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_39_{dimensions=(67, 0, 0), dtype=int16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_40_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_41_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_42_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_43_{dimensions=(67, 0, 0), dtype=int16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_44_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_45_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_46_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_47_{dimensions=(67, 0, 0), dtype=int16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_48_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_49_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_50_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_51_{dimensions=(67, 0, 0), dtype=int32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_52_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_53_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_54_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_55_{dimensions=(67, 0, 0), dtype=int32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_56_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_57_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_58_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_59_{dimensions=(67, 0, 0), dtype=int32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_60_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_61_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_62_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_63_{dimensions=(67, 0, 0), dtype=uint8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_64_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_65_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_66_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_67_{dimensions=(67, 0, 0), dtype=uint8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_68_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_69_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_70_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_71_{dimensions=(67, 0, 0), dtype=uint8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_72_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_73_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_74_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_75_{dimensions=(67, 0, 0), dtype=uint16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_76_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_77_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_78_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_79_{dimensions=(67, 0, 0), dtype=uint16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_80_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_81_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_82_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_83_{dimensions=(67, 0, 0), dtype=uint16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_84_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_85_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_86_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_87_{dimensions=(67, 0, 0), dtype=uint32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_88_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_89_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_90_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_91_{dimensions=(67, 0, 0), dtype=uint32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_92_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_93_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_94_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_95_{dimensions=(67, 0, 0), dtype=uint32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_96_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_97_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_98_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_99_{dimensions=(67, 19, 0), dtype=float16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_100_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_101_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_102_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_103_{dimensions=(67, 19, 0), dtype=float16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_104_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_105_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_106_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_107_{dimensions=(67, 19, 0), dtype=float16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_108_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_109_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_110_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_111_{dimensions=(67, 19, 0), dtype=float32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_112_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_113_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_114_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_115_{dimensions=(67, 19, 0), dtype=float32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_116_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_117_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_118_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_119_{dimensions=(67, 19, 0), dtype=float32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_120_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_121_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_122_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_123_{dimensions=(67, 19, 0), dtype=int8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_124_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_125_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_126_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_127_{dimensions=(67, 19, 0), dtype=int8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_128_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_129_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_130_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_131_{dimensions=(67, 19, 0), dtype=int8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_132_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_133_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_134_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_135_{dimensions=(67, 19, 0), dtype=int16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_136_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_137_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_138_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_139_{dimensions=(67, 19, 0), dtype=int16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_140_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_141_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_142_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_143_{dimensions=(67, 19, 0), dtype=int16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_144_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_145_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_146_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_147_{dimensions=(67, 19, 0), dtype=int32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_148_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_149_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_150_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_151_{dimensions=(67, 19, 0), dtype=int32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_152_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_153_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_154_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_155_{dimensions=(67, 19, 0), dtype=int32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_156_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_157_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_158_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_159_{dimensions=(67, 19, 0), dtype=uint8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_160_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_161_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_162_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_163_{dimensions=(67, 19, 0), dtype=uint8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_164_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_165_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_166_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_167_{dimensions=(67, 19, 0), dtype=uint8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_168_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_169_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_170_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_171_{dimensions=(67, 19, 0), dtype=uint16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_172_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_173_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_174_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_175_{dimensions=(67, 19, 0), dtype=uint16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_176_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_177_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_178_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_179_{dimensions=(67, 19, 0), dtype=uint16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_180_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_181_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_182_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_183_{dimensions=(67, 19, 0), dtype=uint32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_184_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_185_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_186_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_187_{dimensions=(67, 19, 0), dtype=uint32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_188_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_189_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_190_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_191_{dimensions=(67, 19, 0), dtype=uint32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_192_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_193_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_194_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_195_{dimensions=(67, 19, 31), dtype=float16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_196_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_197_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_198_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_199_{dimensions=(67, 19, 31), dtype=float16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_200_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_201_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_202_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_203_{dimensions=(67, 19, 31), dtype=float16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_204_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_205_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_206_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_207_{dimensions=(67, 19, 31), dtype=float32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_208_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_209_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_210_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_211_{dimensions=(67, 19, 31), dtype=float32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_212_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_213_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_214_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_215_{dimensions=(67, 19, 31), dtype=float32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_216_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_217_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_218_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_219_{dimensions=(67, 19, 31), dtype=int8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_220_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_221_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_222_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_223_{dimensions=(67, 19, 31), dtype=int8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_224_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_225_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_226_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_227_{dimensions=(67, 19, 31), dtype=int8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_228_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_229_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_230_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_231_{dimensions=(67, 19, 31), dtype=int16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_232_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_233_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_234_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_235_{dimensions=(67, 19, 31), dtype=int16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_236_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_237_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_238_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_239_{dimensions=(67, 19, 31), dtype=int16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_240_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_241_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_242_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_243_{dimensions=(67, 19, 31), dtype=int32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_244_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_245_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_246_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_247_{dimensions=(67, 19, 31), dtype=int32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_248_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_249_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_250_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_251_{dimensions=(67, 19, 31), dtype=int32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_252_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_253_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_254_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_255_{dimensions=(67, 19, 31), dtype=uint8, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_256_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_257_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_258_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_259_{dimensions=(67, 19, 31), dtype=uint8, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_260_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_261_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_262_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_263_{dimensions=(67, 19, 31), dtype=uint8, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_264_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_265_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_266_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_267_{dimensions=(67, 19, 31), dtype=uint16, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_268_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_269_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_270_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_271_{dimensions=(67, 19, 31), dtype=uint16, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_272_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_273_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_274_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_275_{dimensions=(67, 19, 31), dtype=uint16, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_276_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_277_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_278_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_279_{dimensions=(67, 19, 31), dtype=uint32, n_channels=1, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_280_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_281_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_282_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_283_{dimensions=(67, 19, 31), dtype=uint32, n_channels=2, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_284_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=True, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_285_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=True, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_286_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=False, xp='numpy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestCUDAarray_param_287_{dimensions=(67, 19, 31), dtype=uint32, n_channels=4, stream=False, xp='cupy'}::test_array_gen_cpy
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_0_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_1_{dimensions=(64, 0, 0), mem_type='CUDAarray', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_2_{dimensions=(64, 0, 0), mem_type='linear', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_3_{dimensions=(64, 0, 0), mem_type='linear', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_6_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_7_{dimensions=(64, 32, 0), mem_type='CUDAarray', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_10_{dimensions=(64, 32, 0), mem_type='pitch2D', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_11_{dimensions=(64, 32, 0), mem_type='pitch2D', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_12_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='object'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTexture_param_13_{dimensions=(64, 32, 19), mem_type='CUDAarray', target='reference'}::test_fetch_float_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTextureVectorType_param_0_{target='object'}::test_fetch_float4_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestTextureVectorType_param_1_{target='reference'}::test_fetch_float4_texture
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestSurface_param_0_{dimensions=(64, 0, 0)}::test_write_float_surface
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestSurface_param_1_{dimensions=(64, 32, 0)}::test_write_float_surface
FAILED tests/cupy_tests/cuda_tests/test_texture.py::TestSurface_param_2_{dimensions=(64, 32, 32)}::test_write_float_surface
FAILED tests/cupy_tests/indexing_tests/test_generate.py::TestIX_::test_ix_ndarray
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_0_{fname='add', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_1_{fname='add', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_2_{fname='add', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_3_{fname='add', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_4_{fname='subtract', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_5_{fname='subtract', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_6_{fname='subtract', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_7_{fname='subtract', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_8_{fname='multiply', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_9_{fname='multiply', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_10_{fname='multiply', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_11_{fname='multiply', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_12_{fname='divide', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_13_{fname='divide', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_14_{fname='divide', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_15_{fname='divide', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_16_{fname='power', type_l='poly1d', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_17_{fname='power', type_l='ndarray', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_18_{fname='power', type_l='python_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1dMathArithmetic_param_19_{fname='power', type_l='numpy_scalar', type_r='poly1d'}::test_poly1d_arithmetic
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyArithmeticDiffTypes_param_2_{fname='polymul'}::test_polyroutine_diff_types_array
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyArithmeticDiffTypes_param_2_{fname='polymul'}::test_polyroutine_diff_types_poly1d
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_0_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_1_{deg=0, rcond=None, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_2_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_3_{deg=0, rcond=None, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_4_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_5_{deg=0, rcond=0.5, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_6_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_7_{deg=0, rcond=0.5, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_8_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_9_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3,), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_10_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=True}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_default
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitParametersCombinations_param_11_{deg=0, rcond=1e-15, shape1=(3,), shape2=(3, 2), weighted=False}::test_polyfit_full
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_0_{cov='unscaled', deg=0, rcond=None, shape=(3,), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_1_{cov='unscaled', deg=0, rcond=None, shape=(3,), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_2_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_3_{cov='unscaled', deg=0, rcond=None, shape=(3, 2), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_4_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_5_{cov='unscaled', deg=0, rcond=1e-15, shape=(3,), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_6_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_7_{cov='unscaled', deg=0, rcond=1e-15, shape=(3, 2), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_16_{cov=True, deg=0, rcond=None, shape=(3,), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_17_{cov=True, deg=0, rcond=None, shape=(3,), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_18_{cov=True, deg=0, rcond=None, shape=(3, 2), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_19_{cov=True, deg=0, rcond=None, shape=(3, 2), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_20_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_21_{cov=True, deg=0, rcond=1e-15, shape=(3,), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_22_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weighted=True}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyfitCovMode_param_23_{cov=True, deg=0, rcond=1e-15, shape=(3, 2), weighted=False}::test_polyfit_cov
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsReal_param_0_{input=[2, -1, -2]}::test_roots_array
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsReal_param_0_{input=[2, -1, -2]}::test_roots_poly1d
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsReal_param_1_{input=[-4, 10, 4]}::test_roots_array
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsReal_param_1_{input=[-4, 10, 4]}::test_roots_poly1d
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]}::test_roots_array
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestRootsComplex_param_0_{input=[3j, 1.5j, (-0-3j)]}::test_roots_poly1d
FAILED tests/cupy_tests/lib_tests/test_polynomial.py::TestPoly1d::test_poly1d_roots
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_0_{UPLO='U'}::test_eigh
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_0_{UPLO='U'}::test_eigh_complex
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_0_{UPLO='U'}::test_eigh_float16
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_0_{UPLO='U'}::test_eigvalsh
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_1_{UPLO='L'}::test_eigh
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_1_{UPLO='L'}::test_eigh_complex
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_1_{UPLO='L'}::test_eigh_float16
FAILED tests/cupy_tests/linalg_tests/test_eigenvalue.py::TestEigenvalue_param_1_{UPLO='L'}::test_eigvalsh
FAILED tests/cupy_tests/linalg_tests/test_einsum.py::TestEinSumUnaryOperation_param_34_{_raw_params={'orig': {'shape_a': (3, 3, 3), 'subscripts': 'iji->ij'}, 'dec': 0, 'drop': True}, shape_a=(1, 1, 1), subscripts='iji->ij'}::test_einsum_unary_dtype
FAILED tests/cupy_tests/manipulation_tests/test_dims.py::TestBroadcast_param_2_{shapes=[(1,), (1,)]}::test_broadcast_arrays
FAILED tests/cupy_tests/manipulation_tests/test_dims.py::TestBroadcast_param_3_{shapes=[(2,), (2,)]}::test_broadcast_arrays
FAILED tests/cupy_tests/math_tests/test_misc.py::TestConvolve_param_0_{mode='valid'}::test_convolve_diff_types
FAILED tests/cupy_tests/math_tests/test_misc.py::TestConvolve_param_1_{mode='same'}::test_convolve_diff_types
FAILED tests/cupy_tests/math_tests/test_misc.py::TestConvolve_param_2_{mode='full'}::test_convolve_diff_types
FAILED tests/cupy_tests/math_tests/test_rational.py::TestRational::test_lcm_check_boundary_cases
FAILED tests/cupy_tests/random_tests/test_generator.py::TestRandomState::test_methods
FAILED tests/cupy_tests/random_tests/test_generator.py::TestChoiceChi::test_goodness_of_fit_2
FAILED tests/cupy_tests/random_tests/test_sample.py::TestRandint2::test_goodness_of_fit_2
FAILED tests/cupy_tests/random_tests/test_sample.py::TestRandomIntegers2::test_goodness_of_fit_2
FAILED tests/cupy_tests/statistics_tests/test_correlation.py::TestCorrelate_param_0_{mode='valid'}::test_correlate_diff_types
FAILED tests/cupy_tests/statistics_tests/test_correlation.py::TestCorrelate_param_1_{mode='full'}::test_correlate_diff_types
FAILED tests/cupy_tests/statistics_tests/test_correlation.py::TestCorrelate_param_1_{mode='full'}::test_correlate_non_contiguous
FAILED tests/cupy_tests/statistics_tests/test_correlation.py::TestCorrelate_param_2_{mode='same'}::test_correlate_diff_types
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_0_{dtype=float32, size=5}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_1_{dtype=float32, size=9}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_2_{dtype=float32, size=17}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_3_{dtype=float32, size=33}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_4_{dtype=float64, size=5}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_5_{dtype=float64, size=9}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_6_{dtype=float64, size=17}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_7_{dtype=float64, size=33}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_8_{dtype=complex64, size=5}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_9_{dtype=complex64, size=9}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_10_{dtype=complex64, size=17}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_11_{dtype=complex64, size=33}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_12_{dtype=complex128, size=5}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_13_{dtype=complex128, size=9}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_14_{dtype=complex128, size=17}::test_invh
FAILED tests/cupyx_tests/linalg_tests/test_solve.py::TestInvh_param_15_{dtype=complex128, size=33}::test_invh
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_0_{dtype=float32}::test_basic_vstack
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_0_{dtype=float32}::test_csr
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_0_{dtype=float32}::test_csr_with_dtype
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_1_{dtype=float64}::test_basic_vstack
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_1_{dtype=float64}::test_csr
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestVstack_param_1_{dtype=float64}::test_csr_with_dtype
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_0_{dtype=float32}::test_basic_hstack
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_0_{dtype=float32}::test_csc
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_0_{dtype=float32}::test_csc_with_dtype
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_1_{dtype=float64}::test_basic_hstack
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_1_{dtype=float64}::test_csc
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestHstack_param_1_{dtype=float64}::test_csc_with_dtype
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_0_{dtype=float32}::test_basic_inputs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_0_{dtype=float32}::test_edge_cases
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_0_{dtype=float32}::test_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_0_{dtype=float32}::test_failure_cases
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_1_{dtype=float64}::test_basic_inputs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_1_{dtype=float64}::test_edge_cases
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_1_{dtype=float64}::test_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestBmat_param_1_{dtype=float64}::test_failure_cases
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}::test_random_with_data_rvs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_0_{dtype=float32, format='csr', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_1_{dtype=float32, format='csr', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}::test_random_with_data_rvs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_2_{dtype=float32, format='csc', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_3_{dtype=float32, format='csc', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_4_{dtype=float32, format='coo', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_4_{dtype=float32, format='coo', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_5_{dtype=float32, format='coo', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_5_{dtype=float32, format='coo', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}::test_random_with_data_rvs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_6_{dtype=float64, format='csr', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_7_{dtype=float64, format='csr', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}::test_random_with_data_rvs
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_8_{dtype=float64, format='csc', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}::test_random
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_9_{dtype=float64, format='csc', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_10_{dtype=float64, format='coo', random_method='random'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_10_{dtype=float64, format='coo', random_method='random'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_11_{dtype=float64, format='coo', random_method='rand'}::test_random_with_seed
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_construct.py::TestRandom_param_11_{dtype=float64, format='coo', random_method='rand'}::test_random_with_state
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_0_{dtype=float32}::test_init_copy
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_0_{dtype=float32}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_0_{dtype=float32}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_1_{dtype=float64}::test_init_copy
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_1_{dtype=float64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_1_{dtype=float64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_2_{dtype=complex64}::test_init_copy
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_2_{dtype=complex64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_2_{dtype=complex64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_3_{dtype=complex128}::test_init_copy
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_3_{dtype=complex128}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_coo.py::TestCooMatrix_param_3_{dtype=complex128}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_0_{dtype=float32}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_1_{dtype=float64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_2_{dtype=complex64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csc.py::TestCscMatrix_param_3_{dtype=complex128}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_0_{dtype=float32}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_1_{dtype=float64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_2_{dtype=complex64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_copy_other_sparse
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_data_row_col
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_dense
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_dense_empty
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_dense_one_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_init_dense_zero_dim
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_pickle_roundtrip
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_csr.py::TestCsrMatrix_param_3_{dtype=complex128}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py::TestDiaMatrix_param_0_{dtype=float32}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py::TestDiaMatrix_param_1_{dtype=float64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py::TestDiaMatrix_param_2_{dtype=complex64}::test_toarray
FAILED tests/cupyx_tests/scipy_tests/sparse_tests/test_dia.py::TestDiaMatrix_param_3_{dtype=complex128}::test_toarray
FAILED tests/example_tests/test_finance.py::TestMonteCarlo::test_monte_carlo
FAILED tests/example_tests/test_finance.py::TestMonteCarloWithMultiGPU::test_monte_carlo_multigpu
FAILED tests/install_tests/test_build.py::TestCheckVersion::test_check_cuda_version
FAILED tests/install_tests/test_build.py::TestCheckVersion::test_check_cudnn_version
XPASS tests/cupy_tests/sorting_tests/test_sort.py::TestMsort::test_msort_zero_dim Explicit error types required
= 737 failed, 24297 passed, 61504 skipped, 56 deselected, 14 xfailed, 1 xpassed, 208 warnings in 12311.77s (3:25:11) =
