============================= test session starts ==============================
platform linux -- Python 3.8.7, pytest-6.2.2, py-1.10.0, pluggy-0.13.1
rootdir: /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy, configfile: setup.cfg
plugins: html-3.1.1, metadata-1.11.0
collected 71425 items / 58 deselected / 12 skipped / 71355 selected

tests/cupy_tests/test_cublas.py ........................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  3%]
........................................................................ [  3%]
........................................................................ [  3%]
...........................x...........x.............................x.. [  3%]
.........x..........                                                     [  3%]
tests/cupy_tests/test_cudnn.py sssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssss                  [  5%]
tests/cupy_tests/test_cusolver.py ssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssss                                               [  6%]
tests/cupy_tests/test_cutensor.py ssssssssssssssssssssssssssssssssssssss [  6%]
sssssssssssssssssssssssssssssssssssss                                    [  6%]
tests/cupy_tests/test_init.py ..s.......                                 [  6%]
tests/cupy_tests/test_ndim.py ............                               [  7%]
tests/cupy_tests/test_numpy_interop.py ..x....                           [  7%]
tests/cupy_tests/test_type_routines.py ................................. [  7%]
.                                                                        [  7%]
tests/cupy_tests/binary_tests/test_elementwise.py ......                 [  7%]
tests/cupy_tests/binary_tests/test_packing.py ...                        [  7%]
tests/cupy_tests/core_tests/test_array_function.py .....                 [  7%]
tests/cupy_tests/core_tests/test_carray.py .....                         [  7%]
tests/cupy_tests/core_tests/test_core.py ......                          [  7%]
tests/cupy_tests/core_tests/test_cub_reduction.py ...................... [  7%]
...                                                                      [  7%]
tests/cupy_tests/core_tests/test_dlpack.py ....                          [  7%]
tests/cupy_tests/core_tests/test_elementwise.py ...............          [  7%]
tests/cupy_tests/core_tests/test_flags.py .............................  [  7%]
tests/cupy_tests/core_tests/test_function.py ..                          [  7%]
tests/cupy_tests/core_tests/test_internal.py ........................... [  7%]
...............................................................          [  7%]
tests/cupy_tests/core_tests/test_iter.py ............                    [  7%]
tests/cupy_tests/core_tests/test_ndarray.py ..........................ss [  7%]
ssss.................................................................... [  7%]
.........................sss...............                              [  7%]
tests/cupy_tests/core_tests/test_ndarray_adv_indexing.py ............... [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
.............................................                            [  7%]
tests/cupy_tests/core_tests/test_ndarray_complex_ops.py ................ [  7%]
.....                                                                    [  7%]
tests/cupy_tests/core_tests/test_ndarray_contiguity.py .                 [  7%]
tests/cupy_tests/core_tests/test_ndarray_conversion.py .......xx..       [  7%]
tests/cupy_tests/core_tests/test_ndarray_copy_and_view.py ss........s... [  7%]
....ssss.......                                                          [  8%]
tests/cupy_tests/core_tests/test_ndarray_cuda_array_interface.py sssssss [  8%]
sssssssssssssssssssssssssssssssssssssssssssssssss                        [  8%]
tests/cupy_tests/core_tests/test_ndarray_elementwise_op.py ............. [  8%]
........................................................................ [  8%]
.................................................................        [  8%]
tests/cupy_tests/core_tests/test_ndarray_get.py ............             [  8%]
tests/cupy_tests/core_tests/test_ndarray_indexing.py xxxx..........x...x [  8%]
........x..........x.............................                        [  8%]
tests/cupy_tests/core_tests/test_ndarray_math.py ......................s [  8%]
sssssssssss                                                              [  8%]
tests/cupy_tests/core_tests/test_ndarray_owndata.py ...                  [  8%]
tests/cupy_tests/core_tests/test_ndarray_reduction.py .................. [  8%]
........................................................................ [  8%]
........................................................................ [  8%]
................................                                         [  8%]
tests/cupy_tests/core_tests/test_ndarray_scatter.py .................... [  8%]
........................................................................ [  8%]
...............................................................          [  8%]
tests/cupy_tests/core_tests/test_ndarray_ufunc.py .......                [  8%]
tests/cupy_tests/core_tests/test_ndarray_unary_op.py .......x..........s [  8%]
...                                                                      [  8%]
tests/cupy_tests/core_tests/test_raw.py .ss.........sss..s.s.s........ss [  9%]
.........sss..s.s.s........ss.........sss..s.s.s......ssssssssssssssssss [  9%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.s [  9%]
s.......sssss....s.s......sssssssssssssssssssssssssssss                  [  9%]
tests/cupy_tests/core_tests/test_reduction.py .....................      [  9%]
tests/cupy_tests/core_tests/test_scan.py ....                            [  9%]
tests/cupy_tests/core_tests/test_syncdetect.py ....                      [  9%]
tests/cupy_tests/core_tests/test_userkernel.py ....sss.............      [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_array.py ................. [  9%]
........................................................................ [  9%]
....................................................                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_indexing.py .............. [  9%]
.................s                                                       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py ....       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_misc.py .......s.......... [  9%]
........                                                                 [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_optimization.py .......... [  9%]
....                                                                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_reduction.py ............. [  9%]
........................................................................ [  9%]
.........................................................s.s.s.s.s.s.s.s [  9%]
.s.ssssssssssssssssss.sss                                                [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_routines.py .............. [  9%]
........................................................................ [ 10%]
..............                                                           [ 10%]
tests/cupy_tests/core_tests/fusion_tests/test_ufunc.py ................. [ 10%]
......................................................                   [ 10%]
tests/cupy_tests/creation_tests/test_basic.py .......................... [ 10%]
...........................................................s............ [ 10%]
....s.                                                                   [ 10%]
tests/cupy_tests/creation_tests/test_from_data.py ssssssssssssssssssssss [ 10%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss............. [ 10%]
....................................F..............................      [ 10%]
tests/cupy_tests/creation_tests/test_matrix.py ......................... [ 10%]
.................................                                        [ 10%]
tests/cupy_tests/creation_tests/test_ranges.py ......................... [ 10%]
..............................................................           [ 10%]
tests/cupy_tests/cuda_tests/test_compiler.py sssssss........             [ 10%]
tests/cupy_tests/cuda_tests/test_cublas.py .                             [ 10%]
tests/cupy_tests/cuda_tests/test_cudnn.py s                              [ 10%]
tests/cupy_tests/cuda_tests/test_cufft.py ssssssssssssssss.              [ 10%]
tests/cupy_tests/cuda_tests/test_curand.py .....                         [ 10%]
tests/cupy_tests/cuda_tests/test_cusolver.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cusparse.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cutensor.py s                           [ 10%]
tests/cupy_tests/cuda_tests/test_device.py .............x.               [ 10%]
tests/cupy_tests/cuda_tests/test_driver.py ss.                           [ 10%]
tests/cupy_tests/cuda_tests/test_memory.py ....ssssssss................. [ 10%]
.ssssssssss.................................................ssssss       [ 10%]
tests/cupy_tests/cuda_tests/test_memory_hook.py .                        [ 10%]
tests/cupy_tests/cuda_tests/test_nccl.py ........                        [ 10%]
tests/cupy_tests/cuda_tests/test_nvrtc.py .                              [ 10%]
tests/cupy_tests/cuda_tests/test_nvtx.py ....                            [ 11%]
tests/cupy_tests/cuda_tests/test_pinned_memory.py ............           [ 11%]
tests/cupy_tests/cuda_tests/test_profile.py ..                           [ 11%]
tests/cupy_tests/cuda_tests/test_runtime.py .                            [ 11%]
tests/cupy_tests/cuda_tests/test_stream.py ..s..s..ssssssss.s            [ 11%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_debug_print.py .     [ 11%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_line_profile.py ..   [ 11%]
tests/cupy_tests/fft_tests/test_cache.py ..sss.....s..                   [ 11%]
tests/cupy_tests/fft_tests/test_callback.py ssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssss                     [ 11%]
tests/cupy_tests/fft_tests/test_fft.py ....ssss....ssss........ssss....s [ 11%]
sss........ssss....ssss........ssss....ssss........ssss....ssss........s [ 12%]
sss....ssss........ssss....ssss........ssss....ssss........ssss....ssss. [ 12%]
.......ssss....ssss....................................................s [ 12%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 12%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss. [ 12%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 12%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s [ 12%]
..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s.. [ 12%]
s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s. [ 12%]
s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s. [ 12%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 13%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.s.s.sssss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.sssss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.sss [ 13%]
ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.s.s..s.s. [ 13%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 13%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s...ss..ss....ss..ss....ss..ss....ss [ 13%]
..ss....ss..ss....ss..ss....ss..ss....ss..ss...s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.s.s.s.s.s.s.s.s.s.s.s.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s. [ 13%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 14%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s......s.s..s.s..s.s..s.s..s.s..s.s. [ 14%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 14%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s [ 14%]
..s.s..s.s..s.s..s.s..s.s..s.s..s.s.sssss.s.s..s.s.sssssssssssssssssssss [ 14%]
ssssssssssssssssssssssssssssssssssssssssssss.s.s..s.s..s.s..s.s..s.s..s. [ 14%]
s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s. [ 14%]
.s.s..s.s..s.s..s.s..s.s..s.s.......ss..ss....ss..ss....ss..ss....ss..ss [ 14%]
....ss..ss....ss..ss....ss..ss....ss..ss........................         [ 14%]
tests/cupy_tests/functional_tests/test_piecewise.py .............        [ 14%]
tests/cupy_tests/functional_tests/test_vectorize.py .................... [ 14%]
.......................FF.......                                         [ 14%]
tests/cupy_tests/indexing_tests/test_generate.py .......x............... [ 14%]
...............                                                          [ 14%]
tests/cupy_tests/indexing_tests/test_indexing.py ....................... [ 15%]
.........................                                                [ 15%]
tests/cupy_tests/indexing_tests/test_insert.py ......................... [ 15%]
........................................................................ [ 15%]
........................................................................ [ 15%]
.........................................................                [ 15%]
tests/cupy_tests/indexing_tests/test_iterate.py ........................ [ 15%]
...............................................                          [ 15%]
tests/cupy_tests/io_tests/test_base_n.py ............................    [ 15%]
tests/cupy_tests/io_tests/test_formatting.py ..                          [ 15%]
tests/cupy_tests/io_tests/test_npz.py .......                            [ 15%]
tests/cupy_tests/lib_tests/test_polynomial.py .......ss.......ssssssssss [ 15%]
sssssss........ssssssssssssssssssssssssssssssssssssxxxxxxxxxxxxxxxxxxxx. [ 15%]
..ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 15%]
ssssssssssssssssssssssssss......xxxxxxxxxxxxxxxxxxxxxxxx................ [ 15%]
........................................................................ [ 15%]
........xxxxxxxx........xxxxxxxx........................................ [ 16%]
...........xxxxxx............................x.......................... [ 16%]
..                                                                       [ 16%]
tests/cupy_tests/lib_tests/test_shape_base.py ......................     [ 16%]
tests/cupy_tests/lib_tests/test_strided_tricks.py ..                     [ 16%]
tests/cupy_tests/linalg_tests/test_decomposition.py .................... [ 16%]
.......................                                                  [ 16%]
tests/cupy_tests/linalg_tests/test_eigenvalue.py xxxxxxxx                [ 16%]
tests/cupy_tests/linalg_tests/test_einsum.py ........................... [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
..........                                                               [ 17%]
tests/cupy_tests/linalg_tests/test_norms.py ............................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
.................................................................        [ 17%]
tests/cupy_tests/linalg_tests/test_product.py .......................... [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
..........................................                               [ 17%]
tests/cupy_tests/linalg_tests/test_solve.py ............................ [ 18%]
                                                                         [ 18%]
tests/cupy_tests/logic_tests/test_comparison.py ........................ [ 18%]
.....                                                                    [ 18%]
tests/cupy_tests/logic_tests/test_content.py ...                         [ 18%]
tests/cupy_tests/logic_tests/test_ops.py ....                            [ 18%]
tests/cupy_tests/logic_tests/test_truth.py ............................. [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 19%]
...........................................                              [ 19%]
tests/cupy_tests/logic_tests/test_type_test.py ......................... [ 19%]
.......                                                                  [ 19%]
tests/cupy_tests/manipulation_tests/test_add_remove.py ................. [ 19%]
.........................                                                [ 19%]
tests/cupy_tests/manipulation_tests/test_basic.py ...................... [ 19%]
.......................................................                  [ 19%]
tests/cupy_tests/manipulation_tests/test_dims.py .....x.x............... [ 19%]
................................................                         [ 19%]
tests/cupy_tests/manipulation_tests/test_join.py ....................... [ 19%]
...........................                                              [ 19%]
tests/cupy_tests/manipulation_tests/test_kind.py ...........             [ 19%]
tests/cupy_tests/manipulation_tests/test_rearrange.py .................. [ 19%]
.......................................................                  [ 19%]
tests/cupy_tests/manipulation_tests/test_shape.py ...................... [ 19%]
....................................                                     [ 19%]
tests/cupy_tests/manipulation_tests/test_split.py ..................     [ 19%]
tests/cupy_tests/manipulation_tests/test_tiling.py ..................... [ 19%]
...........                                                              [ 19%]
tests/cupy_tests/manipulation_tests/test_transpose.py .................. [ 19%]
..........                                                               [ 19%]
tests/cupy_tests/math_tests/test_arithmetic.py ......................... [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 31%]
...........................                                              [ 31%]
tests/cupy_tests/math_tests/test_explog.py .........                     [ 31%]
tests/cupy_tests/math_tests/test_floating.py .......                     [ 31%]
tests/cupy_tests/math_tests/test_hyperbolic.py ......                    [ 31%]
tests/cupy_tests/math_tests/test_matmul.py ............................. [ 31%]
........................................................................ [ 31%]
........................................................................ [ 31%]
........................................................................ [ 31%]
...............................................                          [ 31%]
tests/cupy_tests/math_tests/test_misc.py ............................... [ 31%]
............................................x..x..x..................... [ 31%]
............................                                             [ 31%]
tests/cupy_tests/math_tests/test_rational.py ....                        [ 31%]
tests/cupy_tests/math_tests/test_rounding.py ........................... [ 31%]
..........................................                               [ 31%]
tests/cupy_tests/math_tests/test_special.py ...                          [ 31%]
tests/cupy_tests/math_tests/test_sumprod.py ............................ [ 31%]
....................................................ssssssssssssssss.... [ 31%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
..............................................................           [ 32%]
tests/cupy_tests/math_tests/test_trigonometric.py ...............        [ 32%]
tests/cupy_tests/math_tests/test_window.py ............................. [ 32%]
.....                                                                    [ 32%]
tests/cupy_tests/misc_tests/test_memory_ranges.py ................       [ 32%]
tests/cupy_tests/misc_tests/test_who.py ......                           [ 32%]
tests/cupy_tests/padding_tests/test_pad.py ......F...................... [ 33%]
..............................................                           [ 33%]
tests/cupy_tests/polynomial_tests/test_polynomial.py ................... [ 33%]
                                                                         [ 33%]
tests/cupy_tests/polynomial_tests/test_polyutils.py .................... [ 33%]
................                                                         [ 33%]
tests/cupy_tests/prof_tests/test_range.py ........                       [ 33%]
tests/cupy_tests/random_tests/test_bit_generator.py ssssssssssss         [ 33%]
tests/cupy_tests/random_tests/test_distributions.py .................... [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
.................................................                        [ 34%]
tests/cupy_tests/random_tests/test_generator.py ........................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 35%]
......................s.s............................................... [ 35%]
............................x...............................             [ 35%]
tests/cupy_tests/random_tests/test_generator_api.py ssssssssssssssssssss [ 35%]
sssssssssssssss                                                          [ 35%]
tests/cupy_tests/random_tests/test_init.py .                             [ 35%]
tests/cupy_tests/random_tests/test_permutations.py ...x...x............. [ 35%]
........................................................................ [ 35%]
........................................................................ [ 35%]
.............                                                            [ 35%]
tests/cupy_tests/random_tests/test_random.py .                           [ 35%]
tests/cupy_tests/random_tests/test_sample.py ...............x........x.. [ 35%]
............                                                             [ 35%]
tests/cupy_tests/sorting_tests/test_count.py ....                        [ 35%]
tests/cupy_tests/sorting_tests/test_search.py ssssssss........ssssssss.. [ 35%]
........................................................................ [ 35%]
........................................................................ [ 35%]
....................................................................     [ 35%]
tests/cupy_tests/sorting_tests/test_sort.py ............................ [ 35%]
........................................................................ [ 36%]
..........................................................x...........   [ 36%]
tests/cupy_tests/statistics_tests/test_correlation.py .................. [ 36%]
..............................x..x.xx...................                 [ 36%]
tests/cupy_tests/statistics_tests/test_histogram.py .................... [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................                 [ 36%]
tests/cupy_tests/statistics_tests/test_meanvar.py ...................... [ 36%]
........................................................................ [ 36%]
........................................................................ [ 37%]
..                                                                       [ 37%]
tests/cupy_tests/statistics_tests/test_order.py sssss................... [ 37%]
.........................                                                [ 37%]
tests/cupy_tests/testing_tests/test_array.py ........................... [ 37%]
...............................................                          [ 37%]
tests/cupy_tests/testing_tests/test_condition.py ................        [ 37%]
tests/cupy_tests/testing_tests/test_helper.py .......................... [ 37%]
........................................................................ [ 37%]
.....sssss..sssssss..ssxxxxxxxx................x..x.................     [ 37%]
tests/cupy_tests/testing_tests/test_parameterized.py ............s.s.s.s [ 37%]
....ssss......                                                           [ 37%]
tests/cupyx_tests/test_cupyx.py ..                                       [ 37%]
tests/cupyx_tests/test_lapack.py .s.s.s.s.....s.s.s.s.....s.s.s.s.....s. [ 37%]
s.s.s.............sssssssssssss                                          [ 37%]
tests/cupyx_tests/test_optimize.py sssssssss                             [ 37%]
tests/cupyx_tests/test_rsqrt.py .                                        [ 37%]
tests/cupyx_tests/test_runtime.py s.                                     [ 37%]
tests/cupyx_tests/test_scatter.py ...                                    [ 37%]
tests/cupyx_tests/test_time.py .........                                 [ 37%]
tests/cupyx_tests/fallback_mode_tests/test_fallback.py ................. [ 37%]
........................................................................ [ 37%]
.........                                                                [ 37%]
tests/cupyx_tests/fallback_mode_tests/test_notifications.py .........    [ 37%]
tests/cupyx_tests/jit_tests/test_raw.py ....                             [ 37%]
tests/cupyx_tests/linalg_tests/test_solve.py xxxxxxxxxxxxxxxx....ssss    [ 37%]
tests/cupyx_tests/scipy_tests/test_get_array_module.py ..                [ 37%]
tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py .................... [ 37%]
........................................................................ [ 37%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 48%]
........................................................................ [ 48%]
........................................................................ [ 48%]
.................sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss........................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
......................................                                   [ 51%]
tests/cupyx_tests/scipy_tests/fft_tests/test_helper.py .                 [ 51%]
tests/cupyx_tests/scipy_tests/fftpack_tests/test_fftpack.py ............ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
.........................                                                [ 52%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py ........... [ 52%]
.............................................F..F..                      [ 52%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_solve_triangular.py .... [ 52%]
........................................................................ [ 52%]
........................................................................ [ 53%]
........................................................................ [ 53%]
....................................................................     [ 53%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_special_matrices.py .... [ 53%]
........................................................................ [ 53%]
.................................................                        [ 53%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py ...sss...... [ 53%]
sss......sss......sss......sss......sss.........sss......sss......sss... [ 53%]
...sss......sss......sss................................................ [ 53%]
...........................................................sss......sss. [ 53%]
.....sss......sss......sss......sss.........sss......sss......sss......s [ 53%]
ss......sss......sss.................................................... [ 53%]
.......................................................sss......sss..... [ 54%]
.sss......sss......sss......sss.........sss......sss......sss......sss.. [ 54%]
....sss......sss........................................................ [ 54%]
...................................................sss......sss......sss [ 54%]
......sss......sss......sss.........sss......sss......sss......sss...... [ 54%]
sss......sss............................................................ [ 54%]
...............................................sss......sss......sss.... [ 54%]
..sss......sss......sss.........sss......sss......sss......sss......sss. [ 54%]
.....sss................................................................ [ 54%]
...........................................sss......sss......sss......ss [ 54%]
s......sss......sss.........sss......sss......sss......sss......sss..... [ 55%]
.sss.................................................................... [ 55%]
.......................................sss......sss......sss......sss... [ 55%]
...sss......sss.........sss......sss......sss......sss......sss......sss [ 55%]
........................................................................ [ 55%]
...................................sss......sss......sss......sss......s [ 55%]
ss......sss.........sss......sss......sss......sss......sss......sss.... [ 55%]
........................................................................ [ 55%]
...............................sss......sss......sss......sss......sss.. [ 55%]
....sss.........sss......sss......sss......sss......sss......sss........ [ 55%]
........................................................................ [ 56%]
...........................sss......sss......sss......sss......sss...... [ 56%]
sss.........sss......sss......sss......sss......sss......sss............ [ 56%]
........................................................................ [ 56%]
.......................sss......sss......sss......sss......sss......sss. [ 56%]
........sss......sss......sss......sss......sss......sss................ [ 56%]
........................................................................ [ 56%]
...................sss......sss......sss......sss......sss......sss..... [ 56%]
....sss......sss......sss......sss......sss......sss.................... [ 56%]
........................................................................ [ 56%]
...............sss......sss......sss......sss......sss......sss......... [ 57%]
sss......sss......sss......sss......sss......sss........................ [ 57%]
........................................................................ [ 57%]
...........sss......sss......sss......sss......sss......sss.........sss. [ 57%]
.....sss......sss......sss......sss......sss............................ [ 57%]
........................................................................ [ 57%]
xxx....sss......sss......sss......sss......sss......sss....x..x.sss.x..x [ 57%]
.sss.x..x.sss......sss......sss......sss................................ [ 57%]
.....................................................x..x.............x. [ 57%]
......................................x.....x....x.....x......x.....x... [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................F.F.F.F......................................... [ 59%]
........................................................................ [ 59%]
................................................F.F..................... [ 59%]
........................................................................ [ 59%]
................................................................F.F.F.F. [ 59%]
........................................................................ [ 59%]
........................................................................ [ 59%]
................F.F..................................................... [ 59%]
........................................................................ [ 59%]
........................................................................ [ 59%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 60%]
........................................................................ [ 60%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 60%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 61%]
.............................................................s.s.s.s.s.s [ 61%]
.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 61%]
........................................................................ [ 61%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 61%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 61%]
.............................................................s.s.s.s.s.s [ 61%]
.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 61%]
........................................................................ [ 61%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 61%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 62%]
.............................................................s.s.s.s.s.s [ 62%]
.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 62%]
........................................................................ [ 62%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 62%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 62%]
.............................................................s.s.s.s.s.s [ 62%]
.s.s.s.s.s.s.s.s.s.s.s.ssss..sss..sss............sss..sss..sss.......... [ 62%]
..sss..sss..sss............sss..sss..sss............sss..sss..sss....... [ 62%]
.....sss..sss..sss............sss..sss..sss............sss..sss..sss.... [ 62%]
........sss..sss..sss............sss..sss..sss............sss..sss..sss. [ 63%]
...........sss..sss..sss................................................ [ 63%]
........................................................................ [ 63%]
....................................                                     [ 63%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_fourier.py ............ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 64%]
........................................                                 [ 64%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py ...... [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
...............................F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 75%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 76%]
.F...F.F...F.F...F.............F...F.F...F.F...F.F...F.............F...F [ 77%]
.F...F.F...F.F...F...................................................... [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
.....................s.................................................. [ 78%]
........................................................................ [ 78%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
...........................F........F..F..F........s.................... [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
.......F.....F....................F.....F....................F.....F.... [ 80%]
................F.....F....................F.....F....................F. [ 80%]
....F....................F.....F....................F.....F............. [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................s............................... [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
.................................ss..................................... [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
...........ssssssssssssssssssssssssssssssssssssssssssssssss              [ 82%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py ....... [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 86%]
........................................................................ [ 86%]
........................................................................ [ 86%]
........................................................................ [ 86%]
.....xx..........xx..........xx..........xx..........xx..........FF..... [ 86%]
.....xx..................................xx............................. [ 86%]
.....xx..........xx..........xx..........xx..........xx................. [ 86%]
.....xx..................................xx............................. [ 86%]
........................................................................ [ 86%]
........................................................................ [ 86%]
...                                                                      [ 86%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_morphology.py ......... [ 86%]
......................s....s....s..s....s....s.......................... [ 87%]
..........s....s....s..s....s....s....................................s. [ 87%]
...s....s..s....s....s....................................s....s....s..s [ 87%]
....s....s....................................s....s....s..s....s....s.. [ 87%]
..................................s....s....s..s....s....s.............. [ 87%]
......................s....s....s..s....s....s.......................... [ 87%]
..........s....s....s..s....s....s....................................s. [ 87%]
...s....s..s....s....s....................................s....s....s..s [ 87%]
....s....s....................................s....s....s..s....s....s.. [ 87%]
..................................s....s....s..s....s....s.............. [ 88%]
......................s....s....s..s....s....s.......................... [ 88%]
..........s....s....s..s....s....s....................................s. [ 88%]
...s....s..s....s....s....................................s....s....s..s [ 88%]
....s....s....................................s....s....s..s....s....s.. [ 88%]
..................................s....s....s..s....s....s.............. [ 88%]
......................s....s....s..s....s....s.......................... [ 88%]
..........s....s....s..s....s....s....................................s. [ 88%]
...s....s..s....s....s....................................s....s....s..s [ 88%]
....s....s....................................s....s....s..s....s....s.. [ 88%]
..................................s....s....s..s....s....s.............. [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
.......................................................................s [ 89%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 89%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............. [ 93%]
........................................................................ [ 93%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 93%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 93%]
..........................................s....s....s....s....s....s.... [ 93%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 93%]
s....s....s....s........................................................ [ 94%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 94%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 94%]
..........................................s....s....s....s....s....s.... [ 94%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 94%]
s....s....s....s........................................................ [ 94%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 94%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 94%]
..........................................s....s....s....s....s....s.... [ 94%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 94%]
s....s....s....s........................................................ [ 95%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 95%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 95%]
..........................................s....s....s....s....s....s.... [ 95%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 95%]
s....s....s....s........................................................ [ 95%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 95%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 95%]
..........................................s....s....s....s....s....s.... [ 95%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 95%]
s....s....s....s........................................................ [ 96%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 96%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 96%]
..........................................s....s....s....s....s....s.... [ 96%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 96%]
s....s....s....s........................................................ [ 96%]
........................................................................ [ 96%]
........................................................................ [ 96%]
........................................................................ [ 96%]
........................................................ssssssss........ [ 96%]
........................................................ssssssss........ [ 97%]
........................................................ssssssss........ [ 97%]
........................................................ssssssss........ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
                                                                         [ 98%]
tests/cupyx_tests/scipy_tests/signal_tests/test_bsplines.py ............ [ 98%]
                                                                         [ 98%]
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py ......... [ 98%]
........................................................................ [ 98%]
......................................................xxxxxxxxx......... [ 98%]
...........................xxxxxxxxxxxx................................. [ 99%]
............xxx..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x.. [ 99%]
x.x..................................................................... [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
....................................                                     [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_bessel.py ............  [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_convex_analysis.py .... [ 99%]
.                                                                        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_digamma.py .....        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_erf.py ............     [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gamma.py ....           [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gammaln.py ....         [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_polygamma.py ....       [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_statistics.py ..        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_zeta.py ....            [ 99%]
tests/cupyx_tests/scipy_tests/stats_tests/test_distributions.py ........ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
                                                                         [ 99%]
tests/cupyx_tests/tools_tests/test_install_library.py ......             [ 99%]
tests/example_tests/test_finance.py ...                                  [ 99%]
tests/example_tests/test_gemm.py .                                       [ 99%]
tests/example_tests/test_gmm.py ss                                       [ 99%]
tests/example_tests/test_kmeans.py sss                                   [ 99%]
tests/install_tests/test_build.py sx.                                    [ 99%]
tests/install_tests/test_utils.py ..                                     [100%]

=================================== FAILURES ===================================
______________ TestFromData.test_array_from_list_of_numpy_scalar _______________
cupy/testing/_helper.py:1175: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:648: in check_func
    _array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([0, 1]), y = array([0, 1]), err_msg = '', verbose = True
strides_check = True

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 2 (50%)
E       Max absolute difference: 4575657221408423936
E       Max relative difference: 0.
E        x: array([4575657221408423936,                   1])
E        y: array([0, 1])

cupy/testing/_array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int64'>
order is C
_____________________ TestVectorizeStmts.test_return_tuple _____________________

self = <cupy_tests.functional_tests.test_vectorize.TestVectorizeStmts testMethod=test_return_tuple>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_array_equal()
    def test_return_tuple(self, xp):
        def func_tuple(x, y):
            return x + y, x / y
    
        f = xp.vectorize(func_tuple)
        x = xp.array([0, 1, 2, 3, 4])
        y = xp.array([5, 6, 7, 8, 9])
>       return f(x, y)

tests/cupy_tests/functional_tests/test_vectorize.py:501: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/_functional/vectorize.py:97: in __call__
    return kern(*args)
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2021: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:428: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:811: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:271: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:255: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f9dea177340>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/core/include', '-I/opt/rocm/include')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           AssertionError: Only cupy raises error
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 623, in compile
E               nvrtc.compileProgram(self.ptr, options)
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 133, in cupy_backends.cuda.libs.nvrtc.compileProgram
E               cpdef compileProgram(intptr_t prog, options):
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 145, in cupy_backends.cuda.libs.nvrtc.compileProgram
E               check_status(status)
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 64, in cupy_backends.cuda.libs.nvrtc.check_status
E               raise NVRTCError(status)
E           cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)
E           
E           During handling of the above exception, another exception occurred:
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/testing/_helper.py", line 47, in _call_func
E               result = impl(self, *args, **kw)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/tests/cupy_tests/functional_tests/test_vectorize.py", line 501, in test_return_tuple
E               return f(x, y)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/_functional/vectorize.py", line 97, in __call__
E               return kern(*args)
E             File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
E               kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
E             File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
E               kern = _get_elementwise_kernel(
E             File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
E               result = f(*args, **kwargs)
E             File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
E               return _get_simple_elementwise_kernel(
E             File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
E               cpdef function.Function _get_simple_elementwise_kernel(
E             File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
E               module = compile_with_cache(module_code, options)
E             File "cupy/core/core.pyx", line 2021, in cupy.core.core.compile_with_cache
E               return cuda.compile_with_cache(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 428, in compile_with_cache
E               return _compile_with_cache_hip(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 811, in _compile_with_cache_hip
E               binary, mapping = compile_using_nvrtc(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 271, in compile_using_nvrtc
E               return _compile(source, options, cu_path,
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 255, in _compile
E               ptx, mapping = prog.compile(options, log_stream)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 635, in compile
E               raise CompileException(log, self.src, self.name, options,
E           cupy.cuda.compiler.CompileException: /tmp/comgr-2e9a76/input/CompileSource:5368:12: error: no template named 'tuple' in namespace 'thrust'; did you mean 'std::tuple'?
E           __device__ thrust::tuple<long long, double> func_tuple(long long x, long long y) {
E                      ^~~~~~~~~~~~~
E                      std::tuple
E           /usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple:556:11: note: 'std::tuple' declared here
E               class tuple : public _Tuple_impl<0, _Elements...>
E                     ^
E           /tmp/comgr-2e9a76/input/CompileSource:5369:10: error: no member named 'make_tuple' in namespace 'thrust'; did you mean 'std::make_tuple'?
E             return thrust::make_tuple((x + y), ((double)x / (double)y));
E                    ^~~~~~~~~~~~~~~~~~
E                    std::make_tuple
E           /usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple:1448:5: note: 'std::make_tuple' declared here
E               make_tuple(_Elements&&... __args)
E               ^
E           /tmp/comgr-2e9a76/input/CompileSource:5379:9: error: no member named 'tie' in namespace 'thrust'
E           thrust::tie(out0, out1) = func_tuple(in0, in1);
E           ~~~~~~~~^
E           3 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:635: AssertionError
________________________ TestVectorizeStmts.test_tuple _________________________

self = <cupy_tests.functional_tests.test_vectorize.TestVectorizeStmts testMethod=test_tuple>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/__init__.py'>

    @testing.numpy_cupy_array_equal()
    def test_tuple(self, xp):
        def func_tuple(x, y):
            x, y = y, x
            z = x, y
            a, b = z
            return a * a + b
    
        f = xp.vectorize(func_tuple)
        x = xp.array([0, 1, 2, 3, 4])
        y = xp.array([5, 6, 7, 8, 9])
>       return f(x, y)

tests/cupy_tests/functional_tests/test_vectorize.py:491: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/_functional/vectorize.py:97: in __call__
    return kern(*args)
cupy/core/_kernel.pyx:840: in cupy.core._kernel.ElementwiseKernel.__call__
    kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
cupy/core/_kernel.pyx:865: in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
    kern = _get_elementwise_kernel(
cupy/_util.pyx:59: in cupy._util.memoize.decorator.ret
    result = f(*args, **kwargs)
cupy/core/_kernel.pyx:652: in cupy.core._kernel._get_elementwise_kernel
    return _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:38: in cupy.core._kernel._get_simple_elementwise_kernel
    cpdef function.Function _get_simple_elementwise_kernel(
cupy/core/_kernel.pyx:61: in cupy.core._kernel._get_simple_elementwise_kernel
    module = compile_with_cache(module_code, options)
cupy/core/core.pyx:2021: in cupy.core.core.compile_with_cache
    return cuda.compile_with_cache(
cupy/cuda/compiler.py:428: in compile_with_cache
    return _compile_with_cache_hip(
cupy/cuda/compiler.py:811: in _compile_with_cache_hip
    binary, mapping = compile_using_nvrtc(
cupy/cuda/compiler.py:271: in compile_using_nvrtc
    return _compile(source, options, cu_path,
cupy/cuda/compiler.py:255: in _compile
    ptx, mapping = prog.compile(options, log_stream)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <cupy.cuda.compiler._NVRTCProgram object at 0x7f9f63295ca0>
options = ('-I/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/core/include', '-I/opt/rocm/include')
log_stream = None

    def compile(self, options=(), log_stream=None):
        try:
            if self.name_expressions:
                for ker in self.name_expressions:
                    nvrtc.addAddNameExpression(self.ptr, ker)
            nvrtc.compileProgram(self.ptr, options)
            mapping = None
            if self.name_expressions:
                mapping = {}
                for ker in self.name_expressions:
                    mapping[ker] = nvrtc.getLoweredName(self.ptr, ker)
            if log_stream is not None:
                log_stream.write(nvrtc.getProgramLog(self.ptr))
            # TODO(leofang): use getCUBIN() for _cuda_version >= 11010?
            return nvrtc.getPTX(self.ptr), mapping
        except nvrtc.NVRTCError:
            log = nvrtc.getProgramLog(self.ptr)
>           raise CompileException(log, self.src, self.name, options,
                                   'nvrtc' if not runtime.is_hip else 'hiprtc')
E           AssertionError: Only cupy raises error
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 623, in compile
E               nvrtc.compileProgram(self.ptr, options)
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 133, in cupy_backends.cuda.libs.nvrtc.compileProgram
E               cpdef compileProgram(intptr_t prog, options):
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 145, in cupy_backends.cuda.libs.nvrtc.compileProgram
E               check_status(status)
E             File "cupy_backends/cuda/libs/nvrtc.pyx", line 64, in cupy_backends.cuda.libs.nvrtc.check_status
E               raise NVRTCError(status)
E           cupy_backends.cuda.libs.nvrtc.NVRTCError: HIPRTC_ERROR_COMPILATION (6)
E           
E           During handling of the above exception, another exception occurred:
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/testing/_helper.py", line 47, in _call_func
E               result = impl(self, *args, **kw)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/tests/cupy_tests/functional_tests/test_vectorize.py", line 491, in test_tuple
E               return f(x, y)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/_functional/vectorize.py", line 97, in __call__
E               return kern(*args)
E             File "cupy/core/_kernel.pyx", line 840, in cupy.core._kernel.ElementwiseKernel.__call__
E               kern = self._get_elementwise_kernel(dev_id, arginfos, type_map)
E             File "cupy/core/_kernel.pyx", line 865, in cupy.core._kernel.ElementwiseKernel._get_elementwise_kernel
E               kern = _get_elementwise_kernel(
E             File "cupy/_util.pyx", line 59, in cupy._util.memoize.decorator.ret
E               result = f(*args, **kwargs)
E             File "cupy/core/_kernel.pyx", line 652, in cupy.core._kernel._get_elementwise_kernel
E               return _get_simple_elementwise_kernel(
E             File "cupy/core/_kernel.pyx", line 38, in cupy.core._kernel._get_simple_elementwise_kernel
E               cpdef function.Function _get_simple_elementwise_kernel(
E             File "cupy/core/_kernel.pyx", line 61, in cupy.core._kernel._get_simple_elementwise_kernel
E               module = compile_with_cache(module_code, options)
E             File "cupy/core/core.pyx", line 2021, in cupy.core.core.compile_with_cache
E               return cuda.compile_with_cache(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 428, in compile_with_cache
E               return _compile_with_cache_hip(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 811, in _compile_with_cache_hip
E               binary, mapping = compile_using_nvrtc(
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 271, in compile_using_nvrtc
E               return _compile(source, options, cu_path,
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 255, in _compile
E               ptx, mapping = prog.compile(options, log_stream)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/cuda/compiler.py", line 635, in compile
E               raise CompileException(log, self.src, self.name, options,
E           cupy.cuda.compiler.CompileException: /tmp/comgr-909ce0/input/CompileSource:5369:3: error: no template named 'tuple' in namespace 'thrust'; did you mean 'std::tuple'?
E             thrust::tuple<long long, long long> z;
E             ^~~~~~~~~~~~~
E             std::tuple
E           /usr/lib/gcc/x86_64-linux-gnu/7.5.0/../../../../include/c++/7.5.0/tuple:556:11: note: 'std::tuple' declared here
E               class tuple : public _Tuple_impl<0, _Elements...>
E                     ^
E           /tmp/comgr-909ce0/input/CompileSource:5372:11: error: no member named 'tie' in namespace 'thrust'
E             thrust::tie(x, y) = thrust::make_tuple(y, x);
E             ~~~~~~~~^
E           /tmp/comgr-909ce0/input/CompileSource:5372:31: error: no member named 'make_tuple' in namespace 'thrust'
E             thrust::tie(x, y) = thrust::make_tuple(y, x);
E                                 ~~~~~~~~^
E           /tmp/comgr-909ce0/input/CompileSource:5373:15: error: no member named 'make_tuple' in namespace 'thrust'
E             z = thrust::make_tuple(x, y);
E                 ~~~~~~~~^
E           /tmp/comgr-909ce0/input/CompileSource:5374:11: error: no member named 'tie' in namespace 'thrust'
E             thrust::tie(a, b) = z;
E             ~~~~~~~~^
E           5 errors generated when compiling for gfx906.
E           Error: Failed to compile opencl source (from CL or HIP source to LLVM IR).

cupy/cuda/compiler.py:635: AssertionError
_ TestPadDefault_param_6_{array=array([[0, 1, 2],
       [3, 4, 5]]), mode='linear_ramp', pad_width=1}.test_pad_default _
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:648: in check_func
    _array.assert_array_equal(x, y, err_msg, verbose, strides_check)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[0, 1, 2],
       [3, 4, 5]], dtype=int8)
y = array([[0, 1, 2],
       [3, 4, 5]], dtype=int8), err_msg = ''
verbose = True, strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 1 / 6 (16.7%)
E       Max absolute difference: 1
E       Max relative difference: 1.
E        x: array([[0, 0, 2],
E              [3, 4, 5]], dtype=int8)
E        y: array([[0, 1, 2],
E              [3, 4, 5]], dtype=int8)

cupy/testing/_array.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.int8'>
______ TestLUSolve_param_0_{shapes=((4, 4), (4,)), trans=0}.test_lu_solve ______

self = <<cupyx_tests.scipy_tests.linalg_tests.test_decomp_lu.TestLUSolve_param_0_{shapes=((4, 4), (4,)), trans=0} testMethod=test_lu_solve>  parameter: {'shapes': ((4, 4), (4,)), 'trans': 0}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/__init__.py'>
scp = <module 'cupyx.scipy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupyx/scipy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_dtypes('fdFD')
    @testing.numpy_cupy_allclose(atol=1e-5, scipy_name='scp')
    def test_lu_solve(self, xp, scp, dtype):
        a_shape, b_shape = self.shapes
        A = testing.shaped_random(a_shape, xp, dtype=dtype)
        b = testing.shaped_random(b_shape, xp, dtype=dtype)
        lu = scp.linalg.lu_factor(A)
>       return scp.linalg.lu_solve(lu, b, trans=self.trans)

tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lu_and_piv = (array([[  4.236548   +9.786183j  ,   6.458941   +7.9915857j ,
          4.375872   +4.614794j  ,   8.91773    +7.8052...       -0.6066229  -0.41192332j, -10.515662   +8.309107j  ]],
      dtype=complex64), array([1, 1, 2, 3], dtype=int32))
b = array([ 0.33598816-0.05543445j,  0.16491814+0.38266957j,
       -0.22301029-0.13307956j,  0.54701537-0.34111553j], dtype=complex64)
trans = 0, overwrite_b = False, check_finite = True

    def lu_solve(lu_and_piv, b, trans=0, overwrite_b=False, check_finite=True):
        """Solve an equation system, ``a * x = b``, given the LU factorization of ``a``
    
        Args:
            lu_and_piv (tuple): LU factorization of matrix ``a`` (``(M, M)``)
                together with pivot indices.
            b (cupy.ndarray): The matrix with dimension ``(M,)`` or
                ``(M, N)``.
            trans ({0, 1, 2}): Type of system to solve:
    
                ========  =========
                trans     system
                ========  =========
                0         a x  = b
                1         a^T x = b
                2         a^H x = b
                ========  =========
            overwrite_b (bool): Allow overwriting data in b (may enhance
                performance)
            check_finite (bool): Whether to check that the input matrices contain
                only finite numbers. Disabling may give a performance gain, but may
                result in problems (crashes, non-termination) if the inputs do
                contain infinities or NaNs.
    
        Returns:
            cupy.ndarray:
                The matrix with dimension ``(M,)`` or ``(M, N)``.
    
        .. seealso:: :func:`scipy.linalg.lu_solve`
        """
    
        (lu, ipiv) = lu_and_piv
    
        _util._assert_cupy_array(lu)
        _util._assert_rank2(lu)
        _util._assert_nd_squareness(lu)
    
        m = lu.shape[0]
        if m != b.shape[0]:
            raise ValueError('incompatible dimensions.')
    
        dtype = lu.dtype
        if dtype.char == 'f':
            getrs = cusolver.sgetrs
        elif dtype.char == 'd':
            getrs = cusolver.dgetrs
        elif dtype.char == 'F':
            getrs = cusolver.cgetrs
        elif dtype.char == 'D':
            getrs = cusolver.zgetrs
        else:
            msg = 'Only float32, float64, complex64 and complex128 are supported.'
            raise NotImplementedError(msg)
    
        if trans == 0:
            trans = cublas.CUBLAS_OP_N
        elif trans == 1:
            trans = cublas.CUBLAS_OP_T
        elif trans == 2:
            trans = cublas.CUBLAS_OP_C
        else:
            raise ValueError('unknown trans')
    
        lu = lu.astype(dtype, order='F', copy=False)
        ipiv = ipiv.astype(ipiv.dtype, order='F', copy=True)
        # cuSolver uses 1-origin while SciPy uses 0-origin
        ipiv += 1
        b = b.astype(dtype, order='F', copy=(not overwrite_b))
    
        if check_finite:
            if lu.dtype.kind == 'f' and not cupy.isfinite(lu).all():
                raise ValueError(
                    'array must not contain infs or NaNs.\n'
                    'Note that when a singular matrix is given, unlike '
                    'scipy.linalg.lu_factor, cupyx.scipy.linalg.lu_factor '
                    'returns an array containing NaN.')
            if b.dtype.kind == 'f' and not cupy.isfinite(b).all():
                raise ValueError(
                    'array must not contain infs or NaNs')
    
        n = 1 if b.ndim == 1 else b.shape[1]
        cusolver_handle = device.get_cusolver_handle()
        dev_info = cupy.empty(1, dtype=numpy.int32)
    
        # solve for the inverse
        getrs(cusolver_handle,
              trans,
              m, n, lu.data.ptr, m, ipiv.data.ptr, b.data.ptr,
              m, dev_info.data.ptr)
    
        if dev_info[0] < 0:
>           raise ValueError('illegal value in %d-th argument of '
                             'internal getrs (lu_solve)' % -dev_info[0])
E           AssertionError: Only cupy raises error
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/testing/_helper.py", line 47, in _call_func
E               result = impl(self, *args, **kw)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py", line 133, in test_lu_solve
E               return scp.linalg.lu_solve(lu, b, trans=self.trans)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupyx/scipy/linalg/decomp_lu.py", line 344, in lu_solve
E               raise ValueError('illegal value in %d-th argument of '
E           ValueError: illegal value in 1904661248-th argument of internal getrs (lu_solve)

cupyx/scipy/linalg/decomp_lu.py:344: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is F
_____ TestLUSolve_param_3_{shapes=((5, 5), (5, 2)), trans=0}.test_lu_solve _____

self = <<cupyx_tests.scipy_tests.linalg_tests.test_decomp_lu.TestLUSolve_param_3_{shapes=((5, 5), (5, 2)), trans=0} testMethod=test_lu_solve>  parameter: {'shapes': ((5, 5), (5, 2)), 'trans': 0}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/__init__.py'>
scp = <module 'cupyx.scipy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupyx/scipy/__init__.py'>
dtype = <class 'numpy.complex128'>

    @testing.for_dtypes('fdFD')
    @testing.numpy_cupy_allclose(atol=1e-5, scipy_name='scp')
    def test_lu_solve(self, xp, scp, dtype):
        a_shape, b_shape = self.shapes
        A = testing.shaped_random(a_shape, xp, dtype=dtype)
        b = testing.shaped_random(b_shape, xp, dtype=dtype)
        lu = scp.linalg.lu_factor(A)
>       return scp.linalg.lu_solve(lu, b, trans=self.trans)

tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lu_and_piv = (array([[ 9.78618342 +6.7063787j ,  7.99158564 +2.10382561j,
         4.61479362 +1.28926298j,  7.80529176 +3.15428351...09693 +0.11253535j, -0.19530724 +0.3829403j ,
         1.48165651 +3.00519867j]]), array([4, 1, 4, 3, 4], dtype=int32))
b = array([[ 2.62387605-0.26982085j,  2.2387386 +2.17849744j],
       [-1.24752213-1.21928963j,  1.06884568-2.83274516j],
...
       [-0.94068427+3.72322175j, -5.04078357+2.5571273j ],
       [-3.22951911-0.30141784j, -2.28920225-3.23327497j]])
trans = 0, overwrite_b = False, check_finite = True

    def lu_solve(lu_and_piv, b, trans=0, overwrite_b=False, check_finite=True):
        """Solve an equation system, ``a * x = b``, given the LU factorization of ``a``
    
        Args:
            lu_and_piv (tuple): LU factorization of matrix ``a`` (``(M, M)``)
                together with pivot indices.
            b (cupy.ndarray): The matrix with dimension ``(M,)`` or
                ``(M, N)``.
            trans ({0, 1, 2}): Type of system to solve:
    
                ========  =========
                trans     system
                ========  =========
                0         a x  = b
                1         a^T x = b
                2         a^H x = b
                ========  =========
            overwrite_b (bool): Allow overwriting data in b (may enhance
                performance)
            check_finite (bool): Whether to check that the input matrices contain
                only finite numbers. Disabling may give a performance gain, but may
                result in problems (crashes, non-termination) if the inputs do
                contain infinities or NaNs.
    
        Returns:
            cupy.ndarray:
                The matrix with dimension ``(M,)`` or ``(M, N)``.
    
        .. seealso:: :func:`scipy.linalg.lu_solve`
        """
    
        (lu, ipiv) = lu_and_piv
    
        _util._assert_cupy_array(lu)
        _util._assert_rank2(lu)
        _util._assert_nd_squareness(lu)
    
        m = lu.shape[0]
        if m != b.shape[0]:
            raise ValueError('incompatible dimensions.')
    
        dtype = lu.dtype
        if dtype.char == 'f':
            getrs = cusolver.sgetrs
        elif dtype.char == 'd':
            getrs = cusolver.dgetrs
        elif dtype.char == 'F':
            getrs = cusolver.cgetrs
        elif dtype.char == 'D':
            getrs = cusolver.zgetrs
        else:
            msg = 'Only float32, float64, complex64 and complex128 are supported.'
            raise NotImplementedError(msg)
    
        if trans == 0:
            trans = cublas.CUBLAS_OP_N
        elif trans == 1:
            trans = cublas.CUBLAS_OP_T
        elif trans == 2:
            trans = cublas.CUBLAS_OP_C
        else:
            raise ValueError('unknown trans')
    
        lu = lu.astype(dtype, order='F', copy=False)
        ipiv = ipiv.astype(ipiv.dtype, order='F', copy=True)
        # cuSolver uses 1-origin while SciPy uses 0-origin
        ipiv += 1
        b = b.astype(dtype, order='F', copy=(not overwrite_b))
    
        if check_finite:
            if lu.dtype.kind == 'f' and not cupy.isfinite(lu).all():
                raise ValueError(
                    'array must not contain infs or NaNs.\n'
                    'Note that when a singular matrix is given, unlike '
                    'scipy.linalg.lu_factor, cupyx.scipy.linalg.lu_factor '
                    'returns an array containing NaN.')
            if b.dtype.kind == 'f' and not cupy.isfinite(b).all():
                raise ValueError(
                    'array must not contain infs or NaNs')
    
        n = 1 if b.ndim == 1 else b.shape[1]
        cusolver_handle = device.get_cusolver_handle()
        dev_info = cupy.empty(1, dtype=numpy.int32)
    
        # solve for the inverse
        getrs(cusolver_handle,
              trans,
              m, n, lu.data.ptr, m, ipiv.data.ptr, b.data.ptr,
              m, dev_info.data.ptr)
    
        if dev_info[0] < 0:
>           raise ValueError('illegal value in %d-th argument of '
                             'internal getrs (lu_solve)' % -dev_info[0])
E           AssertionError: Only cupy raises error
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupy/testing/_helper.py", line 47, in _call_func
E               result = impl(self, *args, **kw)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py", line 133, in test_lu_solve
E               return scp.linalg.lu_solve(lu, b, trans=self.trans)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/cupyx/scipy/linalg/decomp_lu.py", line 344, in lu_solve
E               raise ValueError('illegal value in %d-th argument of '
E           ValueError: illegal value in 1573970959-th argument of internal getrs (lu_solve)

cupyx/scipy/linalg/decomp_lu.py:344: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is D
_ TestGenericFilter.test_filter[_param_156_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca796e310>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f9db3c38940>}>
args = (), kw = {}
cupy_result = (array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[28, 38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]],...38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8))]
cupy_r = array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]], dtype=uint8)
numpy_r = array([[28, 38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]], dtype=uint8)
desired = array([[28, 38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 253
E       Max relative difference: 14.
E        x: array([[21, 31, 40, 31, 33],
E              [27, 29, 28, 20, 27],
E              [14, 25, 35, 34, 32],
E              [27, 26, 33, 25, 31]], dtype=uint8)
E        y: array([[28, 38, 48, 42, 45],
E              [32, 36, 44, 37, 44],
E              [18, 31, 45, 48, 55],
E              [22, 29, 41, 43, 54]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_158_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca7982040>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f9db3c38940>}>
args = (), kw = {}
cupy_result = (array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[34, 34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]],...34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8))]
cupy_r = array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
numpy_r = array([[34, 34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
desired = array([[34, 34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 251
E       Max relative difference: 8.48148148
E        x: array([[28, 24, 32, 32, 39],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0]], dtype=uint8)
E        y: array([[34, 34, 44, 37, 47],
E              [34, 34, 44, 37, 47],
E              [29, 29, 39, 37, 46],
E              [27, 27, 41, 38, 52]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_160_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca78f6eb0>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f9db3c38940>}>
args = (), kw = {}
cupy_result = (array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.011765...2, 44.03386405, 43.67148673, 48.63067102],
       [32.28830047, 30.15609296, 36.65741325, 35.73179981, 40.69098504]]),)
cupy_error = None
numpy_result = (array([[32.49418447, 44.26508328, 55.58324819, 50.90632842, 53.13241351],
       [36.78467189, 42.32410703, 50.513759...4, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.01176...4, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]]))]
cupy_r = array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.0117654...672, 44.03386405, 43.67148673, 48.63067102],
       [32.28830047, 30.15609296, 36.65741325, 35.73179981, 40.69098504]])
numpy_r = array([[32.49418447, 44.26508328, 55.58324819, 50.90632842, 53.13241351],
       [36.78467189, 42.32410703, 50.5137596...954, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.0117654...672, 44.03386405, 43.67148673, 48.63067102],
       [32.28830047, 30.15609296, 36.65741325, 35.73179981, 40.69098504]])
desired = array([[32.49418447, 44.26508328, 55.58324819, 50.90632842, 53.13241351],
       [36.78467189, 42.32410703, 50.5137596...954, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 19.36441258
E       Max relative difference: 0.34647974
E        x: array([[30.366597, 39.629756, 53.455653, 42.070115, 42.814124],
E              [33.368385, 37.733903, 33.011765, 32.58301 , 39.999025],
E              [18.994361, 35.440507, 44.033864, 43.671487, 48.630671],
E              [32.2883  , 30.156093, 36.657413, 35.7318  , 40.690985]])
E        y: array([[32.494184, 44.265083, 55.583248, 50.906328, 53.132414],
E              [36.784672, 42.324107, 50.51376 , 43.278745, 49.956693],
E              [22.164907, 37.049   , 51.930152, 56.789857, 63.231118],
E              [26.455394, 35.108023, 46.860663, 49.162274, 60.055398]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_162_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca796ed00>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f9db3c38940>}>
args = (), kw = {}
cupy_result = (array([[29.110215  , 29.71338479, 34.73644898, 25.2421024 , 32.97375627],
       [ 0.        ,  0.        ,  0.      ... ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]]),)
cupy_error = None
numpy_result = (array([[39.92050807, 39.92050807, 51.40005714, 43.376314  , 54.85586307],
       [39.92050807, 39.92050807, 51.400057...2, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[29.110215  , 29.71338479, 34.73644898, 25.2421024 , 32.97375627],
       [ 0.        ,  0.        ,  0.     ...2, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]]))]
cupy_r = array([[29.110215  , 29.71338479, 34.73644898, 25.2421024 , 32.97375627],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
numpy_r = array([[39.92050807, 39.92050807, 51.40005714, 43.376314  , 54.85586307],
       [39.92050807, 39.92050807, 51.4000571...222, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[29.110215  , 29.71338479, 34.73644898, 25.2421024 , 32.97375627],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
desired = array([[39.92050807, 39.92050807, 51.40005714, 43.376314  , 54.85586307],
       [39.92050807, 39.92050807, 51.4000571...222, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 59.64480722
E       Max relative difference: 1.
E        x: array([[29.110215, 29.713385, 34.736449, 25.242102, 32.973756],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ]])
E        y: array([[39.920508, 39.920508, 51.400057, 43.376314, 54.855863],
E              [39.920508, 39.920508, 51.400057, 43.376314, 54.855863],
E              [34.334642, 34.334642, 44.988915, 43.336931, 53.991204],
E              [33.218712, 33.218712, 48.820469, 44.04305 , 59.644807]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_324_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...28f1b40>, <function lt_pyfunc at 0x7f9db29bc280>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca759a160>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7f9db29bc280>}>
args = (), kw = {}
cupy_result = (array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]]),)
cupy_error = None
numpy_result = (array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]]), array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]]))]
cupy_r = array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]])
numpy_r = array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]])
desired = array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 14 / 20 (70%)
E       Max absolute difference: 7.
E       Max relative difference: 2.
E        x: array([[4., 6., 3., 4., 3.],
E              [5., 7., 7., 5., 3.],
E              [6., 5., 4., 3., 2.],
E              [5., 7., 6., 4., 3.]])
E        y: array([[4., 6., 3., 3., 2.],
E              [5., 0., 6., 8., 1.],
E              [8., 3., 3., 7., 0.],
E              [2., 0., 6., 4., 4.]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_326_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...28f1b40>, <function lt_pyfunc at 0x7f9db29bc280>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca6dba190>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7f9db29bc280>}>
args = (), kw = {}
cupy_result = (array([[15.,  5., 13.,  8., 11.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]]),)
cupy_error = None
numpy_result = (array([[ 8., 11.,  4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[15.,  5., 13.,  8., 11.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  ...4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]]))]
cupy_r = array([[15.,  5., 13.,  8., 11.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
numpy_r = array([[ 8., 11.,  4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[15.,  5., 13.,  8., 11.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
desired = array([[ 8., 11.,  4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 17 / 20 (85%)
E       Max absolute difference: 14.
E       Max relative difference: 2.25
E        x: array([[15.,  5., 13.,  8., 11.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.]])
E        y: array([[ 8., 11.,  4., 10.,  7.],
E              [14.,  0.,  7.,  4.,  8.],
E              [ 8.,  5., 11.,  5.,  5.],
E              [14.,  0.,  1.,  0.,  7.]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_484_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca6db5c70>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f9db3c38940>}>
args = (), kw = {}
cupy_result = (array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[31, 36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]],...36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8))]
cupy_r = array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]], dtype=uint8)
numpy_r = array([[31, 36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]], dtype=uint8)
desired = array([[31, 36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 254
E       Max relative difference: 15.875
E        x: array([[21, 28, 45, 28, 29],
E              [28, 24, 27, 19, 21],
E              [14, 25, 40, 31, 32],
E              [28, 19, 33, 25, 26]], dtype=uint8)
E        y: array([[31, 36, 54, 42, 44],
E              [32, 37, 44, 33, 44],
E              [16, 36, 54, 41, 63],
E              [24, 30, 40, 45, 48]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_486_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca6594b50>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f9db3c38940>}>
args = (), kw = {}
cupy_result = (array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[31, 37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]],...37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8))]
cupy_r = array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
numpy_r = array([[31, 37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
desired = array([[31, 37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 255
E       Max relative difference: 8.84615385
E        x: array([[23, 27, 36, 28, 53],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0]], dtype=uint8)
E        y: array([[31, 37, 37, 34, 51],
E              [36, 33, 47, 34, 49],
E              [32, 30, 35, 33, 43],
E              [26, 31, 44, 32, 61]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_488_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca6d9ebe0>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f9db3c38940>}>
args = (), kw = {}
cupy_result = (array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.257219...9, 51.41878991, 42.0040045 , 51.31070106],
       [33.21458492, 22.51034287, 37.94448098, 37.08985252, 37.51394469]]),)
cupy_error = None
numpy_result = (array([[34.73996818, 43.64546371, 63.5383726 , 49.84875414, 52.48268444],
       [37.33873469, 42.72655042, 49.589277...5, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.25721...5, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]]))]
cupy_r = array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.2572195...229, 51.41878991, 42.0040045 , 51.31070106],
       [33.21458492, 22.51034287, 37.94448098, 37.08985252, 37.51394469]])
numpy_r = array([[34.73996818, 43.64546371, 63.5383726 , 49.84875414, 52.48268444],
       [37.33873469, 42.72655042, 49.5892777...725, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.2572195...229, 51.41878991, 42.0040045 , 51.31070106],
       [33.21458492, 22.51034287, 37.94448098, 37.08985252, 37.51394469]])
desired = array([[34.73996818, 43.64546371, 63.5383726 , 49.84875414, 52.48268444],
       [37.33873469, 42.72655042, 49.5892777...725, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 21.26396424
E       Max relative difference: 0.37779527
E        x: array([[32.004498, 37.685758, 60.802894, 38.487909, 39.216312],
E              [34.603265, 32.253241, 33.25722 , 33.041408, 36.624282],
E              [20.112677, 38.150832, 51.41879 , 42.004005, 51.310701],
E              [33.214585, 22.510343, 37.944481, 37.089853, 37.513945]])
E        y: array([[34.739968, 43.645464, 63.538373, 49.848754, 52.482684],
E              [37.338735, 42.72655 , 49.589278, 37.768093, 49.890655],
E              [19.537204, 43.529837, 62.151861, 50.872889, 72.574665],
E              [29.909488, 36.178354, 46.34963 , 49.948601, 54.161936]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_490_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca65946a0>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f9db3c38940>}>
args = (), kw = {}
cupy_result = (array([[21.27808861, 29.80163272, 37.25897052, 32.87956485, 40.18680146],
       [ 0.        ,  0.        ,  0.      ... ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]]),)
cupy_error = None
numpy_result = (array([[36.86077635, 42.87616583, 43.41972747, 39.82804323, 58.74618737],
       [42.04291274, 39.49732697, 56.260026...8, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[21.27808861, 29.80163272, 37.25897052, 32.87956485, 40.18680146],
       [ 0.        ,  0.        ,  0.     ...8, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]]))]
cupy_r = array([[21.27808861, 29.80163272, 37.25897052, 32.87956485, 40.18680146],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
numpy_r = array([[36.86077635, 42.87616583, 43.41972747, 39.82804323, 58.74618737],
       [42.04291274, 39.49732697, 56.2600260...358, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[21.27808861, 29.80163272, 37.25897052, 32.87956485, 40.18680146],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
desired = array([[36.86077635, 42.87616583, 43.41972747, 39.82804323, 58.74618737],
       [42.04291274, 39.49732697, 56.2600260...358, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 70.43768385
E       Max relative difference: 1.
E        x: array([[21.278089, 29.801633, 37.258971, 32.879565, 40.186801],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ]])
E        y: array([[36.860776, 42.876166, 43.419727, 39.828043, 58.746187],
E              [42.042913, 39.497327, 56.260026, 40.67984 , 58.57918 ],
E              [36.303403, 34.455314, 40.066132, 37.533243, 49.792072],
E              [31.441124, 37.686712, 51.654176, 39.594527, 70.437684]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_652_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...28f1b40>, <function lt_pyfunc at 0x7f9db29bc280>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca659b100>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7f9db29bc280>}>
args = (), kw = {}
cupy_result = (array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]]),)
cupy_error = None
numpy_result = (array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]]), array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]]))]
cupy_r = array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]])
numpy_r = array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]])
desired = array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 14 / 20 (70%)
E       Max absolute difference: 2.
E       Max relative difference: 1.
E        x: array([[5., 3., 2., 4., 3.],
E              [1., 5., 1., 5., 6.],
E              [4., 4., 1., 3., 5.],
E              [1., 1., 1., 4., 4.]])
E        y: array([[5., 2., 2., 3., 2.],
E              [0., 4., 0., 5., 5.],
E              [4., 4., 1., 2., 3.],
E              [0., 0., 0., 3., 2.]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_654_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...28f1b40>, <function lt_pyfunc at 0x7f9db29bc280>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f9ca65a5250>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7f9db29bc280>}>
args = (), kw = {}
cupy_result = (array([[ 6., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]]),)
cupy_error = None
numpy_result = (array([[ 0., 10., 10.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[ 6., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  ...0.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]]))]
cupy_r = array([[ 6., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
numpy_r = array([[ 0., 10., 10.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
desired = array([[ 0., 10., 10.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 18 / 20 (90%)
E       Max absolute difference: 10.
E       Max relative difference: 2.
E        x: array([[ 6., 10., 10.,  3.,  9.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.]])
E        y: array([[ 0., 10., 10.,  1.,  8.],
E              [ 7.,  6.,  2.,  2.,  2.],
E              [ 1., 10., 10.,  2.,  9.],
E              [ 4.,  5.,  9.,  1.,  6.]])

cupy/testing/_array.py:24: AssertionError
_ TestAffineTransform.test_affine_transform_int[_param_13_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa41040>  parameter: {..._shape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_17_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9517c0>  parameter: {...ape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_19_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa4b850>  parameter: {..._shape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_23_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a998970>  parameter: {...ape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_25_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9514f0>  parameter: {..._shape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_29_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a908c10>  parameter: {...ape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 8, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 8, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_31_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa5aa90>  parameter: {..._shape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 9, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 9, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_35_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7d2eb0>  parameter: {...ape': (2,), 'mode': 'constant', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  3, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[5, 9, 0, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [3, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  3, 255,   0, ...,   1,   1,   1],...
E        y: array([[5, 9, 0, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [3, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_49_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa6d910>  parameter: {... (2,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_53_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a902970>  parameter: {...,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_55_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa5f4f0>  parameter: {... (2,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_59_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa56820>  parameter: {...,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_61_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a98f310>  parameter: {... (2,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 8 / 10000 (0.08%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_65_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a75f310>  parameter: {...,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 8 / 10000 (0.08%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_67_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7d2670>  parameter: {... (2,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [5, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [5, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [5, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [5, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_71_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a951070>  parameter: {...,), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [5, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [5, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [5, 2, 3, ..., 1, 1, 1],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [5, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_85_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca659b310>  parameter: {...x_shape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[5, 8, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[5, 8, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_89_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9d0296aa30>  parameter: {...hape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[5, 8, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[5, 8, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_91_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9cfaa0a580>  parameter: {...x_shape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   1,   1,   1],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[5, 8, 2, ..., 1, 1, 1],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[5, 8, 2, ..., 1, 1, 1],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_95_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9cfaa0a850>  parameter: {...hape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   1,   1,   1],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[5, 8, 2, ..., 1, 1, 1],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[5, 8, 2, ..., 1, 1, 1],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_97_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9cfeea16d0>  parameter: {...x_shape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   0,   0],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 0, 0],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   0,   0],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[6, 8, 2, ..., 0, 0, 0],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_101_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa78a60>  parameter: {...hape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   0,   0],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 0, 0],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   0,   0],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[6, 8, 2, ..., 0, 0, 0],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_103_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7ad5e0>  parameter: {...x_shape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   0,   0],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 0, 0],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 89 / 10000 (0.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   0,   0],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[6, 8, 2, ..., 0, 0, 0],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_107_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a8f9fa0>  parameter: {...hape': (2,), 'mode': 'nearest', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   0,   0],
       [  2,   0,   6, ...,   9,   9,   9],
       [  3, 255,   0, ...,   ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8],
       [  6,   7,   1, ...,   8,   8,   8]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 0, 0],
       [2, 0, 6, ..., 9, 9, 9],
       [3, 0, 0, ..., 5, 5, 5],
       ...,
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8],
       [6, 7, 1, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 89 / 10000 (0.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   0,   0],
E              [  2,   0,   6, ...,   9,   9,   9],
E              [  3, 255,   0, ...,   5,   5,   5],...
E        y: array([[6, 8, 2, ..., 0, 0, 0],
E              [2, 0, 6, ..., 9, 9, 9],
E              [3, 0, 0, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_121_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a99b310>  parameter: {...: (2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_125_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a792550>  parameter: {...2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_127_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a992040>  parameter: {...: (2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_131_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a792ca0>  parameter: {...2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [4, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [4, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_133_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a992d90>  parameter: {...: (2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_137_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9aebe0>  parameter: {...2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_139_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9a5040>  parameter: {...: (2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 10 / 10000 (0.1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_143_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a76cbb0>  parameter: {...2,), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 7, 0, ..., 0, 0, 0],
       [7, 5, 1, ..., 3, 3, 3],
       [5, 2, 3, ..., 6, 6, 6],
       ...,
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8],
       [1, 7, 3, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 10 / 10000 (0.1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...
E        y: array([[7, 7, 0, ..., 0, 0, 0],
E              [7, 5, 1, ..., 3, 3, 3],
E              [5, 2, 3, ..., 6, 6, 6],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_157_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a775040>  parameter: {...ix_shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   3,   2,   2],
       [  2,   0,   6, ...,   2,   5,   8],
       [  4, 255,   0, ...,   ...,   1,   4,   8],
       [  2,   5,   0, ...,   8,   2,   1],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 0, ..., 3, 2, 2],
       [2, 0, 6, ..., 2, 5, 8],
       [4, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 8],
       [2, 5, 0, ..., 8, 2, 1],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 72 / 10000 (0.72%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   3,   2,   2],
E              [  2,   0,   6, ...,   2,   5,   8],
E              [  4, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 3, 2, 2],
E              [2, 0, 6, ..., 2, 5, 8],
E              [4, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_161_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9660d0>  parameter: {...shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   3,   2,   2],
       [  2,   0,   6, ...,   2,   5,   8],
       [  4, 255,   0, ...,   ...,   1,   4,   8],
       [  2,   5,   0, ...,   8,   2,   1],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 0, ..., 3, 2, 2],
       [2, 0, 6, ..., 2, 5, 8],
       [4, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 8],
       [2, 5, 0, ..., 8, 2, 1],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 72 / 10000 (0.72%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   3,   2,   2],
E              [  2,   0,   6, ...,   2,   5,   8],
E              [  4, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 3, 2, 2],
E              [2, 0, 6, ..., 2, 5, 8],
E              [4, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_163_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7586d0>  parameter: {...ix_shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   3,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   1,   4,   8],
       [  2,   5,   0, ...,   7,   2,   1],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 1, ..., 3, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 8],
       [2, 5, 0, ..., 7, 2, 1],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   3,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 1, ..., 3, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_167_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a760430>  parameter: {...shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   3,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   1,   4,   8],
       [  2,   5,   0, ...,   7,   2,   1],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 1, ..., 3, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 8],
       [2, 5, 0, ..., 7, 2, 1],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   3,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 1, ..., 3, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_169_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a95a130>  parameter: {...ix_shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   4,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   0,   4,   8],
       [  2,   5, 255, ...,   7,   2,   0],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 0, ..., 4, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 0, 4, 8],
       [2, 5, 0, ..., 7, 2, 0],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 163 / 10000 (1.63%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   4,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 4, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_173_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a966940>  parameter: {...shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   4,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   0,   4,   8],
       [  2,   5, 255, ...,   7,   2,   0],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 8, 0, ..., 4, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 0, 4, 8],
       [2, 5, 0, ..., 7, 2, 0],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 163 / 10000 (1.63%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   4,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 4, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_175_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa539a0>  parameter: {...ix_shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   4,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   0,   4,   8],
       [  2,   5, 255, ...,   7,   2,   0],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 9, 0, ..., 4, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 2, ..., 0, 4, 8],
       [2, 5, 0, ..., 7, 2, 0],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 191 / 10000 (1.91%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   4,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 9, 0, ..., 4, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_179_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9423d0>  parameter: {...shape': (2,), 'mode': 'mirror', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   4,   2,   2],
       [  2,   0,   6, ...,   3,   6,   8],
       [  3, 255,   0, ...,   ...,   0,   4,   8],
       [  2,   5, 255, ...,   7,   2,   0],
       [  6,   7,   1, ...,   5,   2,   6]], dtype=uint8)
desired = array([[5, 9, 0, ..., 4, 2, 2],
       [2, 0, 6, ..., 3, 6, 8],
       [3, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 2, ..., 0, 4, 8],
       [2, 5, 0, ..., 7, 2, 0],
       [6, 7, 1, ..., 5, 2, 6]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 191 / 10000 (1.91%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   4,   2,   2],
E              [  2,   0,   6, ...,   3,   6,   8],
E              [  3, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 9, 0, ..., 4, 2, 2],
E              [2, 0, 6, ..., 3, 6, 8],
E              [3, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_193_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a917bb0>  parameter: {...': (2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  8,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  6,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  1, ...,  3,  4, 10]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  8,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  6,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  1, ...,  3,  4, 10]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 63 / 10000 (0.63%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  8,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  8,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_197_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca6da3ee0>  parameter: {...(2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  8,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  6,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  1, ...,  3,  4, 10]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  8,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  6,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  1, ...,  3,  4, 10]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 63 / 10000 (0.63%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  8,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  8,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_199_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9562b0>  parameter: {...': (2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  2, ...,  3,  4, 11]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  2, ...,  3,  4, 11]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 82 / 10000 (0.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_203_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca797e3a0>  parameter: {...(2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  2, ...,  3,  4, 11]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 10,  6,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 8,  5,  2, ...,  3,  4, 11]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 82 / 10000 (0.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 10,  6,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_205_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9cfef47100>  parameter: {...': (2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 11,  7,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 11,  7,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 144 / 10000 (1.44%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 11,  7,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 11,  7,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_209_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9cfef477c0>  parameter: {...(2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 11,  7,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
desired = array([[ 3,  4,  5, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  5,  5,  1],
       [ 4,  2,  3, ..., 11,  7,  3],
    ... 2,  7,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 144 / 10000 (1.44%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 11,  7,  3],...
E        y: array([[ 3,  4,  5, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  5,  5,  1],
E              [ 4,  2,  3, ..., 11,  7,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_211_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a781970>  parameter: {...': (2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 2,  4,  6, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  4,  5,  0],
       [ 5,  2,  3, ..., 11,  7,  3],
    ... 2,  6,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
desired = array([[ 2,  4,  6, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  4,  5,  0],
       [ 5,  2,  3, ..., 11,  7,  3],
    ... 2,  6,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 164 / 10000 (1.64%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 2,  4,  6, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  4,  5,  0],
E              [ 5,  2,  3, ..., 11,  7,  3],...
E        y: array([[ 2,  4,  6, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  4,  5,  0],
E              [ 5,  2,  3, ..., 11,  7,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_215_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a8f57c0>  parameter: {...(2,), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 2,  4,  6, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  4,  5,  0],
       [ 5,  2,  3, ..., 11,  7,  3],
    ... 2,  6,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
desired = array([[ 2,  4,  6, ...,  6,  7,  2],
       [ 7,  5,  1, ...,  4,  5,  0],
       [ 5,  2,  3, ..., 11,  7,  3],
    ... 2,  6,  4, ...,  1,  7,  7],
       [ 4,  5,  8, ...,  3,  1,  2],
       [ 9,  5,  1, ...,  2,  4, 12]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 164 / 10000 (1.64%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 2,  4,  6, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  4,  5,  0],
E              [ 5,  2,  3, ..., 11,  7,  3],...
E        y: array([[ 2,  4,  6, ...,  6,  7,  2],
E              [ 7,  5,  1, ...,  4,  5,  0],
E              [ 5,  2,  3, ..., 11,  7,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_229_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a932a60>  parameter: {...trix_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   3,   2,   5],
       [  2,   0,   6, ...,   2,   5,   2],
       [  4, 255,   0, ...,   ...,   1,   4,   3],
       [  2,   5,   0, ...,   8,   2,   2],
       [  5,   8,   0, ...,   3,   2,   5]], dtype=uint8)
desired = array([[5, 8, 0, ..., 3, 2, 5],
       [2, 0, 6, ..., 2, 5, 2],
       [4, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 3],
       [2, 5, 0, ..., 8, 2, 2],
       [5, 8, 0, ..., 3, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   3,   2,   5],
E              [  2,   0,   6, ...,   2,   5,   2],
E              [  4, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 3, 2, 5],
E              [2, 0, 6, ..., 2, 5, 2],
E              [4, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_233_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a79dc70>  parameter: {...x_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   3,   2,   5],
       [  2,   0,   6, ...,   2,   5,   2],
       [  4, 255,   0, ...,   ...,   1,   4,   3],
       [  2,   5,   0, ...,   8,   2,   2],
       [  5,   8,   0, ...,   3,   2,   5]], dtype=uint8)
desired = array([[5, 8, 0, ..., 3, 2, 5],
       [2, 0, 6, ..., 2, 5, 2],
       [4, 0, 0, ..., 4, 7, 4],
       ...,
       [3, 2, 3, ..., 1, 4, 3],
       [2, 5, 0, ..., 8, 2, 2],
       [5, 8, 0, ..., 3, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   3,   2,   5],
E              [  2,   0,   6, ...,   2,   5,   2],
E              [  4, 255,   0, ...,   4,   7,   4],...
E        y: array([[5, 8, 0, ..., 3, 2, 5],
E              [2, 0, 6, ..., 2, 5, 2],
E              [4, 0, 0, ..., 4, 7, 4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_235_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca796e6a0>  parameter: {...trix_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   3,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   1,   4,   3],
       [  2,   5,   0, ...,   7,   2,   2],
       [  5,   8,   1, ...,   3,   2,   5]], dtype=uint8)
desired = array([[5, 8, 1, ..., 3, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 3, ..., 1, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 8, 1, ..., 3, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 112 / 10000 (1.12%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   3,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 8, 1, ..., 3, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_239_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa5f9a0>  parameter: {...x_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   1, ...,   3,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   1,   4,   3],
       [  2,   5,   0, ...,   7,   2,   2],
       [  5,   8,   1, ...,   3,   2,   5]], dtype=uint8)
desired = array([[5, 8, 1, ..., 3, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 3, ..., 1, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 8, 1, ..., 3, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 112 / 10000 (1.12%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   1, ...,   3,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 8, 1, ..., 3, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_241_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6f81f0>  parameter: {...trix_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   4,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   0,   4,   3],
       [  2,   5, 255, ...,   7,   2,   2],
       [  5,   8,   0, ...,   4,   2,   5]], dtype=uint8)
desired = array([[5, 8, 0, ..., 4, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 3, ..., 0, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 8, 0, ..., 4, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 181 / 10000 (1.81%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   4,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 8, 0, ..., 4, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_245_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ce5e4e430>  parameter: {...x_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   0, ...,   4,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   0,   4,   3],
       [  2,   5, 255, ...,   7,   2,   2],
       [  5,   8,   0, ...,   4,   2,   5]], dtype=uint8)
desired = array([[5, 8, 0, ..., 4, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 3, ..., 0, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 8, 0, ..., 4, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 181 / 10000 (1.81%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   0, ...,   4,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 8, 0, ..., 4, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_247_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a706b50>  parameter: {...trix_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   4,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   0,   4,   3],
       [  2,   5, 255, ...,   7,   2,   2],
       [  5,   9,   0, ...,   4,   2,   5]], dtype=uint8)
desired = array([[5, 9, 0, ..., 4, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 2, ..., 0, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 9, 0, ..., 4, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 210 / 10000 (2.1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   4,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 9, 0, ..., 4, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_251_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a704cd0>  parameter: {...x_shape': (2,), 'mode': 'wrap', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   9,   0, ...,   4,   2,   5],
       [  2,   0,   6, ...,   3,   6,   2],
       [  3, 255,   0, ...,   ...,   0,   4,   3],
       [  2,   5, 255, ...,   7,   2,   2],
       [  5,   9,   0, ...,   4,   2,   5]], dtype=uint8)
desired = array([[5, 9, 0, ..., 4, 2, 5],
       [2, 0, 6, ..., 3, 6, 2],
       [3, 0, 0, ..., 4, 7, 3],
       ...,
       [3, 2, 2, ..., 0, 4, 3],
       [2, 5, 0, ..., 7, 2, 2],
       [5, 9, 0, ..., 4, 2, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 210 / 10000 (2.1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   9,   0, ...,   4,   2,   5],
E              [  2,   0,   6, ...,   3,   6,   2],
E              [  3, 255,   0, ...,   4,   7,   3],...
E        y: array([[5, 9, 0, ..., 4, 2, 5],
E              [2, 0, 6, ..., 3, 6, 2],
E              [3, 0, 0, ..., 4, 7, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_265_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6ce460>  parameter: {...pe': (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 8,  5,  1, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  6,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  1, ...,  3,  4,  8]], dtype=uint8)
desired = array([[ 8,  5,  1, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  6,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  1, ...,  3,  4,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 80 / 10000 (0.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 8,  5,  1, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...
E        y: array([[ 8,  5,  1, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_269_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a8f83d0>  parameter: {...: (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 8,  5,  1, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  6,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  1, ...,  3,  4,  8]], dtype=uint8)
desired = array([[ 8,  5,  1, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  6,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  1, ...,  3,  4,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 80 / 10000 (0.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 8,  5,  1, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...
E        y: array([[ 8,  5,  1, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_271_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6aaaf0>  parameter: {...pe': (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 8,  5,  2, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  2, ...,  3,  4,  8]], dtype=uint8)
desired = array([[ 8,  5,  2, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  2, ...,  3,  4,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 106 / 10000 (1.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 8,  5,  2, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...
E        y: array([[ 8,  5,  2, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_275_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa56eb0>  parameter: {...: (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 8,  5,  2, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  2, ...,  3,  4,  8]], dtype=uint8)
desired = array([[ 8,  5,  2, ...,  3,  4,  8],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 10,  6,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 8,  5,  2, ...,  3,  4,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 106 / 10000 (1.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 8,  5,  2, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...
E        y: array([[ 8,  5,  2, ...,  3,  4,  8],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 10,  6,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_277_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9838b0>  parameter: {...pe': (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 11,  7,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
desired = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 11,  7,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 168 / 10000 (1.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 11,  7,  4],...
E        y: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 11,  7,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_281_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a704550>  parameter: {...: (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 11,  7,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
desired = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  5,  5,  7],
       [ 4,  2,  3, ..., 11,  7,  4],
    ... 2,  7,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 168 / 10000 (1.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 11,  7,  4],...
E        y: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  5,  5,  7],
E              [ 4,  2,  3, ..., 11,  7,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_283_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca991b700>  parameter: {...pe': (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  4,  5,  7],
       [ 5,  2,  3, ..., 11,  7,  5],
    ... 2,  6,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
desired = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  4,  5,  7],
       [ 5,  2,  3, ..., 11,  7,  5],
    ... 2,  6,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 193 / 10000 (1.93%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  4,  5,  7],
E              [ 5,  2,  3, ..., 11,  7,  5],...
E        y: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  4,  5,  7],
E              [ 5,  2,  3, ..., 11,  7,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_287_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7d2a00>  parameter: {...: (2,), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  4,  5,  7],
       [ 5,  2,  3, ..., 11,  7,  5],
    ... 2,  6,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
desired = array([[ 9,  5,  1, ...,  2,  4,  9],
       [ 7,  5,  1, ...,  4,  5,  7],
       [ 5,  2,  3, ..., 11,  7,  5],
    ... 2,  6,  4, ...,  1,  7,  2],
       [ 4,  5,  8, ...,  3,  1,  4],
       [ 9,  5,  1, ...,  2,  4,  9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 193 / 10000 (1.93%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  4,  5,  7],
E              [ 5,  2,  3, ..., 11,  7,  5],...
E        y: array([[ 9,  5,  1, ...,  2,  4,  9],
E              [ 7,  5,  1, ...,  4,  5,  7],
E              [ 5,  2,  3, ..., 11,  7,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_301_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a0ea700>  parameter: {...shape': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ...,   0,   3,   8],
       [  1,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 8],
       [1, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 90 / 10000 (0.9%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ...,   0,   3,   8],
E              [  1,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 8],
E              [1, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_305_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a987190>  parameter: {...pe': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ...,   0,   3,   8],
       [  1,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 8],
       [1, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 90 / 10000 (0.9%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ...,   0,   3,   8],
E              [  1,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 8],
E              [1, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_307_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a784af0>  parameter: {...shape': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ...,   0,   3,   8],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  3,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 8],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [3, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 115 / 10000 (1.15%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ...,   0,   3,   8],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 8],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_311_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a100fd0>  parameter: {...pe': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ...,   0,   3,   8],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  3,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 8],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [3, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 115 / 10000 (1.15%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ...,   0,   3,   8],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 8],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_313_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99dbd040>  parameter: {...shape': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ..., 255,   3,   9],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  3,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 9],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [4, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [3, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 180 / 10000 (1.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ..., 255,   3,   9],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 9],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_317_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a100ca0>  parameter: {...pe': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   1, ..., 255,   3,   9],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  3,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 1, ..., 0, 3, 9],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [4, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [3, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 180 / 10000 (1.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   1, ..., 255,   3,   9],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 1, ..., 0, 3, 9],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_319_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d994c0>  parameter: {...shape': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   8,   2, ..., 255,   3,   9],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  3,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[7, 8, 2, ..., 0, 3, 9],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [4, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [3, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 205 / 10000 (2.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   8,   2, ..., 255,   3,   9],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[7, 8, 2, ..., 0, 3, 9],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_323_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d9edc0>  parameter: {...pe': (2,), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   8,   2, ..., 255,   3,   9],
       [  1,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  3,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[7, 8, 2, ..., 0, 3, 9],
       [1, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [4, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [3, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 205 / 10000 (2.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   8,   2, ..., 255,   3,   9],
E              [  1,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[7, 8, 2, ..., 0, 3, 9],
E              [1, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_337_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a140460>  parameter: {...(2,), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 80 / 10000 (0.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_341_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a14b520>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 80 / 10000 (0.8%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_343_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a145b20>  parameter: {...(2,), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[3, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[3, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 120 / 10000 (1.2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[3, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[3, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_347_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a14b940>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[3, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[3, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 120 / 10000 (1.2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[3, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[3, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_349_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a12c040>  parameter: {...(2,), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 3, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [5, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 3, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [5, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 175 / 10000 (1.75%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 3, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 3, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_353_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a96eaf0>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 3, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [5, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[2, 6, 3, ..., 3, 6, 8],
       [7, 5, 1, ..., 3, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [5, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 175 / 10000 (1.75%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 3, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[2, 6, 3, ..., 3, 6, 8],
E              [7, 5, 1, ..., 3, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_355_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a8d8d60>  parameter: {...(2,), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 2,  5,  3, ...,  3,  6,  9],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 5,  5,  2, ...,  5,  2,  3],
       [ 5,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 2,  5,  3, ...,  3,  6,  9],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 5,  5,  2, ...,  5,  2,  3],
       [ 5,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 195 / 10000 (1.95%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 2,  5,  3, ...,  3,  6,  9],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 2,  5,  3, ...,  3,  6,  9],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_359_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a8fdfd0>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 2,  5,  3, ...,  3,  6,  9],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 5,  5,  2, ...,  5,  2,  3],
       [ 5,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 2,  5,  3, ...,  3,  6,  9],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 5,  5,  2, ...,  5,  2,  3],
       [ 5,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 195 / 10000 (1.95%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 2,  5,  3, ...,  3,  6,  9],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 2,  5,  3, ...,  3,  6,  9],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_373_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99c6d5b0>  parameter: {...x_shape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [6, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_377_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99c71430>  parameter: {...hape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [6, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_379_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a96b850>  parameter: {...x_shape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  4,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [4, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 122 / 10000 (1.22%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_383_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99c71d90>  parameter: {...hape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  4,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [4, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 122 / 10000 (1.22%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_385_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99c50eb0>  parameter: {...x_shape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 173 / 10000 (1.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_389_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99cff550>  parameter: {...hape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 173 / 10000 (1.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_391_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d1fdc0>  parameter: {...x_shape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   7,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 7, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 199 / 10000 (1.99%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   7,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 7, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_395_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99cffd30>  parameter: {...hape': (2,), 'mode': 'reflect', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   7,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 7, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 199 / 10000 (1.99%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   7,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 7, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_409_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d101c0>  parameter: {...: (2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_413_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99b45760>  parameter: {...2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_415_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d10e20>  parameter: {...: (2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_419_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9581f0>  parameter: {...2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_421_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99b3a9d0>  parameter: {...: (2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 176 / 10000 (1.76%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_425_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a712a60>  parameter: {...2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 176 / 10000 (1.76%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_427_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca95bfd60>  parameter: {...: (2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_431_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a122be0>  parameter: {...2,), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_445_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6d8640>  parameter: {...ape': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [6, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_449_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a122160>  parameter: {...': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   1,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  6,   6,   1, ...,   2,   4,   5],
       [  3,   6,   1, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 1, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [6, 5, 3, ..., 3, 6, 6],
       [6, 6, 1, ..., 2, 4, 5],
       [3, 6, 1, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 88 / 10000 (0.88%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   1,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 1, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_451_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a11c790>  parameter: {...ape': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  4,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [4, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 122 / 10000 (1.22%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_455_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9083d0>  parameter: {...': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   8,   2, ...,   0,   4,   8],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   6,   6],
       [  5,   7,   1, ...,   2,   4,   5],
       [  4,   6,   2, ...,   2,   5,   2]], dtype=uint8)
desired = array([[5, 8, 2, ..., 0, 4, 8],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 5, 3, ..., 3, 6, 6],
       [5, 7, 1, ..., 2, 4, 5],
       [4, 6, 2, ..., 2, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 122 / 10000 (1.22%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   8,   2, ...,   0,   4,   8],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[5, 8, 2, ..., 0, 4, 8],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_457_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6beca0>  parameter: {...ape': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 173 / 10000 (1.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_461_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6bebb0>  parameter: {...': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   8,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   6],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 8, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 6],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 173 / 10000 (1.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   8,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 8, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_463_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99db8fd0>  parameter: {...ape': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   7,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 7, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 199 / 10000 (1.99%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   7,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 7, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_467_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca6d9eca0>  parameter: {...': (2,), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   7,   2, ...,   0,   4,   9],
       [  2,   0,   6, ...,   7,   2,   4],
       [  3, 255,   0, ...,   ...,   3,   5,   5],
       [  6,   7,   1, ...,   3,   4,   5],
       [  4,   7,   1, ...,   1,   5,   2]], dtype=uint8)
desired = array([[6, 7, 2, ..., 0, 4, 9],
       [2, 0, 6, ..., 7, 2, 4],
       [3, 0, 0, ..., 3, 2, 5],
       ...,
       [5, 4, 3, ..., 3, 5, 5],
       [6, 7, 1, ..., 3, 4, 5],
       [4, 7, 1, ..., 1, 5, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 199 / 10000 (1.99%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   7,   2, ...,   0,   4,   9],
E              [  2,   0,   6, ...,   7,   2,   4],
E              [  3, 255,   0, ...,   3,   2,   5],...
E        y: array([[6, 7, 2, ..., 0, 4, 9],
E              [2, 0, 6, ..., 7, 2, 4],
E              [3, 0, 0, ..., 3, 2, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_481_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a942070>  parameter: {...,), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_485_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99784040>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[6, 6, 1, ..., 3, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 3, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[6, 6, 1, ..., 3, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_487_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a0e85b0>  parameter: {...,), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_491_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99784eb0>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 8, 3],
       [4, 2, 3, ..., 9, 6, 5],
       ...,
       [6, 4, 2, ..., 5, 3, 3],
       [5, 6, 4, ..., 4, 5, 4],
       [7, 2, 5, ..., 4, 2, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 8, 3],
E              [4, 2, 3, ..., 9, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_493_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9796d0>  parameter: {...,), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 176 / 10000 (1.76%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_497_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca8c4b4f0>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
desired = array([[5, 6, 1, ..., 4, 2, 2],
       [7, 5, 1, ..., 2, 9, 3],
       [5, 2, 3, ..., 9, 5, 5],
       ...,
       [6, 5, 2, ..., 5, 2, 3],
       [4, 6, 3, ..., 3, 5, 3],
       [7, 2, 5, ..., 4, 1, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 176 / 10000 (1.76%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...
E        y: array([[5, 6, 1, ..., 4, 2, 2],
E              [7, 5, 1, ..., 2, 9, 3],
E              [5, 2, 3, ..., 9, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_499_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca9581a90>  parameter: {...,), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_503_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9daeb34be0>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
desired = array([[ 5,  6,  1, ...,  4,  2,  2],
       [ 7,  5,  1, ...,  3,  9,  3],
       [ 5,  2,  3, ..., 10,  5,  5],
    ... 6,  5,  2, ...,  5,  2,  3],
       [ 4,  6,  3, ...,  3,  5,  3],
       [ 7,  2,  5, ...,  4,  1,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...
E        y: array([[ 5,  6,  1, ...,  4,  2,  2],
E              [ 7,  5,  1, ...,  3,  9,  3],
E              [ 5,  2,  3, ..., 10,  5,  5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_517_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a152340>  parameter: {...e': (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[6, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[6, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_521_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a12cee0>  parameter: {... (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[6, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[6, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_523_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99b37790>  parameter: {...e': (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[6, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[6, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_527_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99c6baf0>  parameter: {... (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[6, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 7 / 10000 (0.07%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[6, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_529_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a75fdf0>  parameter: {...e': (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[7, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[7, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_533_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99b1f700>  parameter: {... (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   9,   1, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[7, 9, 1, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   9,   1, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[7, 9, 1, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_535_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca759a9d0>  parameter: {...e': (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   9,   2, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[7, 9, 2, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   9,   2, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[7, 9, 2, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_539_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99b1f5b0>  parameter: {... (2,), 'mode': 'grid-constant', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   9,   2, ...,   1,   1,   1],
       [  2,   0,   6, ...,   1,   1,   1],
       [  4, 255,   0, ...,   ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1],
       [  1,   1,   1, ...,   1,   1,   1]], dtype=uint8)
desired = array([[7, 9, 2, ..., 1, 1, 1],
       [2, 0, 6, ..., 1, 1, 1],
       [4, 0, 0, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   9,   2, ...,   1,   1,   1],
E              [  2,   0,   6, ...,   1,   1,   1],
E              [  4, 255,   0, ...,   1,   1,   1],...
E        y: array([[7, 9, 2, ..., 1, 1, 1],
E              [2, 0, 6, ..., 1, 1, 1],
E              [4, 0, 0, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_553_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6a5550>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_557_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa78a90>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_559_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99b4ae80>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_563_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c997b3df0>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 6 / 10000 (0.06%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_565_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c997951f0>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 8 / 10000 (0.08%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_569_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a794490>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 8 / 10000 (0.08%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_571_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d64550>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_575_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99799820>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 0, 1, ..., 1, 1, 1],
       [7, 5, 1, ..., 1, 1, 1],
       [4, 2, 3, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 9 / 10000 (0.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...
E        y: array([[0, 0, 1, ..., 1, 1, 1],
E              [7, 5, 1, ..., 1, 1, 1],
E              [4, 2, 3, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_589_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d470d0>  parameter: {...hape': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_593_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99c5d7c0>  parameter: {...e': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_595_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9986a0>  parameter: {...hape': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_599_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99df04f0>  parameter: {...e': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_601_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a98f3a0>  parameter: {...hape': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_605_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a746be0>  parameter: {...e': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_607_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9daeb4ca60>  parameter: {...hape': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_611_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a770a60>  parameter: {...e': (2, 2), 'mode': 'constant', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[5, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[5, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_625_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c996c24c0>  parameter: {...2, 2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_629_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca6594340>  parameter: {...2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_631_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99757340>  parameter: {...2, 2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_635_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c996e6f10>  parameter: {...2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_637_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a757ca0>  parameter: {...2, 2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_641_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99acdfd0>  parameter: {...2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_643_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7355b0>  parameter: {...2, 2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_647_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9976f040>  parameter: {...2), 'mode': 'constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[1, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[1, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_661_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9cfee447f0>  parameter: {...shape': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_665_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9976fa00>  parameter: {...pe': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_667_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a983d90>  parameter: {...shape': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_671_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98f37430>  parameter: {...pe': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[5, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[5, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_673_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98f5c6a0>  parameter: {...shape': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_677_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98f5c7c0>  parameter: {...pe': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 5 / 10000 (0.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_679_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98f45a00>  parameter: {...shape': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 4 / 10000 (0.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_683_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98e47910>  parameter: {...pe': (2, 2), 'mode': 'nearest', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[6, 3, 1, ..., 8, 8, 8],
       [5, 7, 6, ..., 8, 8, 8],
       [2, 6, 5, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 4 / 10000 (0.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...
E        y: array([[6, 3, 1, ..., 8, 8, 8],
E              [5, 7, 6, ..., 8, 8, 8],
E              [2, 6, 5, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_697_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98f66040>  parameter: {...(2, 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 2, ..., 8, 8, 8],
       [2, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 2, ..., 8, 8, 8],
       [2, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 2, ..., 8, 8, 8],
E              [2, 2, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 2, ..., 8, 8, 8],
E              [2, 2, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_701_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a0f8a00>  parameter: {... 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 2, ..., 8, 8, 8],
       [2, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 2, ..., 8, 8, 8],
       [2, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 2, ..., 8, 8, 8],
E              [2, 2, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 2, ..., 8, 8, 8],
E              [2, 2, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_703_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c996f5940>  parameter: {...(2, 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 3, ..., 8, 8, 8],
       [3, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 3, ..., 8, 8, 8],
       [3, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 3, ..., 8, 8, 8],
E              [3, 2, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 3, ..., 8, 8, 8],
E              [3, 2, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_707_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a74b760>  parameter: {... 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 3, ..., 8, 8, 8],
       [3, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [3, 2, 3, ..., 8, 8, 8],
       [3, 2, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 3, ..., 8, 8, 8],
E              [3, 2, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [3, 2, 3, ..., 8, 8, 8],
E              [3, 2, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_709_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a902ee0>  parameter: {...(2, 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_713_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a79f730>  parameter: {... 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_715_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca6dba5b0>  parameter: {...(2, 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_719_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca6dba250>  parameter: {... 2), 'mode': 'nearest', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
desired = array([[7, 3, 2, ..., 8, 8, 8],
       [4, 1, 3, ..., 8, 8, 8],
       [2, 3, 8, ..., 8, 8, 8],
       ...,
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8],
       [8, 8, 8, ..., 8, 8, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...
E        y: array([[7, 3, 2, ..., 8, 8, 8],
E              [4, 1, 3, ..., 8, 8, 8],
E              [2, 3, 8, ..., 8, 8, 8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_733_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9914acd0>  parameter: {..._shape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 7, 8, 6],
       [5, 7, 6, ..., 4, 9, 6],
       [2, 6, 5, ..., 3, 7, 2],
       ...,
       [3, 5, 4, ..., 2, 7, 8],
       [7, 3, 2, ..., 7, 2, 4],
       [6, 6, 2, ..., 3, 9, 2]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 6],
       [5, 7, 6, ..., 4, 9, 6],
       [2, 6, 5, ..., 3, 7, 2],
       ...,
       [3, 5, 4, ..., 2, 7, 8],
       [7, 3, 2, ..., 7, 2, 4],
       [6, 6, 2, ..., 3, 9, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 93 / 10000 (0.93%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 7, 8, 6],
E              [5, 7, 6, ..., 4, 9, 6],
E              [2, 6, 5, ..., 3, 7, 2],...
E        y: array([[5, 3, 1, ..., 7, 8, 6],
E              [5, 7, 6, ..., 4, 9, 6],
E              [2, 6, 5, ..., 3, 7, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_737_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d395b0>  parameter: {...ape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 3, 1, ..., 7, 8, 6],
       [5, 7, 6, ..., 4, 9, 6],
       [2, 6, 5, ..., 3, 7, 2],
       ...,
       [3, 5, 4, ..., 2, 7, 8],
       [7, 3, 2, ..., 7, 2, 4],
       [6, 6, 2, ..., 3, 9, 2]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 6],
       [5, 7, 6, ..., 4, 9, 6],
       [2, 6, 5, ..., 3, 7, 2],
       ...,
       [3, 5, 4, ..., 2, 7, 8],
       [7, 3, 2, ..., 7, 2, 4],
       [6, 6, 2, ..., 3, 9, 2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 93 / 10000 (0.93%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 3, 1, ..., 7, 8, 6],
E              [5, 7, 6, ..., 4, 9, 6],
E              [2, 6, 5, ..., 3, 7, 2],...
E        y: array([[5, 3, 1, ..., 7, 8, 6],
E              [5, 7, 6, ..., 4, 9, 6],
E              [2, 6, 5, ..., 3, 7, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_739_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99b48640>  parameter: {..._shape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 4,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  2, ...,  7,  3,  4],
       [ 6,  6,  2, ...,  3,  9,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 4,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  2, ...,  7,  3,  4],
       [ 6,  6,  2, ...,  3,  9,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 114 / 10000 (1.14%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_743_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98d66100>  parameter: {...ape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 4,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  2, ...,  7,  3,  4],
       [ 6,  6,  2, ...,  3,  9,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 4,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  2, ...,  7,  3,  4],
       [ 6,  6,  2, ...,  3,  9,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 114 / 10000 (1.14%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_745_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98d6a850>  parameter: {..._shape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 3,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  3, ...,  7,  3,  3],
       [ 6,  6,  2, ...,  3, 10,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 3,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  3, ...,  7,  3,  3],
       [ 6,  6,  2, ...,  3, 10,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 177 / 10000 (1.77%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_749_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c996712b0>  parameter: {...ape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 3,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  3, ...,  7,  3,  3],
       [ 6,  6,  2, ...,  3, 10,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 10,  5],
       [ 2,  6,  5, ...,  3,  7,  2],
    ... 3,  5,  5, ...,  2,  7,  8],
       [ 6,  3,  3, ...,  7,  3,  3],
       [ 6,  6,  2, ...,  3, 10,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 177 / 10000 (1.77%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 10,  5],
E              [ 2,  6,  5, ...,  3,  7,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_751_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d5b970>  parameter: {..._shape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 11,  5],
       [ 2,  6,  5, ...,  3,  8,  2],
    ... 3,  5,  6, ...,  2,  6,  8],
       [ 7,  3,  3, ...,  7,  2,  3],
       [ 6,  6,  2, ...,  4, 10,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 11,  5],
       [ 2,  6,  5, ...,  3,  8,  2],
    ... 3,  5,  6, ...,  2,  6,  8],
       [ 7,  3,  3, ...,  7,  2,  3],
       [ 6,  6,  2, ...,  4, 10,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 205 / 10000 (2.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 11,  5],
E              [ 2,  6,  5, ...,  3,  8,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 11,  5],
E              [ 2,  6,  5, ...,  3,  8,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_755_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99add6a0>  parameter: {...ape': (2, 2), 'mode': 'mirror', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 11,  5],
       [ 2,  6,  5, ...,  3,  8,  2],
    ... 3,  5,  6, ...,  2,  6,  8],
       [ 7,  3,  3, ...,  7,  2,  3],
       [ 6,  6,  2, ...,  4, 10,  2]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  7,  8,  6],
       [ 5,  7,  6, ...,  4, 11,  5],
       [ 2,  6,  5, ...,  3,  8,  2],
    ... 3,  5,  6, ...,  2,  6,  8],
       [ 7,  3,  3, ...,  7,  2,  3],
       [ 6,  6,  2, ...,  4, 10,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 205 / 10000 (2.05%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 11,  5],
E              [ 2,  6,  5, ...,  3,  8,  2],...
E        y: array([[ 5,  3,  1, ...,  7,  8,  6],
E              [ 5,  7,  6, ...,  4, 11,  5],
E              [ 2,  6,  5, ...,  3,  8,  2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_769_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98d54850>  parameter: {... (2, 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  10],
       [  3,   2,   2, ...,   1,   4,   4],
       [  2,   2,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   6],
       [  8,  10,   9, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 10],
       [ 3,  2,  2, ...,  1,  4,  4],
       [ 2,  2,  8, ...,  5,  0,  4],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  6],
       [ 8, 10,  9, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 85 / 10000 (0.85%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  10],
E              [  3,   2,   2, ...,   1,   4,   4],
E              [  2,   2,   8, ...,   5, 255,   4],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 10],
E              [ 3,  2,  2, ...,  1,  4,  4],
E              [ 2,  2,  8, ...,  5,  0,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_773_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99abf7c0>  parameter: {..., 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  10],
       [  3,   2,   2, ...,   1,   4,   4],
       [  2,   2,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   6],
       [  8,  10,   9, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 10],
       [ 3,  2,  2, ...,  1,  4,  4],
       [ 2,  2,  8, ...,  5,  0,  4],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  6],
       [ 8, 10,  9, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 85 / 10000 (0.85%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  10],
E              [  3,   2,   2, ...,   1,   4,   4],
E              [  2,   2,   8, ...,   5, 255,   4],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 10],
E              [ 3,  2,  2, ...,  1,  4,  4],
E              [ 2,  2,  8, ...,  5,  0,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_775_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7207f0>  parameter: {... (2, 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  11],
       [  3,   2,   3, ...,   0,   4,   5],
       [  3,   2,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  8,  10,   8, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 11],
       [ 3,  2,  3, ...,  0,  4,  5],
       [ 3,  2,  8, ...,  5,  0,  4],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 8, 10,  8, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 123 / 10000 (1.23%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  11],
E              [  3,   2,   3, ...,   0,   4,   5],
E              [  3,   2,   8, ...,   5, 255,   4],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 11],
E              [ 3,  2,  3, ...,  0,  4,  5],
E              [ 3,  2,  8, ...,  5,  0,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_779_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a982880>  parameter: {..., 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  11],
       [  3,   2,   3, ...,   0,   4,   5],
       [  3,   2,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  8,  10,   8, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 11],
       [ 3,  2,  3, ...,  0,  4,  5],
       [ 3,  2,  8, ...,  5,  0,  4],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 8, 10,  8, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 123 / 10000 (1.23%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  11],
E              [  3,   2,   3, ...,   0,   4,   5],
E              [  3,   2,   8, ...,   5, 255,   4],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 11],
E              [ 3,  2,  3, ...,  0,  4,  5],
E              [ 3,  2,  8, ...,  5,  0,  4],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_781_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a99b700>  parameter: {... (2, 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  12],
       [  4,   1,   3, ...,   0,   4,   5],
       [  2,   3,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  9,  10,   8, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 12],
       [ 4,  1,  3, ...,  0,  4,  5],
       [ 2,  3,  8, ...,  5,  0,  3],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 9, 10,  8, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 189 / 10000 (1.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  12],
E              [  4,   1,   3, ...,   0,   4,   5],
E              [  2,   3,   8, ...,   5, 255,   3],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 12],
E              [ 4,  1,  3, ...,  0,  4,  5],
E              [ 2,  3,  8, ...,  5,  0,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_785_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a735250>  parameter: {..., 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  3,   3,   2, ...,   6,   3,  12],
       [  4,   1,   3, ...,   0,   4,   5],
       [  2,   3,   8, ...,   ...,   5,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  9,  10,   8, ...,   8,   3,   2]], dtype=uint8)
desired = array([[ 3,  3,  2, ...,  6,  3, 12],
       [ 4,  1,  3, ...,  0,  4,  5],
       [ 2,  3,  8, ...,  5,  0,  3],
    ... 6,  4,  3, ...,  5,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 9, 10,  8, ...,  8,  3,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 189 / 10000 (1.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  3,   3,   2, ...,   6,   3,  12],
E              [  4,   1,   3, ...,   0,   4,   5],
E              [  2,   3,   8, ...,   5, 255,   3],...
E        y: array([[ 3,  3,  2, ...,  6,  3, 12],
E              [ 4,  1,  3, ...,  0,  4,  5],
E              [ 2,  3,  8, ...,  5,  0,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_787_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9916ec40>  parameter: {... (2, 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   7,   3,  12],
       [  4,   1,   3, ...,   0,   4,   6],
       [  2,   3,   8, ...,   ...,   6,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  9,  10,   8, ...,   9,   2,   2]], dtype=uint8)
desired = array([[ 2,  3,  2, ...,  7,  3, 12],
       [ 4,  1,  3, ...,  0,  4,  6],
       [ 2,  3,  8, ...,  6,  0,  3],
    ... 6,  4,  3, ...,  6,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 9, 10,  8, ...,  9,  2,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 220 / 10000 (2.2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   7,   3,  12],
E              [  4,   1,   3, ...,   0,   4,   6],
E              [  2,   3,   8, ...,   6, 255,   3],...
E        y: array([[ 2,  3,  2, ...,  7,  3, 12],
E              [ 4,  1,  3, ...,  0,  4,  6],
E              [ 2,  3,  8, ...,  6,  0,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_791_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a145760>  parameter: {..., 2), 'mode': 'mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   7,   3,  12],
       [  4,   1,   3, ...,   0,   4,   6],
       [  2,   3,   8, ...,   ...,   6,   4,   7],
       [  2,   4,   6, ...,   8,   3,   7],
       [  9,  10,   8, ...,   9,   2,   2]], dtype=uint8)
desired = array([[ 2,  3,  2, ...,  7,  3, 12],
       [ 4,  1,  3, ...,  0,  4,  6],
       [ 2,  3,  8, ...,  6,  0,  3],
    ... 6,  4,  3, ...,  6,  4,  7],
       [ 2,  4,  6, ...,  8,  3,  7],
       [ 9, 10,  8, ...,  9,  2,  2]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 220 / 10000 (2.2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   7,   3,  12],
E              [  4,   1,   3, ...,   0,   4,   6],
E              [  2,   3,   8, ...,   6, 255,   3],...
E        y: array([[ 2,  3,  2, ...,  7,  3, 12],
E              [ 4,  1,  3, ...,  0,  4,  6],
E              [ 2,  3,  8, ...,  6,  0,  3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_805_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a0ea9d0>  parameter: {...ix_shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   5,   5],
       [  2,   6,   5, ..., 25...,   1,   1,   5],
       [  8,   8,   7, ...,   6,   4,   8],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 5, 5],
       [2, 6, 5, ..., 0, 2, 2],
       ...,
       [5, 6, 4, ..., 1, 1, 5],
       [8, 8, 7, ..., 6, 4, 8],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   5,   5],
E              [  2,   6,   5, ..., 255,   2,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 5, 5],
E              [2, 6, 5, ..., 0, 2, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_809_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a96b340>  parameter: {...shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   5,   5],
       [  2,   6,   5, ..., 25...,   1,   1,   5],
       [  8,   8,   7, ...,   6,   4,   8],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 5, 5],
       [2, 6, 5, ..., 0, 2, 2],
       ...,
       [5, 6, 4, ..., 1, 1, 5],
       [8, 8, 7, ..., 6, 4, 8],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 87 / 10000 (0.87%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   5,   5],
E              [  2,   6,   5, ..., 255,   2,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 5, 5],
E              [2, 6, 5, ..., 0, 2, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_811_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d1f160>  parameter: {...ix_shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   5,   5],
       [  2,   6,   5, ..., 25...,   1,   1,   5],
       [  8,   7,   7, ...,   6,   4,   8],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 5, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 1, 5],
       [8, 7, 7, ..., 6, 4, 8],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 111 / 10000 (1.11%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   5,   5],
E              [  2,   6,   5, ..., 255,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 5, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_815_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d39160>  parameter: {...shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   5,   5],
       [  2,   6,   5, ..., 25...,   1,   1,   5],
       [  8,   7,   7, ...,   6,   4,   8],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 5, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 1, 5],
       [8, 7, 7, ..., 6, 4, 8],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 111 / 10000 (1.11%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   5,   5],
E              [  2,   6,   5, ..., 255,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 5, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_817_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99d47c40>  parameter: {...ix_shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   6,   5],
       [  2,   6,   5, ..., 25...,   1,   0,   5],
       [  9,   7,   7, ...,   6,   4,   9],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 6, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 0, 5],
       [9, 7, 7, ..., 6, 4, 9],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 182 / 10000 (1.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   6,   5],
E              [  2,   6,   5, ..., 254,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 6, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_821_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ce5e4f160>  parameter: {...shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   6,   5],
       [  2,   6,   5, ..., 25...,   1,   0,   5],
       [  9,   7,   7, ...,   6,   4,   9],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 6, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 0, 5],
       [9, 7, 7, ..., 6, 4, 9],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 182 / 10000 (1.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   6,   5],
E              [  2,   6,   5, ..., 254,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 6, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_823_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca759aaf0>  parameter: {...ix_shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   6,   5],
       [  2,   6,   5, ..., 25...,   1,   0,   5],
       [  9,   8,   7, ...,   6,   4,   9],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 6, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 0, 5],
       [9, 8, 7, ..., 6, 4, 9],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 211 / 10000 (2.11%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   6,   5],
E              [  2,   6,   5, ..., 254,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 6, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_827_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9dae99a460>  parameter: {...shape': (2, 2), 'mode': 'wrap', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   1, ...,   7,   8,   5],
       [  5,   7,   6, ...,   4,   6,   5],
       [  2,   6,   5, ..., 25...,   1,   0,   5],
       [  9,   8,   7, ...,   6,   4,   9],
       [  5,   3,   1, ...,   7,   8,   5]], dtype=uint8)
desired = array([[5, 3, 1, ..., 7, 8, 5],
       [5, 7, 6, ..., 4, 6, 5],
       [2, 6, 5, ..., 0, 3, 2],
       ...,
       [5, 6, 4, ..., 1, 0, 5],
       [9, 8, 7, ..., 6, 4, 9],
       [5, 3, 1, ..., 7, 8, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 211 / 10000 (2.11%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   1, ...,   7,   8,   5],
E              [  5,   7,   6, ...,   4,   6,   5],
E              [  2,   6,   5, ..., 254,   3,   2],...
E        y: array([[5, 3, 1, ..., 7, 8, 5],
E              [5, 7, 6, ..., 4, 6, 5],
E              [2, 6, 5, ..., 0, 3, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_841_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98f5c250>  parameter: {...': (2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 2, ..., 1, 1, 3],
       [2, 2, 8, ..., 5, 5, 2],
       ...,
       [3, 6, 2, ..., 7, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
desired = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 2, ..., 1, 1, 3],
       [2, 2, 8, ..., 5, 5, 2],
       ...,
       [3, 6, 2, ..., 7, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 79 / 10000 (0.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 2, ..., 1, 1, 3],
E              [2, 2, 8, ..., 5, 5, 2],...
E        y: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 2, ..., 1, 1, 3],
E              [2, 2, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_845_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98f7af70>  parameter: {...(2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 2, ..., 1, 1, 3],
       [2, 2, 8, ..., 5, 5, 2],
       ...,
       [3, 6, 2, ..., 7, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
desired = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 2, ..., 1, 1, 3],
       [2, 2, 8, ..., 5, 5, 2],
       ...,
       [3, 6, 2, ..., 7, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 79 / 10000 (0.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 2, ..., 1, 1, 3],
E              [2, 2, 8, ..., 5, 5, 2],...
E        y: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 2, ..., 1, 1, 3],
E              [2, 2, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_847_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9dae9a8760>  parameter: {...': (2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 3, ..., 0, 0, 3],
       [3, 2, 8, ..., 5, 5, 3],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
desired = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 3, ..., 0, 0, 3],
       [3, 2, 8, ..., 5, 5, 3],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 3, ..., 0, 0, 3],
E              [3, 2, 8, ..., 5, 5, 3],...
E        y: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 3, ..., 0, 0, 3],
E              [3, 2, 8, ..., 5, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_851_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a72fd00>  parameter: {...(2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 3, ..., 0, 0, 3],
       [3, 2, 8, ..., 5, 5, 3],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
desired = array([[8, 3, 2, ..., 6, 3, 8],
       [3, 2, 3, ..., 0, 0, 3],
       [3, 2, 8, ..., 5, 5, 3],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [8, 3, 2, ..., 6, 3, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 104 / 10000 (1.04%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 3, ..., 0, 0, 3],
E              [3, 2, 8, ..., 5, 5, 3],...
E        y: array([[8, 3, 2, ..., 6, 3, 8],
E              [3, 2, 3, ..., 0, 0, 3],
E              [3, 2, 8, ..., 5, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_853_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9dae9739a0>  parameter: {...': (2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[9, 3, 2, ..., 6, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 6, 3, 9]], dtype=uint8)
desired = array([[9, 3, 2, ..., 6, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 6, 3, 9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 164 / 10000 (1.64%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[9, 3, 2, ..., 6, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...
E        y: array([[9, 3, 2, ..., 6, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_857_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a983850>  parameter: {...(2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[9, 3, 2, ..., 6, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 6, 3, 9]], dtype=uint8)
desired = array([[9, 3, 2, ..., 6, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 6, 3, 9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 164 / 10000 (1.64%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[9, 3, 2, ..., 6, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...
E        y: array([[9, 3, 2, ..., 6, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_859_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a983eb0>  parameter: {...': (2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[9, 3, 2, ..., 7, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 7, 3, 9]], dtype=uint8)
desired = array([[9, 3, 2, ..., 7, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 7, 3, 9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 189 / 10000 (1.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[9, 3, 2, ..., 7, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...
E        y: array([[9, 3, 2, ..., 7, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_863_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99dbdd00>  parameter: {...(2, 2), 'mode': 'wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[9, 3, 2, ..., 7, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 7, 3, 9]], dtype=uint8)
desired = array([[9, 3, 2, ..., 7, 3, 9],
       [4, 1, 3, ..., 0, 0, 4],
       [2, 3, 8, ..., 5, 5, 2],
       ...,
       [3, 7, 3, ..., 6, 4, 3],
       [4, 6, 6, ..., 3, 6, 4],
       [9, 3, 2, ..., 7, 3, 9]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 189 / 10000 (1.89%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[9, 3, 2, ..., 7, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...
E        y: array([[9, 3, 2, ..., 7, 3, 9],
E              [4, 1, 3, ..., 0, 0, 4],
E              [2, 3, 8, ..., 5, 5, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_877_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9daeac86a0>  parameter: {...ape': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 5, 3, 6],
       [2, 6, 5, ..., 1, 4, 2],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 0, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 5, 3, 6],
       [2, 6, 5, ..., 1, 4, 2],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 0, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 91 / 10000 (0.91%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 5, 3, 6],
E              [2, 6, 5, ..., 1, 4, 2],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 5, 3, 6],
E              [2, 6, 5, ..., 1, 4, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_881_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a706790>  parameter: {...': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 5, 3, 6],
       [2, 6, 5, ..., 1, 4, 2],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 0, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 5, 3, 6],
       [2, 6, 5, ..., 1, 4, 2],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 0, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 91 / 10000 (0.91%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 5, 3, 6],
E              [2, 6, 5, ..., 1, 4, 2],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 5, 3, 6],
E              [2, 6, 5, ..., 1, 4, 2],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_883_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a15b7f0>  parameter: {...ape': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 7, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 7, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 116 / 10000 (1.16%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_887_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99aca760>  parameter: {...': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 7, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 7, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [5, 6, 7, ..., 2, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 116 / 10000 (1.16%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_889_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6d8370>  parameter: {...ape': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 1, 4],
       [5, 6, 7, ..., 1, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 1, 4],
       [5, 6, 7, ..., 1, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 184 / 10000 (1.84%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_893_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99b37b80>  parameter: {...': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 1, 4],
       [5, 6, 7, ..., 1, 6, 7]], dtype=uint8)
desired = array([[6, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [5, 9, 1, ..., 5, 8, 4],
       [3, 4, 4, ..., 7, 1, 4],
       [5, 6, 7, ..., 1, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 184 / 10000 (1.84%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[6, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_895_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6a5760>  parameter: {...ape': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [6, 9, 0, ..., 5, 8, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [4, 6, 7, ..., 1, 6, 7]], dtype=uint8)
desired = array([[7, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [6, 9, 0, ..., 5, 8, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [4, 6, 7, ..., 1, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 216 / 10000 (2.16%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[7, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_899_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a8df670>  parameter: {...': (2, 2), 'mode': 'grid-wrap', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [6, 9, 0, ..., 5, 8, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [4, 6, 7, ..., 1, 6, 7]], dtype=uint8)
desired = array([[7, 3, 1, ..., 6, 4, 4],
       [5, 7, 6, ..., 4, 3, 6],
       [2, 6, 5, ..., 1, 5, 3],
       ...,
       [6, 9, 0, ..., 5, 8, 4],
       [3, 4, 4, ..., 6, 1, 4],
       [4, 6, 7, ..., 1, 6, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 216 / 10000 (2.16%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...
E        y: array([[7, 3, 1, ..., 6, 4, 4],
E              [5, 7, 6, ..., 4, 3, 6],
E              [2, 6, 5, ..., 1, 5, 3],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_913_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99abf730>  parameter: {..., 2), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 7],
       [2, 2, 8, ..., 6, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 1],
       [6, 2, 4, ..., 2, 6, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 7],
       [2, 2, 8, ..., 6, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 1],
       [6, 2, 4, ..., 2, 6, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 82 / 10000 (0.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 7],
E              [2, 2, 8, ..., 6, 5, 5],...
E        y: array([[2, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 7],
E              [2, 2, 8, ..., 6, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_917_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9584c0>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[2, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 7],
       [2, 2, 8, ..., 6, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 1],
       [6, 2, 4, ..., 2, 6, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 7],
       [2, 2, 8, ..., 6, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 1],
       [6, 2, 4, ..., 2, 6, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 82 / 10000 (0.82%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[2, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 7],
E              [2, 2, 8, ..., 6, 5, 5],...
E        y: array([[2, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 7],
E              [2, 2, 8, ..., 6, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_919_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98e347c0>  parameter: {..., 2), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[3, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 7],
       [3, 2, 8, ..., 5, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
desired = array([[3, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 7],
       [3, 2, 8, ..., 5, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 109 / 10000 (1.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[3, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 7],
E              [3, 2, 8, ..., 5, 5, 5],...
E        y: array([[3, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 7],
E              [3, 2, 8, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_923_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa6deb0>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[3, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 7],
       [3, 2, 8, ..., 5, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
desired = array([[3, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 7],
       [3, 2, 8, ..., 5, 5, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 109 / 10000 (1.09%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[3, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 7],
E              [3, 2, 8, ..., 5, 5, 5],...
E        y: array([[3, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 7],
E              [3, 2, 8, ..., 5, 5, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_925_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a72f970>  parameter: {..., 2), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   8],
       [  2,   3,   8, ...,   ...,   6,   6,   2],
       [  6,   2,   4, ...,   2,   5,   7],
       [  6,   6,   6, ..., 255,   5,   3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 1, 1],
       [4, 1, 3, ..., 5, 0, 8],
       [2, 3, 8, ..., 5, 6, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 169 / 10000 (1.69%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   8],
E              [  2,   3,   8, ...,   5,   6,   5],...
E        y: array([[2, 3, 2, ..., 2, 1, 1],
E              [4, 1, 3, ..., 5, 0, 8],
E              [2, 3, 8, ..., 5, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_929_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a979460>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   8],
       [  2,   3,   8, ...,   ...,   6,   6,   2],
       [  6,   2,   4, ...,   2,   5,   7],
       [  6,   6,   6, ..., 255,   5,   3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 1, 1],
       [4, 1, 3, ..., 5, 0, 8],
       [2, 3, 8, ..., 5, 6, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 169 / 10000 (1.69%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   8],
E              [  2,   3,   8, ...,   5,   6,   5],...
E        y: array([[2, 3, 2, ..., 2, 1, 1],
E              [4, 1, 3, ..., 5, 0, 8],
E              [2, 3, 8, ..., 5, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_931_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99c6bf70>  parameter: {..., 2), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   8],
       [  2,   3,   8, ...,   ...,   6,   6,   2],
       [  6,   2,   4, ...,   2,   5,   7],
       [  6,   6,   6, ..., 255,   5,   3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 1, 1],
       [4, 1, 3, ..., 4, 0, 8],
       [2, 3, 8, ..., 5, 6, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 197 / 10000 (1.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   8],
E              [  2,   3,   8, ...,   5,   6,   5],...
E        y: array([[2, 3, 2, ..., 2, 1, 1],
E              [4, 1, 3, ..., 4, 0, 8],
E              [2, 3, 8, ..., 5, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_935_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca6d9efa0>  parameter: {...), 'mode': 'grid-wrap', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  2,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   8],
       [  2,   3,   8, ...,   ...,   6,   6,   2],
       [  6,   2,   4, ...,   2,   5,   7],
       [  6,   6,   6, ..., 255,   5,   3]], dtype=uint8)
desired = array([[2, 3, 2, ..., 2, 1, 1],
       [4, 1, 3, ..., 4, 0, 8],
       [2, 3, 8, ..., 5, 6, 5],
       ...,
       [3, 3, 4, ..., 6, 6, 2],
       [6, 2, 4, ..., 2, 5, 7],
       [6, 6, 6, ..., 0, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 197 / 10000 (1.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  2,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   8],
E              [  2,   3,   8, ...,   5,   6,   5],...
E        y: array([[2, 3, 2, ..., 2, 1, 1],
E              [4, 1, 3, ..., 4, 0, 8],
E              [2, 3, 8, ..., 5, 6, 5],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_949_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca6522fa0>  parameter: {...shape': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 97 / 10000 (0.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_953_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a9a5cd0>  parameter: {...pe': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 97 / 10000 (0.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_955_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9daeaef3a0>  parameter: {...shape': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 131 / 10000 (1.31%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_959_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99dc89a0>  parameter: {...pe': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 131 / 10000 (1.31%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_961_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa78910>  parameter: {...shape': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_965_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9aa56640>  parameter: {...pe': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_967_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98f37a60>  parameter: {...shape': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 218 / 10000 (2.18%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_971_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a942af0>  parameter: {...pe': (2, 2), 'mode': 'reflect', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 218 / 10000 (2.18%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_985_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7606a0>  parameter: {...(2, 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   3,   2, ...,   2,   2,   1],
       [  3,   2,   2, ...,   5,   0,   4],
       [  2,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   8, ...,   4,   4,   7],
       [  4,   4,   6, ...,   5,   4,   3]], dtype=uint8)
desired = array([[6, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 4],
       [2, 2, 8, ..., 6, 2, 0],
       ...,
       [5, 1, 3, ..., 4, 2, 8],
       [6, 2, 8, ..., 4, 4, 7],
       [4, 4, 6, ..., 5, 4, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 102 / 10000 (1.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   2, ...,   5,   0,   4],
E              [  2,   2,   8, ...,   6,   2, 255],...
E        y: array([[6, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 4],
E              [2, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_989_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98e239d0>  parameter: {... 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   3,   2, ...,   2,   2,   1],
       [  3,   2,   2, ...,   5,   0,   4],
       [  2,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   8, ...,   4,   4,   7],
       [  4,   4,   6, ...,   5,   4,   3]], dtype=uint8)
desired = array([[6, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 4],
       [2, 2, 8, ..., 6, 2, 0],
       ...,
       [5, 1, 3, ..., 4, 2, 8],
       [6, 2, 8, ..., 4, 4, 7],
       [4, 4, 6, ..., 5, 4, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 102 / 10000 (1.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   2, ...,   5,   0,   4],
E              [  2,   2,   8, ...,   6,   2, 255],...
E        y: array([[6, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 4],
E              [2, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_991_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9914aca0>  parameter: {...(2, 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   2,   1],
       [  3,   2,   3, ...,   5,   0,   4],
       [  3,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   9, ...,   4,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[5, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 4],
       [3, 2, 8, ..., 6, 2, 0],
       ...,
       [4, 1, 3, ..., 4, 2, 8],
       [6, 2, 9, ..., 4, 4, 8],
       [4, 4, 6, ..., 5, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 130 / 10000 (1.3%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   3, ...,   5,   0,   4],
E              [  3,   2,   8, ...,   6,   2, 255],...
E        y: array([[5, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 4],
E              [3, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_995_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99690bb0>  parameter: {... 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   2,   1],
       [  3,   2,   3, ...,   5,   0,   4],
       [  3,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   9, ...,   4,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[5, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 4],
       [3, 2, 8, ..., 6, 2, 0],
       ...,
       [4, 1, 3, ..., 4, 2, 8],
       [6, 2, 9, ..., 4, 4, 8],
       [4, 4, 6, ..., 5, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 130 / 10000 (1.3%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   3, ...,   5,   0,   4],
E              [  3,   2,   8, ...,   6,   2, 255],...
E        y: array([[5, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 4],
E              [3, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_997_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a6aafa0>  parameter: {...(2, 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  5,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  3, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  4,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 179 / 10000 (1.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  5,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1001_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a987040>  parameter: {... 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  5,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  3, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  4,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 179 / 10000 (1.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  5,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1003_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9dae9b4d60>  parameter: {...(2, 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   3,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  4,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  2, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  3,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 202 / 10000 (2.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  4,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1007_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a775e50>  parameter: {... 2), 'mode': 'reflect', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   3,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  4,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  2, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  3,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 202 / 10000 (2.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  4,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1021_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a14bd30>  parameter: {...e': (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 97 / 10000 (0.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1025_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9ca6dba6d0>  parameter: {... (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  5,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  6,  8, ...,  3,  6,  2],
       [ 4, 10,  2, ...,  6,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 97 / 10000 (0.97%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  5,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1027_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9cfef47040>  parameter: {...e': (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 131 / 10000 (1.31%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1031_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a97a790>  parameter: {... (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 5,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  3,  7,  2],
       [ 4, 10,  2, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 131 / 10000 (1.31%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 5,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1033_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7ad340>  parameter: {...e': (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1037_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a15c760>  parameter: {... (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  7],
    ... 3,  2,  4, ...,  7,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  8,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 196 / 10000 (1.96%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1039_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9db1ef1f10>  parameter: {...e': (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 218 / 10000 (2.18%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1043_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9cfee44640>  parameter: {... (2, 2), 'mode': 'grid-mirror', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
desired = array([[ 6,  3,  1, ...,  6,  4,  4],
       [ 5,  7,  6, ...,  4,  3,  7],
       [ 2,  6,  5, ...,  1,  4,  8],
    ... 3,  1,  3, ...,  6,  2,  3],
       [ 4,  5,  8, ...,  4,  7,  2],
       [ 4, 11,  3, ...,  5,  9,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 218 / 10000 (2.18%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...
E        y: array([[ 6,  3,  1, ...,  6,  4,  4],
E              [ 5,  7,  6, ...,  4,  3,  7],
E              [ 2,  6,  5, ...,  1,  4,  8],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1057_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9968f4f0>  parameter: {...2), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   3,   2, ...,   2,   2,   1],
       [  3,   2,   2, ...,   5,   0,   4],
       [  2,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   8, ...,   4,   4,   7],
       [  4,   4,   6, ...,   5,   4,   3]], dtype=uint8)
desired = array([[6, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 4],
       [2, 2, 8, ..., 6, 2, 0],
       ...,
       [5, 1, 3, ..., 4, 2, 8],
       [6, 2, 8, ..., 4, 4, 7],
       [4, 4, 6, ..., 5, 4, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 102 / 10000 (1.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   2, ...,   5,   0,   4],
E              [  2,   2,   8, ...,   6,   2, 255],...
E        y: array([[6, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 4],
E              [2, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1061_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99de3f10>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  6,   3,   2, ...,   2,   2,   1],
       [  3,   2,   2, ...,   5,   0,   4],
       [  2,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   8, ...,   4,   4,   7],
       [  4,   4,   6, ...,   5,   4,   3]], dtype=uint8)
desired = array([[6, 3, 2, ..., 2, 2, 1],
       [3, 2, 2, ..., 5, 0, 4],
       [2, 2, 8, ..., 6, 2, 0],
       ...,
       [5, 1, 3, ..., 4, 2, 8],
       [6, 2, 8, ..., 4, 4, 7],
       [4, 4, 6, ..., 5, 4, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 102 / 10000 (1.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  6,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   2, ...,   5,   0,   4],
E              [  2,   2,   8, ...,   6,   2, 255],...
E        y: array([[6, 3, 2, ..., 2, 2, 1],
E              [3, 2, 2, ..., 5, 0, 4],
E              [2, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1063_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a942700>  parameter: {...2), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   2,   1],
       [  3,   2,   3, ...,   5,   0,   4],
       [  3,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   9, ...,   4,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[5, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 4],
       [3, 2, 8, ..., 6, 2, 0],
       ...,
       [4, 1, 3, ..., 4, 2, 8],
       [6, 2, 9, ..., 4, 4, 8],
       [4, 4, 6, ..., 5, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 130 / 10000 (1.3%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   3, ...,   5,   0,   4],
E              [  3,   2,   8, ...,   6,   2, 255],...
E        y: array([[5, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 4],
E              [3, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1067_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a79da60>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   2,   1],
       [  3,   2,   3, ...,   5,   0,   4],
       [  3,   2,   8, ...,   ...,   4,   2,   8],
       [  6,   2,   9, ...,   4,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[5, 3, 2, ..., 2, 2, 1],
       [3, 2, 3, ..., 5, 0, 4],
       [3, 2, 8, ..., 6, 2, 0],
       ...,
       [4, 1, 3, ..., 4, 2, 8],
       [6, 2, 9, ..., 4, 4, 8],
       [4, 4, 6, ..., 5, 5, 3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 130 / 10000 (1.3%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   2,   1],
E              [  3,   2,   3, ...,   5,   0,   4],
E              [  3,   2,   8, ...,   6,   2, 255],...
E        y: array([[5, 3, 2, ..., 2, 2, 1],
E              [3, 2, 3, ..., 5, 0, 4],
E              [3, 2, 8, ..., 6, 2, 0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1069_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7351f0>  parameter: {...2), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  5,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  3, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  4,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 179 / 10000 (1.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  5,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1073_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a7356d0>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   5,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   4,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  5,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  3, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  4,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 179 / 10000 (1.79%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   5,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  5,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1075_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99dc24f0>  parameter: {...2), 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   3,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  4,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  2, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  3,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 202 / 10000 (2.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  4,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1079_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a100d60>  parameter: {... 'mode': 'grid-mirror', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  5,   3,   2, ...,   2,   1,   1],
       [  4,   1,   3, ...,   4,   0,   4],
       [  2,   3,   8, ...,   ...,   4,   2,   8],
       [  5,   2,  10, ...,   3,   4,   8],
       [  4,   3,   6, ...,   5,   5,   3]], dtype=uint8)
desired = array([[ 5,  3,  2, ...,  2,  1,  1],
       [ 4,  1,  3, ...,  4,  0,  4],
       [ 2,  3,  8, ...,  6,  2,  0],
    ... 4,  1,  2, ...,  4,  2,  8],
       [ 5,  2, 10, ...,  3,  4,  8],
       [ 4,  3,  6, ...,  5,  5,  3]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 202 / 10000 (2.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  5,   3,   2, ...,   2,   1,   1],
E              [  4,   1,   3, ...,   4,   0,   4],
E              [  2,   3,   8, ...,   6,   2, 255],...
E        y: array([[ 5,  3,  2, ...,  2,  1,  1],
E              [ 4,  1,  3, ...,  4,  0,  4],
E              [ 2,  3,  8, ...,  6,  2,  0],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1093_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98f8dee0>  parameter: {...: (2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1097_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99c6fa60>  parameter: {...2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1099_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9cfaa0ae80>  parameter: {...: (2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1103_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99c6f700>  parameter: {...2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[6, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[6, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1105_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98ed75b0>  parameter: {...: (2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1109_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98edf5b0>  parameter: {...2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 3 / 10000 (0.03%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1111_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98ef1c70>  parameter: {...: (2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1115_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a34d1c0>  parameter: {...2, 2), 'mode': 'grid-constant', 'offset': 0.3, 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[7, 3, 1, ..., 1, 1, 1],
       [5, 7, 6, ..., 1, 1, 1],
       [2, 6, 5, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...
E        y: array([[7, 3, 1, ..., 1, 1, 1],
E              [5, 7, 6, ..., 1, 1, 1],
E              [2, 6, 5, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1129_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a352700>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1133_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a329220>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 2, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 2, ..., 1, 1, 1],
       [2, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 2, ..., 1, 1, 1],
E              [2, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1135_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a352850>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1139_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a329280>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 3, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [3, 2, 3, ..., 1, 1, 1],
       [3, 2, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 10000 (0.01%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [3, 2, 3, ..., 1, 1, 1],
E              [3, 2, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1141_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c98cc4d30>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1145_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c9a35ab20>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 4, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1147_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c99778c70>  parameter: {..., 'mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': None, 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestAffineTransform.test_affine_transform_int[_param_1151_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestAffineTransform object at 0x7f9c997b1940>  parameter: {...mode': 'grid-constant', 'offset': [-1.3, 1.3], 'order': 5, 'output': 'empty', 'output_shape': None, 'prefilter': True}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
desired = array([[0, 3, 2, ..., 1, 1, 1],
       [4, 1, 3, ..., 1, 1, 1],
       [2, 3, 8, ..., 1, 1, 1],
       ...,
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1],
       [1, 1, 1, ..., 1, 1, 1]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 10000 (0.02%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...
E        y: array([[0, 3, 2, ..., 1, 1, 1],
E              [4, 1, 3, ..., 1, 1, 1],
E              [2, 3, 8, ..., 1, 1, 1],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestRotate.test_rotate_int[_param_77_{angle=-15, axes=(1, 0), cval=1.0, mode='nearest', order=3, output=None, prefilter=True, reshape=False}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestRotate object at 0x7f9c974a7430>  parameter: {'angle': -15, 'axes': (1, 0), 'cval': 1.0, 'mode': 'nearest', 'order': 3, 'output': None, 'prefilter': True, 'reshape': False}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
       [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
...   0,   6,   4,   2,   4,   1,   1,   1, 255],
       [  4,   2,   7,   1,   2,   5,   0,   6,   9,   8]], dtype=uint8)
desired = array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
       [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
       [ 1,  5,  6, ...5,  0],
       [ 6,  0,  6,  4,  2,  4,  1,  1,  1,  0],
       [ 4,  2,  7,  1,  2,  5,  0,  6,  9,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 100 (1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
E              [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
E              [  1,   5,   6,   5,   4,   2,   3,   1,   9,   7],...
E        y: array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
E              [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
E              [ 1,  5,  6,  5,  4,  2,  3,  1,  9,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestRotate.test_rotate_int[_param_86_{angle=-15, axes=(1, 0), cval=1.0, mode='grid-wrap', order=3, output=None, prefilter=True, reshape=False}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestRotate object at 0x7f9c974c2640>  parameter: {'angle': -15, 'axes': (1, 0), 'cval': 1.0, 'mode': 'grid-wrap', 'order': 3, 'output': None, 'prefilter': True, 'reshape': False}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  7,   7,   5,   6,   6,   4,   5,   5,   2,   6],
       [  5,   9,   6,   5,   9,   0,   1,   2,   9,   9],
...   0,   7,   4,   2,   4,   1,   2,   0,   6],
       [  7,   5,   5,   2,   2,   5, 255,   6,   9,   5]], dtype=uint8)
desired = array([[7, 7, 5, 6, 6, 4, 5, 5, 2, 6],
       [5, 9, 6, 5, 9, 0, 1, 2, 9, 9],
       [3, 4, 6, 5, 4, 2, 3, 1, 8, 7],
 ...2, 6, 8, 2, 2, 2, 4, 5, 0],
       [6, 0, 7, 4, 2, 4, 1, 2, 0, 6],
       [7, 5, 5, 2, 2, 5, 0, 6, 9, 5]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 1 / 100 (1%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  7,   7,   5,   6,   6,   4,   5,   5,   2,   6],
E              [  5,   9,   6,   5,   9,   0,   1,   2,   9,   9],
E              [  3,   4,   6,   5,   4,   2,   3,   1,   8,   7],...
E        y: array([[7, 7, 5, 6, 6, 4, 5, 5, 2, 6],
E              [5, 9, 6, 5, 9, 0, 1, 2, 9, 9],
E              [3, 4, 6, 5, 4, 2, 3, 1, 8, 7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestRotate.test_rotate_int[_param_89_{angle=-15, axes=(1, 0), cval=1.0, mode='reflect', order=3, output=None, prefilter=True, reshape=False}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestRotate object at 0x7f9c97165100>  parameter: {'angle': -15, 'axes': (1, 0), 'cval': 1.0, 'mode': 'reflect', 'order': 3, 'output': None, 'prefilter': True, 'reshape': False}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
       [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
...   0,   6,   4,   2,   4,   1,   2,   1, 255],
       [  4,   3,   7,   1,   2,   5,   0,   6,   9,   8]], dtype=uint8)
desired = array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
       [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
       [ 0,  5,  6, ...5,  0],
       [ 6,  0,  6,  4,  2,  4,  1,  2,  1,  0],
       [ 4,  3,  7,  1,  2,  5,  0,  6,  9,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 100 (2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
E              [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
E              [  0,   5,   6,   5,   4,   2,   3,   1,   9,   7],...
E        y: array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
E              [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
E              [ 0,  5,  6,  5,  4,  2,  3,  1,  9,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestRotate.test_rotate_int[_param_92_{angle=-15, axes=(1, 0), cval=1.0, mode='grid-mirror', order=3, output=None, prefilter=True, reshape=False}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestRotate object at 0x7f9c96ffc1f0>  parameter: {'angle': -15, 'axes': (1, 0), 'cval': 1.0, 'mode': 'grid-mirror', 'order': 3, 'output': None, 'prefilter': True, 'reshape': False}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
       [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
...   0,   6,   4,   2,   4,   1,   2,   1, 255],
       [  4,   3,   7,   1,   2,   5,   0,   6,   9,   8]], dtype=uint8)
desired = array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
       [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
       [ 0,  5,  6, ...5,  0],
       [ 6,  0,  6,  4,  2,  4,  1,  2,  1,  0],
       [ 4,  3,  7,  1,  2,  5,  0,  6,  9,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 2 / 100 (2%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[  8,   7,   5,   5,   6,   4,   7,   5,   7,  10],
E              [  7,   9,   6,   5,   8,   0,   1,   2,   8,   9],
E              [  0,   5,   6,   5,   4,   2,   3,   1,   9,   7],...
E        y: array([[ 8,  7,  5,  5,  6,  4,  7,  5,  7, 10],
E              [ 7,  9,  6,  5,  8,  0,  1,  2,  8,  9],
E              [ 0,  5,  6,  5,  4,  2,  3,  1,  9,  7],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_18_{cval=1.0, mode='constant', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c964460a0>  parameter: {'cval': 1.0, 'mode': 'constant', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [1, 2, 6, ..., 2, 0, 3],
       [1, 5, 4, ..., 7, 9, 9],
       ...,
       [1, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [1, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [1, 2, 6, ..., 2, 0, 3],
       [1, 5, 4, ..., 7, 9, 9],
       ...,
       [1, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [1, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [1, 2, 6, ..., 2, 0, 3],
E              [1, 5, 4, ..., 7, 9, 9],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [1, 2, 6, ..., 2, 0, 3],
E              [1, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_24_{cval=1.0, mode='constant', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c962d1f40>  parameter: {'cval': 1.0, 'mode': 'constant', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 1, 1, ..., 1, 1, 1],
       [1, 2, 6, ..., 2, 0, 3],
       [1, 5, 4, ..., 7, 9, 9],
       ...,
       [1, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [1, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[1, 1, 1, ..., 1, 1, 1],
       [1, 2, 6, ..., 2, 0, 3],
       [1, 5, 4, ..., 7, 9, 9],
       ...,
       [1, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [1, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[1, 1, 1, ..., 1, 1, 1],
E              [1, 2, 6, ..., 2, 0, 3],
E              [1, 5, 4, ..., 7, 9, 9],...
E        y: array([[1, 1, 1, ..., 1, 1, 1],
E              [1, 2, 6, ..., 2, 0, 3],
E              [1, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_45_{cval=1.0, mode='nearest', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c9621e0a0>  parameter: {'cval': 1.0, 'mode': 'nearest', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 73 / 10000 (0.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_51_{cval=1.0, mode='nearest', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c96467280>  parameter: {'cval': 1.0, 'mode': 'nearest', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 73 / 10000 (0.73%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_72_{cval=1.0, mode='mirror', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c95fdc1c0>  parameter: {'cval': 1.0, 'mode': 'mirror', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 0],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 5, 4, ..., 7, 9, 9],
       ...,
       [8, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 0],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 5, 4, ..., 7, 9, 9],
       ...,
       [8, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 0],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 5, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 0],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_78_{cval=1.0, mode='mirror', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c9627f070>  parameter: {'cval': 1.0, 'mode': 'mirror', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 0],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 5, 4, ..., 7, 9, 9],
       ...,
       [8, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 0],
       [6, 2, 6, ..., 2, 0, 3],
       [3, 5, 4, ..., 7, 9, 9],
       ...,
       [8, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 0],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 5, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 0],
E              [6, 2, 6, ..., 2, 0, 3],
E              [3, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_99_{cval=1.0, mode='wrap', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c95f1e250>  parameter: {'cval': 1.0, 'mode': 'wrap', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 2, 4, ..., 7, 0, 8],
       [3, 2, 6, ..., 2, 0, 3],
       [9, 5, 4, ..., 7, 9, 9],
       ...,
       [3, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[8, 2, 4, ..., 7, 0, 8],
       [3, 2, 6, ..., 2, 0, 3],
       [9, 5, 4, ..., 7, 9, 9],
       ...,
       [3, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 2, 4, ..., 7, 0, 8],
E              [3, 2, 6, ..., 2, 0, 3],
E              [9, 5, 4, ..., 7, 9, 9],...
E        y: array([[8, 2, 4, ..., 7, 0, 8],
E              [3, 2, 6, ..., 2, 0, 3],
E              [9, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_105_{cval=1.0, mode='wrap', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c962da910>  parameter: {'cval': 1.0, 'mode': 'wrap', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[8, 2, 4, ..., 7, 0, 8],
       [3, 2, 6, ..., 2, 0, 3],
       [9, 5, 4, ..., 7, 9, 9],
       ...,
       [3, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
desired = array([[8, 2, 4, ..., 7, 0, 8],
       [3, 2, 6, ..., 2, 0, 3],
       [9, 5, 4, ..., 7, 9, 9],
       ...,
       [3, 2, 7, ..., 4, 6, 3],
       [1, 6, 9, ..., 8, 9, 1],
       [8, 2, 4, ..., 7, 0, 8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 68 / 10000 (0.68%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[8, 2, 4, ..., 7, 0, 8],
E              [3, 2, 6, ..., 2, 0, 3],
E              [9, 5, 4, ..., 7, 9, 9],...
E        y: array([[8, 2, 4, ..., 7, 0, 8],
E              [3, 2, 6, ..., 2, 0, 3],
E              [9, 5, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_126_{cval=1.0, mode='grid-wrap', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c962a1070>  parameter: {'cval': 1.0, 'mode': 'grid-wrap', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  1,  0,  3],
       [ 3,  5,  4, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  7,  9, ...,  8,  9,  1],
       [ 8,  1,  5, ...,  8,  0,  7]], dtype=uint8)
desired = array([[ 5,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  1,  0,  3],
       [ 3,  5,  4, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  7,  9, ...,  8,  9,  1],
       [ 8,  1,  5, ...,  8,  0,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 71 / 10000 (0.71%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  1,  0,  3],
E              [ 3,  5,  4, ...,  7,  9, 10],...
E        y: array([[ 5,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  1,  0,  3],
E              [ 3,  5,  4, ...,  7,  9, 10],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_132_{cval=1.0, mode='grid-wrap', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c962da850>  parameter: {'cval': 1.0, 'mode': 'grid-wrap', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  1,  0,  3],
       [ 3,  5,  4, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  7,  9, ...,  8,  9,  1],
       [ 8,  1,  5, ...,  8,  0,  7]], dtype=uint8)
desired = array([[ 5,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  1,  0,  3],
       [ 3,  5,  4, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  7,  9, ...,  8,  9,  1],
       [ 8,  1,  5, ...,  8,  0,  7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 71 / 10000 (0.71%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 5,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  1,  0,  3],
E              [ 3,  5,  4, ...,  7,  9, 10],...
E        y: array([[ 5,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  1,  0,  3],
E              [ 3,  5,  4, ...,  7,  9, 10],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_153_{cval=1.0, mode='reflect', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c96272220>  parameter: {'cval': 1.0, 'mode': 'reflect', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 74 / 10000 (0.74%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_159_{cval=1.0, mode='reflect', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c9623f670>  parameter: {'cval': 1.0, 'mode': 'reflect', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 74 / 10000 (0.74%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_180_{cval=1.0, mode='grid-mirror', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c96263670>  parameter: {'cval': 1.0, 'mode': 'grid-mirror', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 74 / 10000 (0.74%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_186_{cval=1.0, mode='grid-mirror', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c95cf1550>  parameter: {'cval': 1.0, 'mode': 'grid-mirror', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
desired = array([[5, 7, 6, ..., 0, 8, 1],
       [7, 2, 7, ..., 2, 0, 3],
       [3, 6, 4, ..., 7, 9, 9],
       ...,
       [9, 2, 7, ..., 4, 6, 3],
       [2, 6, 9, ..., 8, 9, 1],
       [8, 2, 5, ..., 7, 1, 7]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 74 / 10000 (0.74%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...
E        y: array([[5, 7, 6, ..., 0, 8, 1],
E              [7, 2, 7, ..., 2, 0, 3],
E              [3, 6, 4, ..., 7, 9, 9],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_207_{cval=1.0, mode='grid-constant', order=3, output=None, prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c959824f0>  parameter: {'cval': 1.0, 'mode': 'grid-constant', 'order': 3, 'output': None, 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 4,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  2,  0,  3],
       [ 3,  6,  3, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  6,  9, ...,  8,  9,  1],
       [ 8,  2,  5, ...,  8,  1,  8]], dtype=uint8)
desired = array([[ 4,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  2,  0,  3],
       [ 3,  6,  3, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  6,  9, ...,  8,  9,  1],
       [ 8,  2,  5, ...,  8,  1,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 71 / 10000 (0.71%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 4,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  2,  0,  3],
E              [ 3,  6,  3, ...,  7,  9, 10],...
E        y: array([[ 4,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  2,  0,  3],
E              [ 3,  6,  3, ...,  7,  9, 10],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestShift.test_shift_int[_param_213_{cval=1.0, mode='grid-constant', order=3, output='empty', prefilter=True, shift=0.1}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_interpolation.TestShift object at 0x7f9c95cc2130>  parameter: {'cval': 1.0, 'mode': 'grid-constant', 'order': 3, 'output': 'empty', 'prefilter': True, 'shift': 0.1}>
args = (), kw = {'dtype': <class 'numpy.uint8'>}, dtype = <class 'numpy.uint8'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 4,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  2,  0,  3],
       [ 3,  6,  3, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  6,  9, ...,  8,  9,  1],
       [ 8,  2,  5, ...,  8,  1,  8]], dtype=uint8)
desired = array([[ 4,  7,  6, ...,  0,  8,  1],
       [ 6,  2,  7, ...,  2,  0,  3],
       [ 3,  6,  3, ...,  7,  9, 10],
    ... 8,  2,  7, ...,  4,  6,  3],
       [ 2,  6,  9, ...,  8,  9,  1],
       [ 8,  2,  5, ...,  8,  1,  8]], dtype=uint8)
rtol = 1e-07, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=1e-05
E       
E       Mismatched elements: 71 / 10000 (0.71%)
E       Max absolute difference: 255
E       Max relative difference: 0.
E        x: array([[ 4,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  2,  0,  3],
E              [ 3,  6,  3, ...,  7,  9, 10],...
E        y: array([[ 4,  7,  6, ...,  0,  8,  1],
E              [ 6,  2,  7, ...,  2,  0,  3],
E              [ 3,  6,  3, ...,  7,  9, 10],...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestMeasurementsSelect.test_measurements_select[_param_70_{enable_cub=True, index=1, labels=50, op='extrema', shape=(512,)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_measurements.TestMeasurementsSelect object at 0x7f9c934f2c10>  parameter: {'enable_cub': True, 'index': 1, 'labels': 50, 'op': 'extrema', 'shape': (512,)}>
args = (), kw = {'dtype': <class 'numpy.float64'>}
dtype = <class 'numpy.float64'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([103]), desired = array([103]), rtol = 1e-07, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=0
E       
E       Mismatched elements: 1 / 1 (100%)
E       Max absolute difference: 28
E       Max relative difference: 0.27184466
E        x: array([75])
E        y: array([103])

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
_ TestMeasurementsSelect.test_measurements_select[_param_71_{enable_cub=True, index=1, labels=50, op='extrema', shape=(32, 64)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_measurements.TestMeasurementsSelect object at 0x7f9c93525f10>  parameter: {'enable_cub': True, 'index': 1, 'labels': 50, 'op': 'extrema', 'shape': (32, 64)}>
args = (), kw = {'dtype': <class 'numpy.float64'>}
dtype = <class 'numpy.float64'>

    @_wraps_partial(impl, name)
    def test_func(self, *args, **kw):
        for dtype in dtypes:
            try:
                kw[name] = numpy.dtype(dtype).type
>               impl(self, *args, **kw)

cupy/testing/_helper.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([ 1, 11]), desired = array([ 1, 11]), rtol = 1e-07, atol = 0
err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=0
E       
E       Mismatched elements: 1 / 2 (50%)
E       Max absolute difference: 1125
E       Max relative difference: 1125.
E        x: array([1126,   11])
E        y: array([ 1, 11])

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float64'>
=============================== warnings summary ===============================
tests/cupy_tests/core_tests/fusion_tests/test_array.py: 1 warning
tests/cupy_tests/math_tests/test_sumprod.py: 19 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: overflow encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/core_tests/fusion_tests/test_routines.py::TestFusionNumericalReduction_param_1_{func='prod'}::test_reduction
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: overflow encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_0_{type_l='poly1d', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_3_{type_l='ndarray', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_array
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in multiply
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in half_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in byte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in short_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ubyte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ushort_scalars
    y = y * x + p[i]

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in power
    absx **= ord

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in reciprocal
    absx **= ord

tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf
tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf_nan
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/numeric.py:2276: RuntimeWarning: overflow encountered in absolute
    return less_equal(abs(x-y), atol + rtol * abs(y))

tests/cupy_tests/math_tests/test_sumprod.py: 15 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: invalid value encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: invalid value encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/math_tests/test_sumprod.py: 32 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/tests/cupy_tests/math_tests/test_sumprod.py:799: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all_transposed2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes4
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axis_transposed2
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py::TestStats::test_only_input[_param_2_{op='variance'}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py::TestStats::test_only_input[_param_3_{op='standard_deviation'}]
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:47: RuntimeWarning: overflow encountered in reduce
    return umr_sum(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/statistics_tests/test_meanvar.py: 28 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/tests/cupy_tests/statistics_tests/test_meanvar.py:114: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_4_{axis=0, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_5_{axis=0, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_6_{axis=0, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_7_{axis=0, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_8_{axis=1, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_9_{axis=1, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_10_{axis=1, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_11_{axis=1, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/nanfunctions.py:1113: RuntimeWarning: All-NaN slice encountered
    r, k = function_base._ureduce(a, func=_nanmedian, axis=axis, out=out,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_3_{func='mean', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_5_{func='mean', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3372: RuntimeWarning: Mean of empty slice.
    return _methods._mean(a, axis=axis, dtype=dtype,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:168: RuntimeWarning: invalid value encountered in true_divide
    ret = arr.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_9_{func='std', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_11_{func='std', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:233: RuntimeWarning: Degrees of freedom <= 0 for slice
    ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:194: RuntimeWarning: invalid value encountered in true_divide
    arrmean = um.true_divide(

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_15_{func='var', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_17_{func='var', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3621: RuntimeWarning: Degrees of freedom <= 0 for slice
    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_217_{cval=nan, mode='constant', order=0, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_220_{cval=nan, mode='constant', order=1, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_223_{cval=nan, mode='constant', order=3, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_226_{cval=inf, mode='constant', order=0, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_229_{cval=inf, mode='constant', order=1, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_232_{cval=inf, mode='constant', order=3, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_235_{cval=-inf, mode='constant', order=0, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_238_{cval=-inf, mode='constant', order=1, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_241_{cval=-inf, mode='constant', order=3, output=float64, prefilter=True, shift=0.1}]
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py:497: RuntimeWarning: invalid value encountered in remainder
    float_out = self._shift(xp, scp, a.astype(xp.float64)) % 1

tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/ndimage/measurements.py:684: RuntimeWarning: invalid value encountered in true_divide
    return sum / numpy.asanyarray(count).astype(numpy.float64)

tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py: 28 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/ndimage/measurements.py:736: RuntimeWarning: invalid value encountered in true_divide
    return sum_c_sq / np.asanyarray(count).astype(float)

tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_0_{im=(10,), mysize=3, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_1_{im=(10,), mysize=3, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_2_{im=(10,), mysize=4, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_3_{im=(10,), mysize=4, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_4_{im=(10,), mysize=(3, 4, 5), noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_5_{im=(10,), mysize=(3, 4, 5), noise=True}::test_wiener
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/signal/signaltools.py:1598: RuntimeWarning: divide by zero encountered in true_divide
    res *= (1 - noise / lVar)

tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_0_{im=(10,), mysize=3, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_1_{im=(10,), mysize=3, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_2_{im=(10,), mysize=4, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_3_{im=(10,), mysize=4, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_4_{im=(10,), mysize=(3, 4, 5), noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_5_{im=(10,), mysize=(3, 4, 5), noise=True}::test_wiener
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/signal/signaltools.py:1598: RuntimeWarning: invalid value encountered in multiply
    res *= (1 - noise / lVar)

-- Docs: https://docs.pytest.org/en/stable/warnings.html
- generated html file: file:///home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.43REkaLqLV/cupy/_output/report.html -
=========================== short test summary info ============================
FAILED tests/cupy_tests/creation_tests/test_from_data.py::TestFromData::test_array_from_list_of_numpy_scalar
FAILED tests/cupy_tests/functional_tests/test_vectorize.py::TestVectorizeStmts::test_return_tuple
FAILED tests/cupy_tests/functional_tests/test_vectorize.py::TestVectorizeStmts::test_tuple
FAILED tests/cupy_tests/padding_tests/test_pad.py::TestPadDefault_param_6_{array=array([[0, 1, 2],
       [3, 4, 5]]), mode='linear_ramp', pad_width=1}::test_pad_default - AssertionError: 
FAILED tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py::TestLUSolve_param_0_{shapes=((4, 4), (4,)), trans=0}::test_lu_solve
FAILED tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py::TestLUSolve_param_3_{shapes=((5, 5), (5, 2)), trans=0}::test_lu_solve
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_156_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_158_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_160_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_162_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_324_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...28f1b40>, <function lt_pyfunc at 0x7f9db29bc280>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_326_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...28f1b40>, <function lt_pyfunc at 0x7f9db29bc280>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_484_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_486_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_488_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_490_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core.raw.RawKernel object at 0x7f9db2932b40>, <function rms_pyfunc at 0x7f9db3c38940>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_652_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...28f1b40>, <function lt_pyfunc at 0x7f9db29bc280>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_654_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy.core._reduction.ReductionKernel object at...28f1b40>, <function lt_pyfunc at 0x7f9db29bc280>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_13_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_17_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_19_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_23_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_25_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_29_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_31_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_35_{cval=1.0, matrix_shape=(2,), mode='constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_49_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_53_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_55_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_59_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_61_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_65_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_67_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_71_{cval=1.0, matrix_shape=(2,), mode='constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_85_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_89_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_91_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_95_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_97_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_101_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_103_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_107_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_121_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_125_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_127_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_131_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_133_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_137_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_139_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_143_{cval=1.0, matrix_shape=(2,), mode='nearest', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_157_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_161_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_163_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_167_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_169_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_173_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_175_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_179_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_193_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_197_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_199_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_203_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_205_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_209_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_211_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_215_{cval=1.0, matrix_shape=(2,), mode='mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_229_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_233_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_235_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_239_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_241_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_245_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_247_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_251_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_265_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_269_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_271_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_275_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_277_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_281_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_283_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_287_{cval=1.0, matrix_shape=(2,), mode='wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_301_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_305_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_307_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_311_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_313_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_317_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_319_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_323_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_337_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_341_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_343_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_347_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_349_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_353_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_355_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_359_{cval=1.0, matrix_shape=(2,), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_373_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_377_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_379_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_383_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_385_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_389_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_391_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_395_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_409_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_413_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_415_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_419_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_421_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_425_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_427_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_431_{cval=1.0, matrix_shape=(2,), mode='reflect', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_445_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_449_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_451_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_455_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_457_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_461_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_463_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_467_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_481_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_485_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_487_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_491_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_493_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_497_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_499_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_503_{cval=1.0, matrix_shape=(2,), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_517_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_521_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_523_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_527_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_529_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_533_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_535_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_539_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_553_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_557_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_559_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_563_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_565_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_569_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_571_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_575_{cval=1.0, matrix_shape=(2,), mode='grid-constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_589_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_593_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_595_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_599_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_601_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_605_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_607_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_611_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_625_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_629_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_631_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_635_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_637_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_641_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_643_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_647_{cval=1.0, matrix_shape=(2, 2), mode='constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_661_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_665_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_667_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_671_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_673_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_677_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_679_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_683_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_697_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_701_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_703_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_707_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_709_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_713_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_715_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_719_{cval=1.0, matrix_shape=(2, 2), mode='nearest', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_733_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_737_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_739_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_743_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_745_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_749_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_751_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_755_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_769_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_773_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_775_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_779_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_781_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_785_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_787_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_791_{cval=1.0, matrix_shape=(2, 2), mode='mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_805_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_809_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_811_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_815_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_817_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_821_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_823_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_827_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_841_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_845_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_847_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_851_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_853_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_857_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_859_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_863_{cval=1.0, matrix_shape=(2, 2), mode='wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_877_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_881_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_883_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_887_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_889_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_893_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_895_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_899_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_913_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_917_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_919_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_923_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_925_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_929_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_931_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_935_{cval=1.0, matrix_shape=(2, 2), mode='grid-wrap', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_949_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_953_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_955_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_959_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_961_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_965_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_967_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_971_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_985_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_989_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_991_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_995_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_997_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1001_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1003_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1007_{cval=1.0, matrix_shape=(2, 2), mode='reflect', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1021_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1025_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1027_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1031_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1033_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1037_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1039_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1043_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1057_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1061_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1063_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1067_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1069_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1073_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1075_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1079_{cval=1.0, matrix_shape=(2, 2), mode='grid-mirror', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1093_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1097_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1099_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1103_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1105_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1109_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1111_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1115_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=0.3, order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1129_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=2, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1133_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=2, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1135_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=3, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1139_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=3, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1141_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=4, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1145_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=4, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1147_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=5, output=None, output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestAffineTransform::test_affine_transform_int[_param_1151_{cval=1.0, matrix_shape=(2, 2), mode='grid-constant', offset=[-1.3, 1.3], order=5, output='empty', output_shape=None, prefilter=True}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestRotate::test_rotate_int[_param_77_{angle=-15, axes=(1, 0), cval=1.0, mode='nearest', order=3, output=None, prefilter=True, reshape=False}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestRotate::test_rotate_int[_param_86_{angle=-15, axes=(1, 0), cval=1.0, mode='grid-wrap', order=3, output=None, prefilter=True, reshape=False}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestRotate::test_rotate_int[_param_89_{angle=-15, axes=(1, 0), cval=1.0, mode='reflect', order=3, output=None, prefilter=True, reshape=False}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestRotate::test_rotate_int[_param_92_{angle=-15, axes=(1, 0), cval=1.0, mode='grid-mirror', order=3, output=None, prefilter=True, reshape=False}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_18_{cval=1.0, mode='constant', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_24_{cval=1.0, mode='constant', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_45_{cval=1.0, mode='nearest', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_51_{cval=1.0, mode='nearest', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_72_{cval=1.0, mode='mirror', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_78_{cval=1.0, mode='mirror', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_99_{cval=1.0, mode='wrap', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_105_{cval=1.0, mode='wrap', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_126_{cval=1.0, mode='grid-wrap', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_132_{cval=1.0, mode='grid-wrap', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_153_{cval=1.0, mode='reflect', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_159_{cval=1.0, mode='reflect', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_180_{cval=1.0, mode='grid-mirror', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_186_{cval=1.0, mode='grid-mirror', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_207_{cval=1.0, mode='grid-constant', order=3, output=None, prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_213_{cval=1.0, mode='grid-constant', order=3, output='empty', prefilter=True, shift=0.1}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py::TestMeasurementsSelect::test_measurements_select[_param_70_{enable_cub=True, index=1, labels=50, op='extrema', shape=(512,)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py::TestMeasurementsSelect::test_measurements_select[_param_71_{enable_cub=True, index=1, labels=50, op='extrema', shape=(32, 64)}]
= 296 failed, 63672 passed, 7182 skipped, 58 deselected, 229 xfailed, 272 warnings in 25702.61s (7:08:22) =
