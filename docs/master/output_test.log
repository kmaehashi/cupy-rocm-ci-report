master: 68e96c3 Merge pull request #5122 from leofang/doc_rocm
============================= test session starts ==============================
platform linux -- Python 3.8.7, pytest-6.2.2, py-1.10.0, pluggy-0.13.1
rootdir: /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy, configfile: setup.cfg
plugins: html-3.1.1, metadata-1.11.0
collected 72071 items / 65 deselected / 12 skipped / 71994 selected

tests/cupy_tests/test_cublas.py ........................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  0%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  1%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  2%]
........................................................................ [  3%]
........................................................................ [  3%]
........................................................................ [  3%]
...........................x...........x.............................x.. [  3%]
.........x..........                                                     [  3%]
tests/cupy_tests/test_cudnn.py sssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  3%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  4%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  5%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssss                  [  5%]
tests/cupy_tests/test_cusolver.py ssssssssssssssssssssssssssssssssssssss [  5%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [  6%]
ssssssssssssssssssssssssss                                               [  6%]
tests/cupy_tests/test_cutensor.py ssssssssssssssssssssssssssssssssssssss [  6%]
sssssssssssssssssssssssssssssssssssss                                    [  6%]
tests/cupy_tests/test_init.py ..s.......                                 [  6%]
tests/cupy_tests/test_ndim.py ............                               [  6%]
tests/cupy_tests/test_numpy_interop.py ..x....                           [  6%]
tests/cupy_tests/test_type_routines.py ................................. [  6%]
.                                                                        [  6%]
tests/cupy_tests/binary_tests/test_elementwise.py ......                 [  7%]
tests/cupy_tests/binary_tests/test_packing.py ...                        [  7%]
tests/cupy_tests/core_tests/test_array_function.py .....                 [  7%]
tests/cupy_tests/core_tests/test_carray.py .....                         [  7%]
tests/cupy_tests/core_tests/test_core.py ......                          [  7%]
tests/cupy_tests/core_tests/test_cub_reduction.py ...................... [  7%]
...                                                                      [  7%]
tests/cupy_tests/core_tests/test_dlpack.py ....                          [  7%]
tests/cupy_tests/core_tests/test_elementwise.py ...............          [  7%]
tests/cupy_tests/core_tests/test_flags.py .............................  [  7%]
tests/cupy_tests/core_tests/test_function.py .....                       [  7%]
tests/cupy_tests/core_tests/test_internal.py ........................... [  7%]
...............................................................          [  7%]
tests/cupy_tests/core_tests/test_iter.py ............                    [  7%]
tests/cupy_tests/core_tests/test_ndarray.py ..........................ss [  7%]
ssss.................................................................... [  7%]
......................F...sss...............                             [  7%]
tests/cupy_tests/core_tests/test_ndarray_adv_indexing.py ............... [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
........................................................................ [  7%]
.............................................                            [  7%]
tests/cupy_tests/core_tests/test_ndarray_complex_ops.py ................ [  7%]
.....                                                                    [  7%]
tests/cupy_tests/core_tests/test_ndarray_contiguity.py .                 [  7%]
tests/cupy_tests/core_tests/test_ndarray_conversion.py .......xx..       [  7%]
tests/cupy_tests/core_tests/test_ndarray_copy_and_view.py ss........s... [  7%]
....ssss.......                                                          [  7%]
tests/cupy_tests/core_tests/test_ndarray_cuda_array_interface.py sssssss [  7%]
sssssssssssssssssssssssssssssssssssssssssssssssss                        [  8%]
tests/cupy_tests/core_tests/test_ndarray_elementwise_op.py ............. [  8%]
........................................................................ [  8%]
.................................................................        [  8%]
tests/cupy_tests/core_tests/test_ndarray_get.py ............             [  8%]
tests/cupy_tests/core_tests/test_ndarray_indexing.py xxxx..........x...x [  8%]
........x..........x.............................                        [  8%]
tests/cupy_tests/core_tests/test_ndarray_math.py ......................s [  8%]
sssssssssss                                                              [  8%]
tests/cupy_tests/core_tests/test_ndarray_owndata.py ...                  [  8%]
tests/cupy_tests/core_tests/test_ndarray_reduction.py .................. [  8%]
........................................................................ [  8%]
........................................................................ [  8%]
................................                                         [  8%]
tests/cupy_tests/core_tests/test_ndarray_scatter.py .................... [  8%]
........................................................................ [  8%]
...............................................................          [  8%]
tests/cupy_tests/core_tests/test_ndarray_ufunc.py .......                [  8%]
tests/cupy_tests/core_tests/test_ndarray_unary_op.py .......x..........s [  8%]
...                                                                      [  8%]
tests/cupy_tests/core_tests/test_raw.py .ss.........sss..s.s.s........ss [  8%]
.........sss..s.s.s........ss.........sss..s.s.s......ssssssssssssssssss [  9%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.s [  9%]
s.......sssss....s.s......sssssssssssssssssssssssssssss                  [  9%]
tests/cupy_tests/core_tests/test_reduction.py .......................    [  9%]
tests/cupy_tests/core_tests/test_scan.py ....                            [  9%]
tests/cupy_tests/core_tests/test_syncdetect.py ....                      [  9%]
tests/cupy_tests/core_tests/test_userkernel.py ....sss.............      [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_array.py ................. [  9%]
........................................................................ [  9%]
....................................................                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_indexing.py .............. [  9%]
.................s                                                       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_kernel_cache.py ....       [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_misc.py .......s.......... [  9%]
........                                                                 [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_optimization.py .......... [  9%]
....                                                                     [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_reduction.py ............. [  9%]
........................................................................ [  9%]
.........................................................s.s.s.s.s.s.s.s [  9%]
.s.ssssssssssssssssss.sss                                                [  9%]
tests/cupy_tests/core_tests/fusion_tests/test_routines.py .............. [  9%]
........................................................................ [  9%]
..............                                                           [ 10%]
tests/cupy_tests/core_tests/fusion_tests/test_ufunc.py ................. [ 10%]
......................................................                   [ 10%]
tests/cupy_tests/creation_tests/test_basic.py .......................... [ 10%]
...........................................................s............ [ 10%]
....s.                                                                   [ 10%]
tests/cupy_tests/creation_tests/test_from_data.py ssssssssssssssssssssss [ 10%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssss............. [ 10%]
...................................................................      [ 10%]
tests/cupy_tests/creation_tests/test_matrix.py ......................... [ 10%]
.................................                                        [ 10%]
tests/cupy_tests/creation_tests/test_ranges.py ......................... [ 10%]
..............................................................           [ 10%]
tests/cupy_tests/cuda_tests/test_compiler.py sssssss........             [ 10%]
tests/cupy_tests/cuda_tests/test_cublas.py .                             [ 10%]
tests/cupy_tests/cuda_tests/test_cudnn.py s                              [ 10%]
tests/cupy_tests/cuda_tests/test_cufft.py ssssssssssssssss.              [ 10%]
tests/cupy_tests/cuda_tests/test_curand.py .....                         [ 10%]
tests/cupy_tests/cuda_tests/test_cusolver.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cusparse.py .                           [ 10%]
tests/cupy_tests/cuda_tests/test_cutensor.py s                           [ 10%]
tests/cupy_tests/cuda_tests/test_device.py .............x.               [ 10%]
tests/cupy_tests/cuda_tests/test_driver.py ss.                           [ 10%]
tests/cupy_tests/cuda_tests/test_memory.py ....ssssssss................. [ 10%]
.ssssssssss.........................................s..........sssssssss [ 10%]
                                                                         [ 10%]
tests/cupy_tests/cuda_tests/test_memory_hook.py .                        [ 10%]
tests/cupy_tests/cuda_tests/test_nccl.py ........                        [ 10%]
tests/cupy_tests/cuda_tests/test_nvrtc.py .                              [ 10%]
tests/cupy_tests/cuda_tests/test_nvtx.py ....                            [ 10%]
tests/cupy_tests/cuda_tests/test_pinned_memory.py ............           [ 10%]
tests/cupy_tests/cuda_tests/test_profile.py ..                           [ 10%]
tests/cupy_tests/cuda_tests/test_runtime.py .                            [ 10%]
tests/cupy_tests/cuda_tests/test_stream.py ..s..s..ssssssss.s            [ 10%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_debug_print.py .     [ 10%]
tests/cupy_tests/cuda_tests/memory_hooks_tests/test_line_profile.py ..   [ 10%]
tests/cupy_tests/fft_tests/test_cache.py ..sss.....s..                   [ 10%]
tests/cupy_tests/fft_tests/test_callback.py ssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 11%]
ssssssssssssssssssssssssssssssssssssssssssssssssssss                     [ 11%]
tests/cupy_tests/fft_tests/test_fft.py ....ssss....ssss........ssss....s [ 11%]
sss........ssss....ssss........ssss....ssss........ssss....ssss........s [ 11%]
sss....ssss........ssss....ssss........ssss....ssss........ssss....ssss. [ 12%]
.......ssss....ssss....................................................s [ 12%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 12%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss. [ 12%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 12%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s [ 12%]
..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s.. [ 12%]
s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s. [ 12%]
s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s. [ 12%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 12%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.s.s.sssss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.sssss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.sss [ 13%]
ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.s.s..s.s. [ 13%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 13%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s...ss..ss....ss..ss....ss..ss....ss [ 13%]
..ss....ss..ss....ss..ss....ss..ss....ss..ss...s.s.s.s.s.s.s.s.s.s.s.s.s [ 13%]
.s.s.s.s.s.s.s.s.s.s.s.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s. [ 13%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 13%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s......s.s..s.s..s.s..s.s..s.s..s.s. [ 14%]
.s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s [ 14%]
.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s [ 14%]
..s.s..s.s..s.s..s.s..s.s..s.s..s.s.sssss.s.s..s.s.sssssssssssssssssssss [ 14%]
ssssssssssssssssssssssssssssssssssssssssssss.s.s..s.s..s.s..s.s..s.s..s. [ 14%]
s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s..s.s. [ 14%]
.s.s..s.s..s.s..s.s..s.s..s.s.......ss..ss....ss..ss....ss..ss....ss..ss [ 14%]
....ss..ss....ss..ss....ss..ss....ss..ss........................         [ 14%]
tests/cupy_tests/functional_tests/test_piecewise.py .............        [ 14%]
tests/cupy_tests/functional_tests/test_vectorize.py .................... [ 14%]
................................                                         [ 14%]
tests/cupy_tests/indexing_tests/test_generate.py .......x............... [ 14%]
...............                                                          [ 14%]
tests/cupy_tests/indexing_tests/test_indexing.py ....................... [ 14%]
.........................                                                [ 14%]
tests/cupy_tests/indexing_tests/test_insert.py ......................... [ 14%]
........................................................................ [ 15%]
........................................................................ [ 15%]
.........................................................                [ 15%]
tests/cupy_tests/indexing_tests/test_iterate.py ........................ [ 15%]
...............................................                          [ 15%]
tests/cupy_tests/io_tests/test_base_n.py ............................    [ 15%]
tests/cupy_tests/io_tests/test_formatting.py ..                          [ 15%]
tests/cupy_tests/io_tests/test_npz.py .......                            [ 15%]
tests/cupy_tests/lib_tests/test_polynomial.py .......ss.......ssssssssss [ 15%]
sssssss........ssssssssssssssssssssssssssssssssssssxxxxxxxxxxxxxxxxxxxx. [ 15%]
..ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 15%]
ssssssssssssssssssssssssss......xxxxxxxxxxxxxxxxxxxxxxxx................ [ 15%]
........................................................................ [ 15%]
........xxxxxxxx........xxxxxxxx........................................ [ 15%]
...........xxxxxx............................x.......................... [ 16%]
..                                                                       [ 16%]
tests/cupy_tests/lib_tests/test_shape_base.py ......................     [ 16%]
tests/cupy_tests/lib_tests/test_strided_tricks.py ..                     [ 16%]
tests/cupy_tests/linalg_tests/test_decomposition.py .................... [ 16%]
.......................                                                  [ 16%]
tests/cupy_tests/linalg_tests/test_eigenvalue.py xxxxxxxx                [ 16%]
tests/cupy_tests/linalg_tests/test_einsum.py ........................... [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 16%]
........................................................................ [ 17%]
........................................................................ [ 17%]
..........                                                               [ 17%]
tests/cupy_tests/linalg_tests/test_norms.py ............................ [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
.................................................................        [ 17%]
tests/cupy_tests/linalg_tests/test_product.py .......................... [ 17%]
........................................................................ [ 17%]
........................................................................ [ 17%]
.................................F........                               [ 17%]
tests/cupy_tests/linalg_tests/test_solve.py ............................ [ 17%]
                                                                         [ 17%]
tests/cupy_tests/logic_tests/test_comparison.py ........................ [ 17%]
.....                                                                    [ 17%]
tests/cupy_tests/logic_tests/test_content.py ...                         [ 17%]
tests/cupy_tests/logic_tests/test_ops.py ....                            [ 17%]
tests/cupy_tests/logic_tests/test_truth.py ............................. [ 17%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
........................................................................ [ 18%]
...........................................                              [ 18%]
tests/cupy_tests/logic_tests/test_type_test.py ......................... [ 18%]
.......                                                                  [ 18%]
tests/cupy_tests/manipulation_tests/test_add_remove.py ................. [ 18%]
.........................                                                [ 19%]
tests/cupy_tests/manipulation_tests/test_basic.py ...................... [ 19%]
.......................................................                  [ 19%]
tests/cupy_tests/manipulation_tests/test_dims.py .....x.x............... [ 19%]
................................................                         [ 19%]
tests/cupy_tests/manipulation_tests/test_join.py ....................... [ 19%]
...........................                                              [ 19%]
tests/cupy_tests/manipulation_tests/test_kind.py ...........             [ 19%]
tests/cupy_tests/manipulation_tests/test_rearrange.py .................. [ 19%]
.......................................................                  [ 19%]
tests/cupy_tests/manipulation_tests/test_shape.py ...................... [ 19%]
....................................                                     [ 19%]
tests/cupy_tests/manipulation_tests/test_split.py ..................     [ 19%]
tests/cupy_tests/manipulation_tests/test_tiling.py ..................... [ 19%]
...........                                                              [ 19%]
tests/cupy_tests/manipulation_tests/test_transpose.py .................. [ 19%]
..........                                                               [ 19%]
tests/cupy_tests/math_tests/test_arithmetic.py ......................... [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 19%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 20%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 21%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 22%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 23%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 24%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 25%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 26%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 27%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 28%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 29%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
........................................................................ [ 30%]
...........................                                              [ 30%]
tests/cupy_tests/math_tests/test_explog.py .........                     [ 30%]
tests/cupy_tests/math_tests/test_floating.py .......                     [ 30%]
tests/cupy_tests/math_tests/test_hyperbolic.py ......                    [ 30%]
tests/cupy_tests/math_tests/test_matmul.py ............................. [ 30%]
........................................................................ [ 31%]
........................................................................ [ 31%]
........................................................................ [ 31%]
...............................................                          [ 31%]
tests/cupy_tests/math_tests/test_misc.py ............................... [ 31%]
............................................x..x..x..................... [ 31%]
............................                                             [ 31%]
tests/cupy_tests/math_tests/test_rational.py ....                        [ 31%]
tests/cupy_tests/math_tests/test_rounding.py ........................... [ 31%]
..........................................                               [ 31%]
tests/cupy_tests/math_tests/test_special.py ...                          [ 31%]
tests/cupy_tests/math_tests/test_sumprod.py ............................ [ 31%]
....................................................ssssssssssssssss.... [ 31%]
........................................................................ [ 31%]
........................................................................ [ 31%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
........................................................................ [ 32%]
..............................................................           [ 32%]
tests/cupy_tests/math_tests/test_trigonometric.py ...............        [ 32%]
tests/cupy_tests/math_tests/test_window.py ............................. [ 32%]
.....                                                                    [ 32%]
tests/cupy_tests/misc_tests/test_memory_ranges.py ................       [ 32%]
tests/cupy_tests/misc_tests/test_who.py ......                           [ 32%]
tests/cupy_tests/padding_tests/test_pad.py ............................. [ 32%]
..............................................                           [ 32%]
tests/cupy_tests/polynomial_tests/test_polynomial.py ................... [ 32%]
                                                                         [ 32%]
tests/cupy_tests/polynomial_tests/test_polyutils.py .................... [ 32%]
................                                                         [ 32%]
tests/cupy_tests/prof_tests/test_range.py ........                       [ 32%]
tests/cupy_tests/random_tests/test_bit_generator.py ssssssssssss         [ 32%]
tests/cupy_tests/random_tests/test_distributions.py .................... [ 32%]
........................................................................ [ 33%]
................................................F.F.F.F.F.F.F.F.F.F.F.F. [ 33%]
F.F.F.F.F.F.F.F.F.F.F.F................................................. [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 33%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
.....F.F.F.F............................................................ [ 34%]
........................................................................ [ 34%]
.....                                                                    [ 34%]
tests/cupy_tests/random_tests/test_generator.py ........................ [ 34%]
........................................................................ [ 34%]
........................................................................ [ 34%]
.........................s.s............................................ [ 34%]
...............................x...............................          [ 34%]
tests/cupy_tests/random_tests/test_generator_api.py ssssssssssssssssssss [ 35%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss       [ 35%]
tests/cupy_tests/random_tests/test_init.py .                             [ 35%]
tests/cupy_tests/random_tests/test_permutations.py ...x...x............. [ 35%]
........................................................................ [ 35%]
........................................................................ [ 35%]
.............                                                            [ 35%]
tests/cupy_tests/random_tests/test_random.py .                           [ 35%]
tests/cupy_tests/random_tests/test_sample.py ...............x........x.. [ 35%]
............                                                             [ 35%]
tests/cupy_tests/sorting_tests/test_count.py ....                        [ 35%]
tests/cupy_tests/sorting_tests/test_search.py ssssssss........ssssssss.. [ 35%]
........................................................................ [ 35%]
........................................................................ [ 35%]
....................................................................     [ 35%]
tests/cupy_tests/sorting_tests/test_sort.py ............................ [ 35%]
........................................................................ [ 35%]
..........................................................x...........   [ 35%]
tests/cupy_tests/statistics_tests/test_correlation.py .................. [ 35%]
..............................x..x.xx...................                 [ 36%]
tests/cupy_tests/statistics_tests/test_histogram.py .................... [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
........................................................                 [ 36%]
tests/cupy_tests/statistics_tests/test_meanvar.py ...................... [ 36%]
........................................................................ [ 36%]
........................................................................ [ 36%]
..                                                                       [ 36%]
tests/cupy_tests/statistics_tests/test_order.py sssss................... [ 36%]
.........................                                                [ 36%]
tests/cupy_tests/testing_tests/test_array.py ........................... [ 36%]
...............................................                          [ 36%]
tests/cupy_tests/testing_tests/test_condition.py ................        [ 37%]
tests/cupy_tests/testing_tests/test_helper.py .......................... [ 37%]
........................................................................ [ 37%]
.....sssss..sssssss..ssxxxxxxxx................x..x.................     [ 37%]
tests/cupy_tests/testing_tests/test_parameterized.py ............s.s.s.s [ 37%]
....ssss......                                                           [ 37%]
tests/cupyx_tests/test_cupyx.py ..                                       [ 37%]
tests/cupyx_tests/test_lapack.py .s.s.s.s.....s.s.s.s.....s.s.s.s.....s. [ 37%]
s.s.s.............sssssssssssss                                          [ 37%]
tests/cupyx_tests/test_optimize.py sssssssss                             [ 37%]
tests/cupyx_tests/test_pinned_array.py ................................. [ 37%]
.......................................                                  [ 37%]
tests/cupyx_tests/test_rsqrt.py .                                        [ 37%]
tests/cupyx_tests/test_runtime.py s.                                     [ 37%]
tests/cupyx_tests/test_scatter.py ...                                    [ 37%]
tests/cupyx_tests/test_time.py .........                                 [ 37%]
tests/cupyx_tests/fallback_mode_tests/test_fallback.py ................. [ 37%]
........................................................................ [ 37%]
.........                                                                [ 37%]
tests/cupyx_tests/fallback_mode_tests/test_notifications.py .........    [ 37%]
tests/cupyx_tests/jit_tests/test_raw.py ..........                       [ 37%]
tests/cupyx_tests/linalg_tests/test_solve.py xxxxxxxxxxxxxxxx....ssss    [ 37%]
tests/cupyx_tests/scipy_tests/test_get_array_module.py ..                [ 37%]
tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py .................... [ 37%]
........................................................................ [ 37%]
........................................................................ [ 37%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 38%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 39%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 40%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 41%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 42%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 43%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 44%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 45%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 46%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 47%]
........................................................................ [ 48%]
.................sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 48%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 49%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss.........sss.........sss.........sss.... [ 50%]
.....sss.........sss.........sss........................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 50%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
......................................................FF..FF..FF........ [ 51%]
......................................................................   [ 51%]
tests/cupyx_tests/scipy_tests/fft_tests/test_helper.py .                 [ 51%]
tests/cupyx_tests/scipy_tests/fftpack_tests/test_fftpack.py ............ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 51%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
........................................................................ [ 52%]
.........................                                                [ 52%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py ........... [ 53%]
...............................................F.FF                      [ 53%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_solve_triangular.py .... [ 53%]
........................................................................ [ 53%]
........................................................................ [ 53%]
........................................................................ [ 53%]
....................................................................     [ 53%]
tests/cupyx_tests/scipy_tests/linalg_tests/test_special_matrices.py .... [ 53%]
........................................................................ [ 53%]
.................................................                        [ 53%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py ...sss...... [ 53%]
sss......sss......sss......sss......sss.........sss......sss......sss... [ 53%]
...sss......sss......sss................................................ [ 53%]
...........................................................sss......sss. [ 53%]
.....sss......sss......sss......sss.........sss......sss......sss......s [ 54%]
ss......sss......sss.................................................... [ 54%]
.......................................................sss......sss..... [ 54%]
.sss......sss......sss......sss.........sss......sss......sss......sss.. [ 54%]
....sss......sss........................................................ [ 54%]
...................................................sss......sss......sss [ 54%]
......sss......sss......sss.........sss......sss......sss......sss...... [ 54%]
sss......sss............................................................ [ 54%]
...............................................sss......sss......sss.... [ 54%]
..sss......sss......sss.........sss......sss......sss......sss......sss. [ 54%]
.....sss................................................................ [ 55%]
...........................................sss......sss......sss......ss [ 55%]
s......sss......sss.........sss......sss......sss......sss......sss..... [ 55%]
.sss.................................................................... [ 55%]
.......................................sss......sss......sss......sss... [ 55%]
...sss......sss.........sss......sss......sss......sss......sss......sss [ 55%]
........................................................................ [ 55%]
...................................sss......sss......sss......sss......s [ 55%]
ss......sss.........sss......sss......sss......sss......sss......sss.... [ 55%]
........................................................................ [ 55%]
...............................sss......sss......sss......sss......sss.. [ 56%]
....sss.........sss......sss......sss......sss......sss......sss........ [ 56%]
........................................................................ [ 56%]
...........................sss......sss......sss......sss......sss...... [ 56%]
sss.........sss......sss......sss......sss......sss......sss............ [ 56%]
........................................................................ [ 56%]
.......................sss......sss......sss......sss......sss......sss. [ 56%]
........sss......sss......sss......sss......sss......sss................ [ 56%]
........................................................................ [ 56%]
...................sss......sss......sss......sss......sss......sss..... [ 56%]
....sss......sss......sss......sss......sss......sss.................... [ 57%]
........................................................................ [ 57%]
...............sss......sss......sss......sss......sss......sss......... [ 57%]
sss......sss......sss......sss......sss......sss........................ [ 57%]
........................................................................ [ 57%]
...........sss......sss......sss......sss......sss......sss.........sss. [ 57%]
.....sss......sss......sss......sss......sss............................ [ 57%]
........................................................................ [ 57%]
xxx....sss......sss......sss......sss......sss......sss....x..x.sss.x..x [ 57%]
.sss.x..x.sss......sss......sss......sss................................ [ 57%]
.....................................................x..x.............x. [ 58%]
......................................x.....x....x.....x......x.....x... [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 58%]
........................................................................ [ 59%]
........................F.F.F.F......................................... [ 59%]
........................................................................ [ 59%]
................................................F.F..................... [ 59%]
........................................................................ [ 59%]
................................................................F.F.F.F. [ 59%]
........................................................................ [ 59%]
........................................................................ [ 59%]
................F.F..................................................... [ 59%]
........................................................................ [ 59%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................................................................ [ 60%]
........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 60%]
........................................................................ [ 60%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 61%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 61%]
.............................................................s.s.s.s.s.s [ 61%]
.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 61%]
........................................................................ [ 61%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 61%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 61%]
.............................................................s.s.s.s.s.s [ 61%]
.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 61%]
........................................................................ [ 61%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 62%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 62%]
.............................................................s.s.s.s.s.s [ 62%]
.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s............. [ 62%]
........................................................................ [ 62%]
.........................s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.ss.s.s.s.s.s. [ 62%]
s.s.s.s.s.s.s.s.s.s.s.s................................................. [ 62%]
.............................................................s.s.s.s.s.s [ 62%]
.s.s.s.s.s.s.s.s.s.s.s.ssss..sss..sss............sss..sss..sss.......... [ 62%]
..sss..sss..sss............sss..sss..sss............sss..sss..sss....... [ 62%]
.....sss..sss..sss............sss..sss..sss............sss..sss..sss.... [ 63%]
........sss..sss..sss............sss..sss..sss............sss..sss..sss. [ 63%]
...........sss..sss..sss................................................ [ 63%]
........................................................................ [ 63%]
....................................                                     [ 63%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_fourier.py ............ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 63%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................                                 [ 64%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py ...... [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 64%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 65%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 66%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 67%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 68%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 69%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 70%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 71%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 72%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 73%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 74%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
........................................................................ [ 75%]
...............................x...x.x...x.x...x.x...x.............x...x [ 75%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 75%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 75%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 75%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 75%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 76%]
.x...x.x...x.x...x.............x...x.x...x.x...x.x...x.............x...x [ 77%]
.x...x.x...x.x...x...................................................... [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 77%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
.....................s.................................................. [ 78%]
........................................................................ [ 78%]
........................................................................ [ 78%]
........................................................................ [ 79%]
.........................x.....x.....x.....x.....x.....x.....x.....x.... [ 79%]
.x.....x.....x.....x.......x........x..x..x........s.................... [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 79%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
.......x.....x....................x.....x....................x.....x.... [ 80%]
................x.....x....................x.....x....................x. [ 80%]
....x....................x.....x....................x.....x............. [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................................................ [ 80%]
........................................s............................... [ 80%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
.................................ss..................................... [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 81%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
...........ssssssssssssssssssssssssssssssssssssssssssssssss              [ 82%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py ....... [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 82%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 83%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 84%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 85%]
........................................................................ [ 86%]
........................................................................ [ 86%]
........................................................................ [ 86%]
.....xx..........xx..........xx..........xx..........xx................. [ 86%]
.....xx..................................xx............................. [ 86%]
.....xx..........xx..........xx..........xx..........xx................. [ 86%]
.....xx..................................xx............................. [ 86%]
........................................................................ [ 86%]
........................................................................ [ 86%]
...                                                                      [ 86%]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_morphology.py ......... [ 86%]
......................s....s....s..s....s....s.......................... [ 87%]
..........s....s....s..s....s....s....................................s. [ 87%]
...s....s..s....s....s....................................s....s....s..s [ 87%]
....s....s....................................s....s....s..s....s....s.. [ 87%]
..................................s....s....s..s....s....s.............. [ 87%]
......................s....s....s..s....s....s.......................... [ 87%]
..........s....s....s..s....s....s....................................s. [ 87%]
...s....s..s....s....s....................................s....s....s..s [ 87%]
....s....s....................................s....s....s..s....s....s.. [ 87%]
..................................s....s....s..s....s....s.............. [ 87%]
......................s....s....s..s....s....s.......................... [ 88%]
..........s....s....s..s....s....s....................................s. [ 88%]
...s....s..s....s....s....................................s....s....s..s [ 88%]
....s....s....................................s....s....s..s....s....s.. [ 88%]
..................................s....s....s..s....s....s.............. [ 88%]
......................s....s....s..s....s....s.......................... [ 88%]
..........s....s....s..s....s....s....................................s. [ 88%]
...s....s..s....s....s....................................s....s....s..s [ 88%]
....s....s....................................s....s....s..s....s....s.. [ 88%]
..................................s....s....s..s....s....s.............. [ 88%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
........................................................................ [ 89%]
.......................................................................s [ 89%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 89%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 89%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 90%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 91%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 92%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............s [ 93%]
.s.s.............s.s.s.............s.s.s.............s.s.s.............. [ 93%]
........................................................................ [ 93%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 93%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 93%]
..........................................s....s....s....s....s....s.... [ 93%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 93%]
s....s....s....s........................................................ [ 93%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 94%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 94%]
..........................................s....s....s....s....s....s.... [ 94%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 94%]
s....s....s....s........................................................ [ 94%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 94%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 94%]
..........................................s....s....s....s....s....s.... [ 94%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 94%]
s....s....s....s........................................................ [ 94%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 95%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 95%]
..........................................s....s....s....s....s....s.... [ 95%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 95%]
s....s....s....s........................................................ [ 95%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 95%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 95%]
..........................................s....s....s....s....s....s.... [ 95%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 95%]
s....s....s....s........................................................ [ 95%]
......s....s....s....s....s....s....s....s....s....s....s....s......s... [ 96%]
.s....s....s....s....s....s....s....s....s....s....s.................... [ 96%]
..........................................s....s....s....s....s....s.... [ 96%]
s....s....s....s....s....s......s....s....s....s....s....s....s....s.... [ 96%]
s....s....s....s........................................................ [ 96%]
........................................................................ [ 96%]
........................................................................ [ 96%]
........................................................................ [ 96%]
........................................................ssssssss........ [ 96%]
........................................................ssssssss........ [ 96%]
........................................................ssssssss........ [ 97%]
........................................................ssssssss........ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 97%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
........................................................................ [ 98%]
                                                                         [ 98%]
tests/cupyx_tests/scipy_tests/signal_tests/test_bsplines.py ............ [ 98%]
                                                                         [ 98%]
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py ......... [ 98%]
........................................................................ [ 98%]
......................................................xxxxxxxxx......... [ 98%]
...........................xxxxxxxxxxxx................................. [ 98%]
....FF......xxx..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x..x.x.. [ 98%]
x.x..................................................................... [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
....................................                                     [ 99%]
tests/cupyx_tests/scipy_tests/sparse_tests/csgraph_tests/test_traversal.py s [ 99%]
ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss [ 99%]
sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss  [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_bessel.py ............  [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_convex_analysis.py .... [ 99%]
.                                                                        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_digamma.py .....        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_erf.py ............     [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gamma.py ....           [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_gammaln.py ....         [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_polygamma.py ....       [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_statistics.py ..        [ 99%]
tests/cupyx_tests/scipy_tests/special_tests/test_zeta.py ....            [ 99%]
tests/cupyx_tests/scipy_tests/stats_tests/test_distributions.py ........ [ 99%]
........................................................................ [ 99%]
........................................................................ [ 99%]
                                                                         [ 99%]
tests/cupyx_tests/tools_tests/test_install_library.py ......             [ 99%]
tests/example_tests/test_custom_struct.py FFF                            [ 99%]
tests/example_tests/test_finance.py ...                                  [ 99%]
tests/example_tests/test_gemm.py .                                       [ 99%]
tests/example_tests/test_gmm.py ss                                       [ 99%]
tests/example_tests/test_kmeans.py sss                                   [ 99%]
tests/install_tests/test_build.py sx.                                    [ 99%]
tests/install_tests/test_utils.py ..                                     [100%]

=================================== FAILURES ===================================
______________ TestNdarrayCopy.test_copy_multi_device_with_stream ______________

self = <cupy_tests.core_tests.test_ndarray.TestNdarrayCopy testMethod=test_copy_multi_device_with_stream>

    @testing.multi_gpu(2)
    def test_copy_multi_device_with_stream(self):
        # Kernel that takes long enough then finally writes values.
        kern = cupy.RawKernel(
            _test_copy_multi_device_with_stream_src, 'wait_and_write')
    
        # Allocates a memory and launches the kernel on a device with its
        # stream.
        with cuda.Device(0):
            with cuda.Stream():
                a = cupy.zeros((2,), dtype=numpy.uint64)
                kern((1,), (1,), a)
    
        # D2D copy to another device with another stream should get the
        # original values of the memory before the kernel on the first device
        # finally makes the write.
        with cuda.Device(1):
            with cuda.Stream():
                b = a.copy()
>               testing.assert_array_equal(
                    b, numpy.array([0, 0], dtype=numpy.uint64))

tests/cupy_tests/core_tests/test_ndarray.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([              1, 635013067470121], dtype=uint64)
y = array([0, 0], dtype=uint64), err_msg = '', verbose = True
strides_check = False

    def assert_array_equal(x, y, err_msg='', verbose=True, strides_check=False):
        """Raises an AssertionError if two array_like objects are not equal.
    
        Args:
             x(numpy.ndarray or cupy.ndarray): The actual object to check.
             y(numpy.ndarray or cupy.ndarray): The desired, expected object.
             strides_check(bool): If ``True``, consistency of strides is also
                 checked.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting values
                 are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_array_equal`
        """
>       numpy.testing.assert_array_equal(
            cupy.asnumpy(x), cupy.asnumpy(y), err_msg=err_msg,
            verbose=verbose)
E       AssertionError: 
E       Arrays are not equal
E       
E       Mismatched elements: 2 / 2 (100%)
E       Max absolute difference: 635013067470121
E       Max relative difference: inf
E        x: array([              1, 635013067470121], dtype=uint64)
E        y: array([0, 0], dtype=uint64)

cupy/testing/_array.py:91: AssertionError
_____________________ TestMatrixPower.test_matrix_power_1 ______________________
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]], dtype=uint8)
desired = array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]], dtype=uint8)
rtol = 1e-07, atol = 0, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-07, atol=0
E       
E       Mismatched elements: 4 / 9 (44.4%)
E       Max absolute difference: 254
E       Max relative difference: 127.
E        x: array([[1, 0, 0],
E              [0, 2, 6],
E              [7, 8, 9]], dtype=uint8)
E        y: array([[1, 2, 3],
E              [4, 5, 6],
E              [7, 8, 9]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.uint8'>
_ TestDistributionsGamma_param_0_{dtype=float64, scale_shape=(), shape=(4, 3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_0_{dtype=float64, scale_shape=(), shape=(4, ...ma_generator>  parameter: {'dtype': <class 'numpy.float64'>, 'scale_shape': (), 'shape': (4, 3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_1_{dtype=float64, scale_shape=(), shape=(4, 3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_1_{dtype=float64, scale_shape=(), shape=(4, ...enerator>  parameter: {'dtype': <class 'numpy.float64'>, 'scale_shape': (), 'shape': (4, 3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_2_{dtype=float64, scale_shape=(), shape=(3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_2_{dtype=float64, scale_shape=(), shape=(3, ...gamma_generator>  parameter: {'dtype': <class 'numpy.float64'>, 'scale_shape': (), 'shape': (3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_3_{dtype=float64, scale_shape=(), shape=(3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_3_{dtype=float64, scale_shape=(), shape=(3, ...a_generator>  parameter: {'dtype': <class 'numpy.float64'>, 'scale_shape': (), 'shape': (3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_4_{dtype=float64, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_4_{dtype=float64, scale_shape=(3, 2), shape=...enerator>  parameter: {'dtype': <class 'numpy.float64'>, 'scale_shape': (3, 2), 'shape': (4, 3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_5_{dtype=float64, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_5_{dtype=float64, scale_shape=(3, 2), shape=...ator>  parameter: {'dtype': <class 'numpy.float64'>, 'scale_shape': (3, 2), 'shape': (4, 3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_6_{dtype=float64, scale_shape=(3, 2), shape=(3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_6_{dtype=float64, scale_shape=(3, 2), shape=...a_generator>  parameter: {'dtype': <class 'numpy.float64'>, 'scale_shape': (3, 2), 'shape': (3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_7_{dtype=float64, scale_shape=(3, 2), shape=(3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_7_{dtype=float64, scale_shape=(3, 2), shape=...nerator>  parameter: {'dtype': <class 'numpy.float64'>, 'scale_shape': (3, 2), 'shape': (3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_8_{dtype=float32, scale_shape=(), shape=(4, 3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_8_{dtype=float32, scale_shape=(), shape=(4, ...ma_generator>  parameter: {'dtype': <class 'numpy.float32'>, 'scale_shape': (), 'shape': (4, 3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_9_{dtype=float32, scale_shape=(), shape=(4, 3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_9_{dtype=float32, scale_shape=(), shape=(4, ...enerator>  parameter: {'dtype': <class 'numpy.float32'>, 'scale_shape': (), 'shape': (4, 3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_10_{dtype=float32, scale_shape=(), shape=(3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_10_{dtype=float32, scale_shape=(), shape=(3,...gamma_generator>  parameter: {'dtype': <class 'numpy.float32'>, 'scale_shape': (), 'shape': (3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_11_{dtype=float32, scale_shape=(), shape=(3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_11_{dtype=float32, scale_shape=(), shape=(3,...a_generator>  parameter: {'dtype': <class 'numpy.float32'>, 'scale_shape': (), 'shape': (3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_12_{dtype=float32, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_12_{dtype=float32, scale_shape=(3, 2), shape...enerator>  parameter: {'dtype': <class 'numpy.float32'>, 'scale_shape': (3, 2), 'shape': (4, 3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_13_{dtype=float32, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_13_{dtype=float32, scale_shape=(3, 2), shape...ator>  parameter: {'dtype': <class 'numpy.float32'>, 'scale_shape': (3, 2), 'shape': (4, 3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_14_{dtype=float32, scale_shape=(3, 2), shape=(3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_14_{dtype=float32, scale_shape=(3, 2), shape...a_generator>  parameter: {'dtype': <class 'numpy.float32'>, 'scale_shape': (3, 2), 'shape': (3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_15_{dtype=float32, scale_shape=(3, 2), shape=(3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_15_{dtype=float32, scale_shape=(3, 2), shape...nerator>  parameter: {'dtype': <class 'numpy.float32'>, 'scale_shape': (3, 2), 'shape': (3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_16_{dtype=float16, scale_shape=(), shape=(4, 3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_16_{dtype=float16, scale_shape=(), shape=(4,...ma_generator>  parameter: {'dtype': <class 'numpy.float16'>, 'scale_shape': (), 'shape': (4, 3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_17_{dtype=float16, scale_shape=(), shape=(4, 3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_17_{dtype=float16, scale_shape=(), shape=(4,...enerator>  parameter: {'dtype': <class 'numpy.float16'>, 'scale_shape': (), 'shape': (4, 3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_18_{dtype=float16, scale_shape=(), shape=(3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_18_{dtype=float16, scale_shape=(), shape=(3,...gamma_generator>  parameter: {'dtype': <class 'numpy.float16'>, 'scale_shape': (), 'shape': (3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_19_{dtype=float16, scale_shape=(), shape=(3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_19_{dtype=float16, scale_shape=(), shape=(3,...a_generator>  parameter: {'dtype': <class 'numpy.float16'>, 'scale_shape': (), 'shape': (3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_20_{dtype=float16, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_20_{dtype=float16, scale_shape=(3, 2), shape...enerator>  parameter: {'dtype': <class 'numpy.float16'>, 'scale_shape': (3, 2), 'shape': (4, 3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_21_{dtype=float16, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_21_{dtype=float16, scale_shape=(3, 2), shape...ator>  parameter: {'dtype': <class 'numpy.float16'>, 'scale_shape': (3, 2), 'shape': (4, 3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_22_{dtype=float16, scale_shape=(3, 2), shape=(3, 2), shape_shape=()}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_22_{dtype=float16, scale_shape=(3, 2), shape...a_generator>  parameter: {'dtype': <class 'numpy.float16'>, 'scale_shape': (3, 2), 'shape': (3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsGamma_param_23_{dtype=float16, scale_shape=(3, 2), shape=(3, 2), shape_shape=(3, 2)}.test_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsGamma_param_23_{dtype=float16, scale_shape=(3, 2), shape...nerator>  parameter: {'dtype': <class 'numpy.float16'>, 'scale_shape': (3, 2), 'shape': (3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float32'>, scale_dtype = <class 'numpy.float32'>

    @cupy.testing.for_dtypes_combination(
        _float_dtypes, names=['shape_dtype', 'scale_dtype'])
    def test_gamma_generator(self, shape_dtype, scale_dtype):
>       self.check_distribution(cupy.random.default_rng().gamma,
                                shape_dtype, scale_dtype)

tests/cupy_tests/random_tests/test_distributions.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
{'shape_dtype': <class 'numpy.float32'>, 'scale_dtype': <class 'numpy.float32'>}
_ TestDistributionsStandardGamma_param_0_{shape=(4, 3, 2), shape_shape=()}.test_standard_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsStandardGamma_param_0_{shape=(4, 3, 2), shape_shape=()} testMethod=test_standard_gamma_generator>  parameter: {'shape': (4, 3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float64'>, dtype = <class 'numpy.float64'>

    @cupy.testing.for_float_dtypes('dtype', no_float16=True)
    @cupy.testing.for_float_dtypes('shape_dtype')
    def test_standard_gamma_generator(self, shape_dtype, dtype):
        shape = numpy.ones(self.shape_shape, dtype=shape_dtype)
>       self.check_generator_distribution('standard_gamma',
                                          {'shape': shape},
                                          dtype)

tests/cupy_tests/random_tests/test_distributions.py:639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/random_tests/test_distributions.py:31: in check_generator_distribution
    cp_gen = cupy.random.default_rng()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
shape_dtype is <class 'numpy.float64'>
dtype is <class 'numpy.float64'>
_ TestDistributionsStandardGamma_param_1_{shape=(4, 3, 2), shape_shape=(3, 2)}.test_standard_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsStandardGamma_param_1_{shape=(4, 3, 2), shape_shape=(3, 2)} testMethod=test_standard_gamma_generator>  parameter: {'shape': (4, 3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float64'>, dtype = <class 'numpy.float64'>

    @cupy.testing.for_float_dtypes('dtype', no_float16=True)
    @cupy.testing.for_float_dtypes('shape_dtype')
    def test_standard_gamma_generator(self, shape_dtype, dtype):
        shape = numpy.ones(self.shape_shape, dtype=shape_dtype)
>       self.check_generator_distribution('standard_gamma',
                                          {'shape': shape},
                                          dtype)

tests/cupy_tests/random_tests/test_distributions.py:639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/random_tests/test_distributions.py:31: in check_generator_distribution
    cp_gen = cupy.random.default_rng()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
shape_dtype is <class 'numpy.float64'>
dtype is <class 'numpy.float64'>
_ TestDistributionsStandardGamma_param_2_{shape=(3, 2), shape_shape=()}.test_standard_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsStandardGamma_param_2_{shape=(3, 2), shape_shape=()} testMethod=test_standard_gamma_generator>  parameter: {'shape': (3, 2), 'shape_shape': ()}>
shape_dtype = <class 'numpy.float64'>, dtype = <class 'numpy.float64'>

    @cupy.testing.for_float_dtypes('dtype', no_float16=True)
    @cupy.testing.for_float_dtypes('shape_dtype')
    def test_standard_gamma_generator(self, shape_dtype, dtype):
        shape = numpy.ones(self.shape_shape, dtype=shape_dtype)
>       self.check_generator_distribution('standard_gamma',
                                          {'shape': shape},
                                          dtype)

tests/cupy_tests/random_tests/test_distributions.py:639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/random_tests/test_distributions.py:31: in check_generator_distribution
    cp_gen = cupy.random.default_rng()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
shape_dtype is <class 'numpy.float64'>
dtype is <class 'numpy.float64'>
_ TestDistributionsStandardGamma_param_3_{shape=(3, 2), shape_shape=(3, 2)}.test_standard_gamma_generator _

self = <<cupy_tests.random_tests.test_distributions.TestDistributionsStandardGamma_param_3_{shape=(3, 2), shape_shape=(3, 2)} testMethod=test_standard_gamma_generator>  parameter: {'shape': (3, 2), 'shape_shape': (3, 2)}>
shape_dtype = <class 'numpy.float64'>, dtype = <class 'numpy.float64'>

    @cupy.testing.for_float_dtypes('dtype', no_float16=True)
    @cupy.testing.for_float_dtypes('shape_dtype')
    def test_standard_gamma_generator(self, shape_dtype, dtype):
        shape = numpy.ones(self.shape_shape, dtype=shape_dtype)
>       self.check_generator_distribution('standard_gamma',
                                          {'shape': shape},
                                          dtype)

tests/cupy_tests/random_tests/test_distributions.py:639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/cupy_tests/random_tests/test_distributions.py:31: in check_generator_distribution
    cp_gen = cupy.random.default_rng()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

seed = None

    def default_rng(seed=None):  # NOQA  avoid redefinition of seed
        """Construct a new Generator with the default BitGenerator (XORWOW).
    
        Args:
            seed (None, int, array_like[ints], numpy.random.SeedSequence, cupy.random.BitGenerator, cupy.random.Generator, optional):
                A seed to initialize the :class:`cupy.random.BitGenerator`. If an
                ``int`` or ``array_like[ints]`` or None is passed, then it will be
                passed to :class:`numpy.random.SeedSequence` to detive the initial
                :class:`BitGenerator` state. One may also pass in a `SeedSequence
                instance. Adiditionally, when passed :class:`BitGenerator`, it will
                be wrapped by :class:`Generator`. If passed a :class:`Generator`,
                it will be returned unaltered.
    
        Returns:
            Generator: The initialized generator object.
        """  # NOQA, list of types need to be in one line for sphinx
        if runtime.is_hip:
>           raise RuntimeError('Generator API not supported in HIP,'
                               ' please use the legacy one.')
E           RuntimeError: Generator API not supported in HIP, please use the legacy one.

cupy/random/__init__.py:36: RuntimeError
----------------------------- Captured stdout call -----------------------------
shape_dtype is <class 'numpy.float64'>
dtype is <class 'numpy.float64'>
_ TestHfftn_param_20_{axes=None, norm=None, s=None, shape=(3, 3, 10)}.test_hfftn _
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[[ 7.79958252e+02,  5.62262268e+02,  7.20955353e+01,
          1.35494995e+02, -8.87500153e+01,  9.28420334e+01..., -2.22661572e+01,  7.20881348e+01,
          4.12633820e+01, -4.14133606e+01,  7.91212988e+00]]],
      dtype=float32)
desired = array([[[ 7.79958313e+02,  5.62262207e+02,  7.20955429e+01,
          1.35495010e+02, -8.87500305e+01,  9.28419800e+01..., -2.22661552e+01,  7.20881348e+01,
          4.12633858e+01, -4.14133606e+01,  7.91212845e+00]]],
      dtype=float32)
rtol = 0.0004, atol = 1e-07, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.0004, atol=1e-07
E       
E       Mismatched elements: 1 / 162 (0.617%)
E       Max absolute difference: 8.022785e-05
E       Max relative difference: 0.00053083
E        x: array([[[ 7.799583e+02,  5.622623e+02,  7.209554e+01,  1.354950e+02,
E                -8.875002e+01,  9.284203e+01, -1.996969e+01,  8.982819e+01,
E                 4.771265e+00,  3.475858e+01, -4.139374e+01,  1.398418e+00,...
E        y: array([[[ 7.799583e+02,  5.622622e+02,  7.209554e+01,  1.354950e+02,
E                -8.875003e+01,  9.284198e+01, -1.996969e+01,  8.982815e+01,
E                 4.771230e+00,  3.475859e+01, -4.139378e+01,  1.398499e+00,...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
_ TestHfftn_param_20_{axes=None, norm=None, s=None, shape=(3, 3, 10)}.test_hfftn_backend _
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[[ 7.79958252e+02,  5.62262268e+02,  7.20955353e+01,
          1.35494995e+02, -8.87500153e+01,  9.28420334e+01..., -2.22661572e+01,  7.20881348e+01,
          4.12633820e+01, -4.14133606e+01,  7.91212988e+00]]],
      dtype=float32)
desired = array([[[ 7.79958313e+02,  5.62262207e+02,  7.20955429e+01,
          1.35495010e+02, -8.87500305e+01,  9.28419800e+01..., -2.22661552e+01,  7.20881348e+01,
          4.12633858e+01, -4.14133606e+01,  7.91212845e+00]]],
      dtype=float32)
rtol = 0.0004, atol = 1e-07, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.0004, atol=1e-07
E       
E       Mismatched elements: 1 / 162 (0.617%)
E       Max absolute difference: 8.022785e-05
E       Max relative difference: 0.00053083
E        x: array([[[ 7.799583e+02,  5.622623e+02,  7.209554e+01,  1.354950e+02,
E                -8.875002e+01,  9.284203e+01, -1.996969e+01,  8.982819e+01,
E                 4.771265e+00,  3.475858e+01, -4.139374e+01,  1.398418e+00,...
E        y: array([[[ 7.799583e+02,  5.622622e+02,  7.209554e+01,  1.354950e+02,
E                -8.875003e+01,  9.284198e+01, -1.996969e+01,  8.982815e+01,
E                 4.771230e+00,  3.475859e+01, -4.139378e+01,  1.398499e+00,...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
_ TestHfftn_param_21_{axes=None, norm='backward', s=None, shape=(3, 3, 10)}.test_hfftn _
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[[ 7.79958252e+02,  5.62262268e+02,  7.20955353e+01,
          1.35494995e+02, -8.87500153e+01,  9.28420334e+01..., -2.22661572e+01,  7.20881348e+01,
          4.12633820e+01, -4.14133606e+01,  7.91212988e+00]]],
      dtype=float32)
desired = array([[[ 7.79958313e+02,  5.62262207e+02,  7.20955429e+01,
          1.35495010e+02, -8.87500305e+01,  9.28419800e+01..., -2.22661552e+01,  7.20881348e+01,
          4.12633858e+01, -4.14133606e+01,  7.91212845e+00]]],
      dtype=float32)
rtol = 0.0004, atol = 1e-07, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.0004, atol=1e-07
E       
E       Mismatched elements: 1 / 162 (0.617%)
E       Max absolute difference: 8.022785e-05
E       Max relative difference: 0.00053083
E        x: array([[[ 7.799583e+02,  5.622623e+02,  7.209554e+01,  1.354950e+02,
E                -8.875002e+01,  9.284203e+01, -1.996969e+01,  8.982819e+01,
E                 4.771265e+00,  3.475858e+01, -4.139374e+01,  1.398418e+00,...
E        y: array([[[ 7.799583e+02,  5.622622e+02,  7.209554e+01,  1.354950e+02,
E                -8.875003e+01,  9.284198e+01, -1.996969e+01,  8.982815e+01,
E                 4.771230e+00,  3.475859e+01, -4.139378e+01,  1.398499e+00,...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
_ TestHfftn_param_21_{axes=None, norm='backward', s=None, shape=(3, 3, 10)}.test_hfftn_backend _
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[[ 7.79958252e+02,  5.62262268e+02,  7.20955353e+01,
          1.35494995e+02, -8.87500153e+01,  9.28420334e+01..., -2.22661572e+01,  7.20881348e+01,
          4.12633820e+01, -4.14133606e+01,  7.91212988e+00]]],
      dtype=float32)
desired = array([[[ 7.79958313e+02,  5.62262207e+02,  7.20955429e+01,
          1.35495010e+02, -8.87500305e+01,  9.28419800e+01..., -2.22661552e+01,  7.20881348e+01,
          4.12633858e+01, -4.14133606e+01,  7.91212845e+00]]],
      dtype=float32)
rtol = 0.0004, atol = 1e-07, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.0004, atol=1e-07
E       
E       Mismatched elements: 1 / 162 (0.617%)
E       Max absolute difference: 8.022785e-05
E       Max relative difference: 0.00053083
E        x: array([[[ 7.799583e+02,  5.622623e+02,  7.209554e+01,  1.354950e+02,
E                -8.875002e+01,  9.284203e+01, -1.996969e+01,  8.982819e+01,
E                 4.771265e+00,  3.475858e+01, -4.139374e+01,  1.398418e+00,...
E        y: array([[[ 7.799583e+02,  5.622622e+02,  7.209554e+01,  1.354950e+02,
E                -8.875003e+01,  9.284198e+01, -1.996969e+01,  8.982815e+01,
E                 4.771230e+00,  3.475859e+01, -4.139378e+01,  1.398499e+00,...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
_ TestHfftn_param_22_{axes=None, norm='ortho', s=None, shape=(3, 3, 10)}.test_hfftn _
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[[ 6.12793121e+01,  4.41754951e+01,  5.66436195e+00,
          1.06454935e+01, -6.97286129e+00,  7.29435587e+00..., -1.74939454e+00,  5.66378021e+00,
          3.24195814e+00, -3.25374198e+00,  6.21635795e-01]]],
      dtype=float32)
desired = array([[[ 6.12793159e+01,  4.41754913e+01,  5.66436100e+00,
          1.06454935e+01, -6.97286129e+00,  7.29435492e+00..., -1.74939442e+00,  5.66377878e+00,
          3.24195790e+00, -3.25374103e+00,  6.21635556e-01]]],
      dtype=float32)
rtol = 0.0004, atol = 1e-07, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.0004, atol=1e-07
E       
E       Mismatched elements: 1 / 162 (0.617%)
E       Max absolute difference: 4.000962e-06
E       Max relative difference: 0.00117883
E        x: array([[[ 6.127931e+01,  4.417550e+01,  5.664362e+00,  1.064549e+01,
E                -6.972861e+00,  7.294356e+00, -1.568968e+00,  7.057568e+00,
E                 3.748631e-01,  2.730891e+00, -3.252204e+00,  1.098724e-01,...
E        y: array([[[ 6.127932e+01,  4.417549e+01,  5.664361e+00,  1.064549e+01,
E                -6.972861e+00,  7.294355e+00, -1.568967e+00,  7.057566e+00,
E                 3.748632e-01,  2.730893e+00, -3.252203e+00,  1.098764e-01,...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
_ TestHfftn_param_22_{axes=None, norm='ortho', s=None, shape=(3, 3, 10)}.test_hfftn_backend _
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[[ 6.12793121e+01,  4.41754951e+01,  5.66436195e+00,
          1.06454935e+01, -6.97286129e+00,  7.29435587e+00..., -1.74939454e+00,  5.66378021e+00,
          3.24195814e+00, -3.25374198e+00,  6.21635795e-01]]],
      dtype=float32)
desired = array([[[ 6.12793159e+01,  4.41754913e+01,  5.66436100e+00,
          1.06454935e+01, -6.97286129e+00,  7.29435492e+00..., -1.74939442e+00,  5.66377878e+00,
          3.24195790e+00, -3.25374103e+00,  6.21635556e-01]]],
      dtype=float32)
rtol = 0.0004, atol = 1e-07, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.0004, atol=1e-07
E       
E       Mismatched elements: 1 / 162 (0.617%)
E       Max absolute difference: 4.000962e-06
E       Max relative difference: 0.00117883
E        x: array([[[ 6.127931e+01,  4.417550e+01,  5.664362e+00,  1.064549e+01,
E                -6.972861e+00,  7.294356e+00, -1.568968e+00,  7.057568e+00,
E                 3.748631e-01,  2.730891e+00, -3.252204e+00,  1.098724e-01,...
E        y: array([[[ 6.127932e+01,  4.417549e+01,  5.664361e+00,  1.064549e+01,
E                -6.972861e+00,  7.294355e+00, -1.568967e+00,  7.057566e+00,
E                 3.748632e-01,  2.730893e+00, -3.252203e+00,  1.098764e-01,...

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.complex64'>
______ TestLUSolve_param_2_{shapes=((4, 4), (4,)), trans=2}.test_lu_solve ______

self = <<cupyx_tests.scipy_tests.linalg_tests.test_decomp_lu.TestLUSolve_param_2_{shapes=((4, 4), (4,)), trans=2} testMethod=test_lu_solve>  parameter: {'shapes': ((4, 4), (4,)), 'trans': 2}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupy/__init__.py'>
scp = <module 'cupyx.scipy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupyx/scipy/__init__.py'>
dtype = <class 'numpy.float32'>

    @testing.for_dtypes('fdFD')
    @testing.numpy_cupy_allclose(atol=1e-5, scipy_name='scp')
    def test_lu_solve(self, xp, scp, dtype):
        a_shape, b_shape = self.shapes
        A = testing.shaped_random(a_shape, xp, dtype=dtype)
        b = testing.shaped_random(b_shape, xp, dtype=dtype)
        lu = scp.linalg.lu_factor(A)
>       return scp.linalg.lu_solve(lu, b, trans=self.trans)

tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lu_and_piv = (array([[ 9.636627  ,  3.8344152 ,  7.91725   ,  5.288949  ],
       [ 0.58946407,  6.995716  , -3.956574  , -2.246352...,
       [ 0.43962973,  0.6823059 ,  0.83048815,  4.776696  ]],
      dtype=float32), array([2, 3, 2, 3], dtype=int32))
b = array([ 1.0000000e+00,  0.0000000e+00, -3.5134796e-08,  5.9604645e-08],
      dtype=float32)
trans = 2, overwrite_b = False, check_finite = True

    def lu_solve(lu_and_piv, b, trans=0, overwrite_b=False, check_finite=True):
        """Solve an equation system, ``a * x = b``, given the LU factorization of ``a``
    
        Args:
            lu_and_piv (tuple): LU factorization of matrix ``a`` (``(M, M)``)
                together with pivot indices.
            b (cupy.ndarray): The matrix with dimension ``(M,)`` or
                ``(M, N)``.
            trans ({0, 1, 2}): Type of system to solve:
    
                ========  =========
                trans     system
                ========  =========
                0         a x  = b
                1         a^T x = b
                2         a^H x = b
                ========  =========
            overwrite_b (bool): Allow overwriting data in b (may enhance
                performance)
            check_finite (bool): Whether to check that the input matrices contain
                only finite numbers. Disabling may give a performance gain, but may
                result in problems (crashes, non-termination) if the inputs do
                contain infinities or NaNs.
    
        Returns:
            cupy.ndarray:
                The matrix with dimension ``(M,)`` or ``(M, N)``.
    
        .. seealso:: :func:`scipy.linalg.lu_solve`
        """
    
        (lu, ipiv) = lu_and_piv
    
        _util._assert_cupy_array(lu)
        _util._assert_rank2(lu)
        _util._assert_nd_squareness(lu)
    
        m = lu.shape[0]
        if m != b.shape[0]:
            raise ValueError('incompatible dimensions.')
    
        dtype = lu.dtype
        if dtype.char == 'f':
            getrs = cusolver.sgetrs
        elif dtype.char == 'd':
            getrs = cusolver.dgetrs
        elif dtype.char == 'F':
            getrs = cusolver.cgetrs
        elif dtype.char == 'D':
            getrs = cusolver.zgetrs
        else:
            msg = 'Only float32, float64, complex64 and complex128 are supported.'
            raise NotImplementedError(msg)
    
        if trans == 0:
            trans = cublas.CUBLAS_OP_N
        elif trans == 1:
            trans = cublas.CUBLAS_OP_T
        elif trans == 2:
            trans = cublas.CUBLAS_OP_C
        else:
            raise ValueError('unknown trans')
    
        lu = lu.astype(dtype, order='F', copy=False)
        ipiv = ipiv.astype(ipiv.dtype, order='F', copy=True)
        # cuSolver uses 1-origin while SciPy uses 0-origin
        ipiv += 1
        b = b.astype(dtype, order='F', copy=(not overwrite_b))
    
        if check_finite:
            if lu.dtype.kind == 'f' and not cupy.isfinite(lu).all():
                raise ValueError(
                    'array must not contain infs or NaNs.\n'
                    'Note that when a singular matrix is given, unlike '
                    'scipy.linalg.lu_factor, cupyx.scipy.linalg.lu_factor '
                    'returns an array containing NaN.')
            if b.dtype.kind == 'f' and not cupy.isfinite(b).all():
                raise ValueError(
                    'array must not contain infs or NaNs')
    
        n = 1 if b.ndim == 1 else b.shape[1]
        cusolver_handle = device.get_cusolver_handle()
        dev_info = cupy.empty(1, dtype=numpy.int32)
    
        # solve for the inverse
        getrs(cusolver_handle,
              trans,
              m, n, lu.data.ptr, m, ipiv.data.ptr, b.data.ptr,
              m, dev_info.data.ptr)
    
        if dev_info[0] < 0:
>           raise ValueError('illegal value in %d-th argument of '
                             'internal getrs (lu_solve)' % -dev_info[0])
E           AssertionError: Only cupy raises error
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupy/testing/_helper.py", line 47, in _call_func
E               result = impl(self, *args, **kw)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py", line 133, in test_lu_solve
E               return scp.linalg.lu_solve(lu, b, trans=self.trans)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupyx/scipy/linalg/decomp_lu.py", line 344, in lu_solve
E               raise ValueError('illegal value in %d-th argument of '
E           ValueError: illegal value in 1409886463-th argument of internal getrs (lu_solve)

cupyx/scipy/linalg/decomp_lu.py:344: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is f
_____ TestLUSolve_param_4_{shapes=((5, 5), (5, 2)), trans=1}.test_lu_solve _____

self = <<cupyx_tests.scipy_tests.linalg_tests.test_decomp_lu.TestLUSolve_param_4_{shapes=((5, 5), (5, 2)), trans=1} testMethod=test_lu_solve>  parameter: {'shapes': ((5, 5), (5, 2)), 'trans': 1}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupy/__init__.py'>
scp = <module 'cupyx.scipy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupyx/scipy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_dtypes('fdFD')
    @testing.numpy_cupy_allclose(atol=1e-5, scipy_name='scp')
    def test_lu_solve(self, xp, scp, dtype):
        a_shape, b_shape = self.shapes
        A = testing.shaped_random(a_shape, xp, dtype=dtype)
        b = testing.shaped_random(b_shape, xp, dtype=dtype)
        lu = scp.linalg.lu_factor(A)
>       return scp.linalg.lu_solve(lu, b, trans=self.trans)

tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lu_and_piv = (array([[ 9.786183   +6.7063785j ,  7.9915857  +2.1038256j ,
         4.614794   +1.289263j  ,  7.8052917  +3.1542835j... , -0.1953073  +0.38294038j,
         1.4816577  +3.0051987j ]], dtype=complex64), array([4, 1, 4, 3, 4], dtype=int32))
b = array([[-0.12906703+0.8393008j , -0.45564157+0.47542247j],
       [-1.6380516 +0.2856012j , -1.3639437 -0.01759137j],
...5160456j ,  0.17068663-1.26324j   ],
       [-0.42293406-0.24016479j, -1.3451302 -0.06091486j]],
      dtype=complex64)
trans = 1, overwrite_b = False, check_finite = True

    def lu_solve(lu_and_piv, b, trans=0, overwrite_b=False, check_finite=True):
        """Solve an equation system, ``a * x = b``, given the LU factorization of ``a``
    
        Args:
            lu_and_piv (tuple): LU factorization of matrix ``a`` (``(M, M)``)
                together with pivot indices.
            b (cupy.ndarray): The matrix with dimension ``(M,)`` or
                ``(M, N)``.
            trans ({0, 1, 2}): Type of system to solve:
    
                ========  =========
                trans     system
                ========  =========
                0         a x  = b
                1         a^T x = b
                2         a^H x = b
                ========  =========
            overwrite_b (bool): Allow overwriting data in b (may enhance
                performance)
            check_finite (bool): Whether to check that the input matrices contain
                only finite numbers. Disabling may give a performance gain, but may
                result in problems (crashes, non-termination) if the inputs do
                contain infinities or NaNs.
    
        Returns:
            cupy.ndarray:
                The matrix with dimension ``(M,)`` or ``(M, N)``.
    
        .. seealso:: :func:`scipy.linalg.lu_solve`
        """
    
        (lu, ipiv) = lu_and_piv
    
        _util._assert_cupy_array(lu)
        _util._assert_rank2(lu)
        _util._assert_nd_squareness(lu)
    
        m = lu.shape[0]
        if m != b.shape[0]:
            raise ValueError('incompatible dimensions.')
    
        dtype = lu.dtype
        if dtype.char == 'f':
            getrs = cusolver.sgetrs
        elif dtype.char == 'd':
            getrs = cusolver.dgetrs
        elif dtype.char == 'F':
            getrs = cusolver.cgetrs
        elif dtype.char == 'D':
            getrs = cusolver.zgetrs
        else:
            msg = 'Only float32, float64, complex64 and complex128 are supported.'
            raise NotImplementedError(msg)
    
        if trans == 0:
            trans = cublas.CUBLAS_OP_N
        elif trans == 1:
            trans = cublas.CUBLAS_OP_T
        elif trans == 2:
            trans = cublas.CUBLAS_OP_C
        else:
            raise ValueError('unknown trans')
    
        lu = lu.astype(dtype, order='F', copy=False)
        ipiv = ipiv.astype(ipiv.dtype, order='F', copy=True)
        # cuSolver uses 1-origin while SciPy uses 0-origin
        ipiv += 1
        b = b.astype(dtype, order='F', copy=(not overwrite_b))
    
        if check_finite:
            if lu.dtype.kind == 'f' and not cupy.isfinite(lu).all():
                raise ValueError(
                    'array must not contain infs or NaNs.\n'
                    'Note that when a singular matrix is given, unlike '
                    'scipy.linalg.lu_factor, cupyx.scipy.linalg.lu_factor '
                    'returns an array containing NaN.')
            if b.dtype.kind == 'f' and not cupy.isfinite(b).all():
                raise ValueError(
                    'array must not contain infs or NaNs')
    
        n = 1 if b.ndim == 1 else b.shape[1]
        cusolver_handle = device.get_cusolver_handle()
        dev_info = cupy.empty(1, dtype=numpy.int32)
    
        # solve for the inverse
        getrs(cusolver_handle,
              trans,
              m, n, lu.data.ptr, m, ipiv.data.ptr, b.data.ptr,
              m, dev_info.data.ptr)
    
        if dev_info[0] < 0:
>           raise ValueError('illegal value in %d-th argument of '
                             'internal getrs (lu_solve)' % -dev_info[0])
E           AssertionError: Only cupy raises error
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupy/testing/_helper.py", line 47, in _call_func
E               result = impl(self, *args, **kw)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py", line 133, in test_lu_solve
E               return scp.linalg.lu_solve(lu, b, trans=self.trans)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupyx/scipy/linalg/decomp_lu.py", line 344, in lu_solve
E               raise ValueError('illegal value in %d-th argument of '
E           ValueError: illegal value in 1857101312-th argument of internal getrs (lu_solve)

cupyx/scipy/linalg/decomp_lu.py:344: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is F
_____ TestLUSolve_param_5_{shapes=((5, 5), (5, 2)), trans=2}.test_lu_solve _____

self = <<cupyx_tests.scipy_tests.linalg_tests.test_decomp_lu.TestLUSolve_param_5_{shapes=((5, 5), (5, 2)), trans=2} testMethod=test_lu_solve>  parameter: {'shapes': ((5, 5), (5, 2)), 'trans': 2}>
xp = <module 'cupy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupy/__init__.py'>
scp = <module 'cupyx.scipy' from '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupyx/scipy/__init__.py'>
dtype = <class 'numpy.complex64'>

    @testing.for_dtypes('fdFD')
    @testing.numpy_cupy_allclose(atol=1e-5, scipy_name='scp')
    def test_lu_solve(self, xp, scp, dtype):
        a_shape, b_shape = self.shapes
        A = testing.shaped_random(a_shape, xp, dtype=dtype)
        b = testing.shaped_random(b_shape, xp, dtype=dtype)
        lu = scp.linalg.lu_factor(A)
>       return scp.linalg.lu_solve(lu, b, trans=self.trans)

tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

lu_and_piv = (array([[ 9.786183   +6.7063785j ,  7.9915857  +2.1038256j ,
         4.614794   +1.289263j  ,  7.8052917  +3.1542835j... , -0.1953073  +0.38294038j,
         1.4816577  +3.0051987j ]], dtype=complex64), array([4, 1, 4, 3, 4], dtype=int32))
b = array([[ 1.3340688 +0.14706898j,  0.63873684+0.93013066j],
       [-0.01678652-1.9822359j ,  2.2719014 -0.60252565j],
...5935101j , -0.64952487-1.6660173j ],
       [-1.6877674 -1.4271243j ,  2.1959105 -0.78355485j]],
      dtype=complex64)
trans = 2, overwrite_b = False, check_finite = True

    def lu_solve(lu_and_piv, b, trans=0, overwrite_b=False, check_finite=True):
        """Solve an equation system, ``a * x = b``, given the LU factorization of ``a``
    
        Args:
            lu_and_piv (tuple): LU factorization of matrix ``a`` (``(M, M)``)
                together with pivot indices.
            b (cupy.ndarray): The matrix with dimension ``(M,)`` or
                ``(M, N)``.
            trans ({0, 1, 2}): Type of system to solve:
    
                ========  =========
                trans     system
                ========  =========
                0         a x  = b
                1         a^T x = b
                2         a^H x = b
                ========  =========
            overwrite_b (bool): Allow overwriting data in b (may enhance
                performance)
            check_finite (bool): Whether to check that the input matrices contain
                only finite numbers. Disabling may give a performance gain, but may
                result in problems (crashes, non-termination) if the inputs do
                contain infinities or NaNs.
    
        Returns:
            cupy.ndarray:
                The matrix with dimension ``(M,)`` or ``(M, N)``.
    
        .. seealso:: :func:`scipy.linalg.lu_solve`
        """
    
        (lu, ipiv) = lu_and_piv
    
        _util._assert_cupy_array(lu)
        _util._assert_rank2(lu)
        _util._assert_nd_squareness(lu)
    
        m = lu.shape[0]
        if m != b.shape[0]:
            raise ValueError('incompatible dimensions.')
    
        dtype = lu.dtype
        if dtype.char == 'f':
            getrs = cusolver.sgetrs
        elif dtype.char == 'd':
            getrs = cusolver.dgetrs
        elif dtype.char == 'F':
            getrs = cusolver.cgetrs
        elif dtype.char == 'D':
            getrs = cusolver.zgetrs
        else:
            msg = 'Only float32, float64, complex64 and complex128 are supported.'
            raise NotImplementedError(msg)
    
        if trans == 0:
            trans = cublas.CUBLAS_OP_N
        elif trans == 1:
            trans = cublas.CUBLAS_OP_T
        elif trans == 2:
            trans = cublas.CUBLAS_OP_C
        else:
            raise ValueError('unknown trans')
    
        lu = lu.astype(dtype, order='F', copy=False)
        ipiv = ipiv.astype(ipiv.dtype, order='F', copy=True)
        # cuSolver uses 1-origin while SciPy uses 0-origin
        ipiv += 1
        b = b.astype(dtype, order='F', copy=(not overwrite_b))
    
        if check_finite:
            if lu.dtype.kind == 'f' and not cupy.isfinite(lu).all():
                raise ValueError(
                    'array must not contain infs or NaNs.\n'
                    'Note that when a singular matrix is given, unlike '
                    'scipy.linalg.lu_factor, cupyx.scipy.linalg.lu_factor '
                    'returns an array containing NaN.')
            if b.dtype.kind == 'f' and not cupy.isfinite(b).all():
                raise ValueError(
                    'array must not contain infs or NaNs')
    
        n = 1 if b.ndim == 1 else b.shape[1]
        cusolver_handle = device.get_cusolver_handle()
        dev_info = cupy.empty(1, dtype=numpy.int32)
    
        # solve for the inverse
        getrs(cusolver_handle,
              trans,
              m, n, lu.data.ptr, m, ipiv.data.ptr, b.data.ptr,
              m, dev_info.data.ptr)
    
        if dev_info[0] < 0:
>           raise ValueError('illegal value in %d-th argument of '
                             'internal getrs (lu_solve)' % -dev_info[0])
E           AssertionError: Only cupy raises error
E           
E           Traceback (most recent call last):
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupy/testing/_helper.py", line 47, in _call_func
E               result = impl(self, *args, **kw)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py", line 133, in test_lu_solve
E               return scp.linalg.lu_solve(lu, b, trans=self.trans)
E             File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/cupyx/scipy/linalg/decomp_lu.py", line 344, in lu_solve
E               raise ValueError('illegal value in %d-th argument of '
E           ValueError: illegal value in 1857101197-th argument of internal getrs (lu_solve)

cupyx/scipy/linalg/decomp_lu.py:344: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is F
_ TestGenericFilter.test_filter[_param_156_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f475947a310>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f4863043940>}>
args = (), kw = {}
cupy_result = (array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[28, 38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]],...38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8))]
cupy_r = array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]], dtype=uint8)
numpy_r = array([[28, 38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[21, 31, 40, 31, 33],
       [27, 29, 28, 20, 27],
       [14, 25, 35, 34, 32],
       [27, 26, 33, 25, 31]], dtype=uint8)
desired = array([[28, 38, 48, 42, 45],
       [32, 36, 44, 37, 44],
       [18, 31, 45, 48, 55],
       [22, 29, 41, 43, 54]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 253
E       Max relative difference: 14.
E        x: array([[21, 31, 40, 31, 33],
E              [27, 29, 28, 20, 27],
E              [14, 25, 35, 34, 32],
E              [27, 26, 33, 25, 31]], dtype=uint8)
E        y: array([[28, 38, 48, 42, 45],
E              [32, 36, 44, 37, 44],
E              [18, 31, 45, 48, 55],
E              [22, 29, 41, 43, 54]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_158_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f475905c910>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f4863043940>}>
args = (), kw = {}
cupy_result = (array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[34, 34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]],...34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8))]
cupy_r = array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
numpy_r = array([[34, 34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[28, 24, 32, 32, 39],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
desired = array([[34, 34, 44, 37, 47],
       [34, 34, 44, 37, 47],
       [29, 29, 39, 37, 46],
       [27, 27, 41, 38, 52]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 251
E       Max relative difference: 8.48148148
E        x: array([[28, 24, 32, 32, 39],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0]], dtype=uint8)
E        y: array([[34, 34, 44, 37, 47],
E              [34, 34, 44, 37, 47],
E              [29, 29, 39, 37, 46],
E              [27, 27, 41, 38, 52]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_160_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f4759488af0>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f4863043940>}>
args = (), kw = {}
cupy_result = (array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.011765...2, 44.03386405, 43.67148673, 48.63067102],
       [32.28830047, 30.15609296, 36.65741325, 35.73179981, 40.69098504]]),)
cupy_error = None
numpy_result = (array([[32.49418447, 44.26508328, 55.58324819, 50.90632842, 53.13241351],
       [36.78467189, 42.32410703, 50.513759...4, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.01176...4, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]]))]
cupy_r = array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.0117654...672, 44.03386405, 43.67148673, 48.63067102],
       [32.28830047, 30.15609296, 36.65741325, 35.73179981, 40.69098504]])
numpy_r = array([[32.49418447, 44.26508328, 55.58324819, 50.90632842, 53.13241351],
       [36.78467189, 42.32410703, 50.5137596...954, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[30.36659675, 39.62975648, 53.45565341, 42.0701155 , 42.81412414],
       [33.36838531, 37.73390254, 33.0117654...672, 44.03386405, 43.67148673, 48.63067102],
       [32.28830047, 30.15609296, 36.65741325, 35.73179981, 40.69098504]])
desired = array([[32.49418447, 44.26508328, 55.58324819, 50.90632842, 53.13241351],
       [36.78467189, 42.32410703, 50.5137596...954, 51.93015205, 56.78985728, 63.23111802],
       [26.45539443, 35.1080233 , 46.86066347, 49.16227375, 60.05539763]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 19.36441258
E       Max relative difference: 0.34647974
E        x: array([[30.366597, 39.629756, 53.455653, 42.070115, 42.814124],
E              [33.368385, 37.733903, 33.011765, 32.58301 , 39.999025],
E              [18.994361, 35.440507, 44.033864, 43.671487, 48.630671],
E              [32.2883  , 30.156093, 36.657413, 35.7318  , 40.690985]])
E        y: array([[32.494184, 44.265083, 55.583248, 50.906328, 53.132414],
E              [36.784672, 42.324107, 50.51376 , 43.278745, 49.956693],
E              [22.164907, 37.049   , 51.930152, 56.789857, 63.231118],
E              [26.455394, 35.108023, 46.860663, 49.162274, 60.055398]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_162_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f475905c370>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f4863043940>}>
args = (), kw = {}
cupy_result = (array([[29.110215  , 29.71338479, 34.67394898, 25.1796024 , 31.7265699 ],
       [ 0.        ,  0.        ,  0.      ... ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]]),)
cupy_error = None
numpy_result = (array([[39.92050807, 39.92050807, 51.40005714, 43.376314  , 54.85586307],
       [39.92050807, 39.92050807, 51.400057...2, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[29.110215  , 29.71338479, 34.67394898, 25.1796024 , 31.7265699 ],
       [ 0.        ,  0.        ,  0.     ...2, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]]))]
cupy_r = array([[29.110215  , 29.71338479, 34.67394898, 25.1796024 , 31.7265699 ],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
numpy_r = array([[39.92050807, 39.92050807, 51.40005714, 43.376314  , 54.85586307],
       [39.92050807, 39.92050807, 51.4000571...222, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[29.110215  , 29.71338479, 34.67394898, 25.1796024 , 31.7265699 ],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
desired = array([[39.92050807, 39.92050807, 51.40005714, 43.376314  , 54.85586307],
       [39.92050807, 39.92050807, 51.4000571...222, 44.98891502, 43.33693082, 53.99120362],
       [33.21871236, 33.21871236, 48.82046921, 44.04305038, 59.64480722]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 59.64480722
E       Max relative difference: 1.
E        x: array([[29.110215, 29.713385, 34.673949, 25.179602, 31.72657 ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ]])
E        y: array([[39.920508, 39.920508, 51.400057, 43.376314, 54.855863],
E              [39.920508, 39.920508, 51.400057, 43.376314, 54.855863],
E              [34.334642, 34.334642, 44.988915, 43.336931, 53.991204],
E              [33.218712, 33.218712, 48.820469, 44.04305 , 59.644807]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_324_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core._reduction.ReductionKernel object a...1c16f60>, <function lt_pyfunc at 0x7f4861ce2280>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f4758dc8700>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7f4861ce2280>}>
args = (), kw = {}
cupy_result = (array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]]),)
cupy_error = None
numpy_result = (array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]]), array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]]))]
cupy_r = array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]])
numpy_r = array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[4., 6., 3., 4., 3.],
       [5., 7., 7., 5., 3.],
       [6., 5., 4., 3., 2.],
       [5., 7., 6., 4., 3.]])
desired = array([[4., 6., 3., 3., 2.],
       [5., 0., 6., 8., 1.],
       [8., 3., 3., 7., 0.],
       [2., 0., 6., 4., 4.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 14 / 20 (70%)
E       Max absolute difference: 7.
E       Max relative difference: 2.
E        x: array([[4., 6., 3., 4., 3.],
E              [5., 7., 7., 5., 3.],
E              [6., 5., 4., 3., 2.],
E              [5., 7., 6., 4., 3.]])
E        y: array([[4., 6., 3., 3., 2.],
E              [5., 0., 6., 8., 1.],
E              [8., 3., 3., 7., 0.],
E              [2., 0., 6., 4., 4.]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_326_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core._reduction.ReductionKernel object a...1c16f60>, <function lt_pyfunc at 0x7f4861ce2280>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f4758dd75e0>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7f4861ce2280>}>
args = (), kw = {}
cupy_result = (array([[15.,  5., 13.,  6., 10.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]]),)
cupy_error = None
numpy_result = (array([[ 8., 11.,  4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[15.,  5., 13.,  6., 10.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  ...4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]]))]
cupy_r = array([[15.,  5., 13.,  6., 10.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
numpy_r = array([[ 8., 11.,  4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[15.,  5., 13.,  6., 10.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
desired = array([[ 8., 11.,  4., 10.,  7.],
       [14.,  0.,  7.,  4.,  8.],
       [ 8.,  5., 11.,  5.,  5.],
       [14.,  0.,  1.,  0.,  7.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 17 / 20 (85%)
E       Max absolute difference: 14.
E       Max relative difference: 2.25
E        x: array([[15.,  5., 13.,  6., 10.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.]])
E        y: array([[ 8., 11.,  4., 10.,  7.],
E              [14.,  0.,  7.,  4.,  8.],
E              [ 8.,  5., 11.,  5.,  5.],
E              [14.,  0.,  1.,  0.,  7.]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_484_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f475853c1c0>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f4863043940>}>
args = (), kw = {}
cupy_result = (array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[31, 36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]],...36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8))]
cupy_r = array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]], dtype=uint8)
numpy_r = array([[31, 36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[21, 28, 45, 28, 29],
       [28, 24, 27, 19, 21],
       [14, 25, 40, 31, 32],
       [28, 19, 33, 25, 26]], dtype=uint8)
desired = array([[31, 36, 54, 42, 44],
       [32, 37, 44, 33, 44],
       [16, 36, 54, 41, 63],
       [24, 30, 40, 45, 48]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 254
E       Max relative difference: 15.875
E        x: array([[21, 28, 45, 28, 29],
E              [28, 24, 27, 19, 21],
E              [14, 25, 40, 31, 32],
E              [28, 19, 33, 25, 26]], dtype=uint8)
E        y: array([[31, 36, 54, 42, 44],
E              [32, 37, 44, 33, 44],
E              [16, 36, 54, 41, 63],
E              [24, 30, 40, 45, 48]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_486_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f4757cfb9a0>  parameter: {'filter'...ss 'numpy.uint8'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f4863043940>}>
args = (), kw = {}
cupy_result = (array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8),)
cupy_error = None
numpy_result = (array([[31, 37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]],...37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8))]
cupy_r = array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
numpy_r = array([[31, 37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8)
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[23, 27, 36, 28, 53],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]], dtype=uint8)
desired = array([[31, 37, 37, 34, 51],
       [36, 33, 47, 34, 49],
       [32, 30, 35, 33, 43],
       [26, 31, 44, 32, 61]], dtype=uint8)
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 255
E       Max relative difference: 8.84615385
E        x: array([[23, 27, 36, 28, 53],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0],
E              [ 0,  0,  0,  0,  0]], dtype=uint8)
E        y: array([[31, 37, 37, 34, 51],
E              [36, 33, 47, 34, 49],
E              [32, 30, 35, 33, 43],
E              [26, 31, 44, 32, 61]], dtype=uint8)

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_488_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f4758cc8910>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f4863043940>}>
args = (), kw = {}
cupy_result = (array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.257219...9, 51.41878991, 42.0040045 , 51.31070106],
       [33.21458492, 22.51034287, 37.94448098, 37.08985252, 37.51394469]]),)
cupy_error = None
numpy_result = (array([[34.73996818, 43.64546371, 63.5383726 , 49.84875414, 52.48268444],
       [37.33873469, 42.72655042, 49.589277...5, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.25721...5, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]]))]
cupy_r = array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.2572195...229, 51.41878991, 42.0040045 , 51.31070106],
       [33.21458492, 22.51034287, 37.94448098, 37.08985252, 37.51394469]])
numpy_r = array([[34.73996818, 43.64546371, 63.5383726 , 49.84875414, 52.48268444],
       [37.33873469, 42.72655042, 49.5892777...725, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[32.00449826, 37.68575782, 60.8028936 , 38.48790895, 39.21631239],
       [34.60326543, 32.2532409 , 33.2572195...229, 51.41878991, 42.0040045 , 51.31070106],
       [33.21458492, 22.51034287, 37.94448098, 37.08985252, 37.51394469]])
desired = array([[34.73996818, 43.64546371, 63.5383726 , 49.84875414, 52.48268444],
       [37.33873469, 42.72655042, 49.5892777...725, 62.15186111, 50.87288873, 72.5746653 ],
       [29.90948782, 36.17835396, 46.34962956, 49.94860122, 54.16193588]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 21.26396424
E       Max relative difference: 0.37779527
E        x: array([[32.004498, 37.685758, 60.802894, 38.487909, 39.216312],
E              [34.603265, 32.253241, 33.25722 , 33.041408, 36.624282],
E              [20.112677, 38.150832, 51.41879 , 42.004005, 51.310701],
E              [33.214585, 22.510343, 37.944481, 37.089853, 37.513945]])
E        y: array([[34.739968, 43.645464, 63.538373, 49.848754, 52.482684],
E              [37.338735, 42.72655 , 49.589278, 37.768093, 49.890655],
E              [19.537204, 43.529837, 62.151861, 50.872889, 72.574665],
E              [29.909488, 36.178354, 46.34963 , 49.948601, 54.161936]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_490_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f4757cfbf70>  parameter: {'filter'... 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function rms_pyfunc at 0x7f4863043940>}>
args = (), kw = {}
cupy_result = (array([[24.21149428, 29.80534893, 37.32798429, 32.88328106, 46.48912698],
       [ 0.        ,  0.        ,  0.      ... ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]]),)
cupy_error = None
numpy_result = (array([[36.86077635, 42.87616583, 43.41972747, 39.82804323, 58.74618737],
       [42.04291274, 39.49732697, 56.260026...8, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[24.21149428, 29.80534893, 37.32798429, 32.88328106, 46.48912698],
       [ 0.        ,  0.        ,  0.     ...8, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]]))]
cupy_r = array([[24.21149428, 29.80534893, 37.32798429, 32.88328106, 46.48912698],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
numpy_r = array([[36.86077635, 42.87616583, 43.41972747, 39.82804323, 58.74618737],
       [42.04291274, 39.49732697, 56.2600260...358, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[24.21149428, 29.80534893, 37.32798429, 32.88328106, 46.48912698],
       [ 0.        ,  0.        ,  0.       ...   ,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ]])
desired = array([[36.86077635, 42.87616583, 43.41972747, 39.82804323, 58.74618737],
       [42.04291274, 39.49732697, 56.2600260...358, 40.06613219, 37.53324325, 49.79207175],
       [31.44112421, 37.6867121 , 51.65417609, 39.59452747, 70.43768385]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 20 / 20 (100%)
E       Max absolute difference: 70.43768385
E       Max relative difference: 1.
E        x: array([[24.211494, 29.805349, 37.327984, 32.883281, 46.489127],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
E              [ 0.      ,  0.      ,  0.      ,  0.      ,  0.      ]])
E        y: array([[36.860776, 42.876166, 43.419727, 39.828043, 58.746187],
E              [42.042913, 39.497327, 56.260026, 40.67984 , 58.57918 ],
E              [36.303403, 34.455314, 40.066132, 37.533243, 49.792072],
E              [31.441124, 37.686712, 51.654176, 39.594527, 70.437684]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_652_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core._reduction.ReductionKernel object a...1c16f60>, <function lt_pyfunc at 0x7f4861ce2280>), ksize=3, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f4757d18550>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 3, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7f4861ce2280>}>
args = (), kw = {}
cupy_result = (array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]]),)
cupy_error = None
numpy_result = (array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]]), array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]]))]
cupy_r = array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]])
numpy_r = array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[5., 3., 2., 4., 3.],
       [1., 5., 1., 5., 6.],
       [4., 4., 1., 3., 5.],
       [1., 1., 1., 4., 4.]])
desired = array([[5., 2., 2., 3., 2.],
       [0., 4., 0., 5., 5.],
       [4., 4., 1., 2., 3.],
       [0., 0., 0., 3., 2.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 14 / 20 (70%)
E       Max absolute difference: 2.
E       Max relative difference: 1.
E        x: array([[5., 3., 2., 4., 3.],
E              [1., 5., 1., 5., 6.],
E              [4., 4., 1., 3., 5.],
E              [1., 1., 1., 4., 4.]])
E        y: array([[5., 2., 2., 3., 2.],
E              [0., 4., 0., 5., 5.],
E              [4., 4., 1., 2., 3.],
E              [0., 0., 0., 3., 2.]])

cupy/testing/_array.py:24: AssertionError
_ TestGenericFilter.test_filter[_param_654_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core._reduction.ReductionKernel object a...1c16f60>, <function lt_pyfunc at 0x7f4861ce2280>), ksize=4, mode='mirror', shape=(4, 5)}] _

self = <<cupyx_tests.scipy_tests.ndimage_tests.test_filters.TestGenericFilter object at 0x7f475747d160>  parameter: {'filter'...s 'numpy.float64'>, 'ksize': 4, 'mode': 'mirror', 'shape': (4, 5), 'function': <function lt_pyfunc at 0x7f4861ce2280>}>
args = (), kw = {}
cupy_result = (array([[ 5., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]]),)
cupy_error = None
numpy_result = (array([[ 0., 10., 10.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]]),)
numpy_error = None
cupy_numpy_result_ndarrays = [(array([[ 5., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  ...0.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]]))]
cupy_r = array([[ 5., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
numpy_r = array([[ 0., 10., 10.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]])
skip = False

            @_wraps_partial_xp(impl, name, sp_name, scipy_name)
            def test_func(self, *args, **kw):
                # Run cupy and numpy
                (
                    cupy_result, cupy_error,
                    numpy_result, numpy_error) = (
                        _call_func_numpy_cupy(
                            self, impl, args, kw, name, sp_name, scipy_name))
                assert cupy_result is not None or cupy_error is not None
                assert numpy_result is not None or numpy_error is not None
    
                # Check errors raised
                if cupy_error or numpy_error:
                    _check_cupy_numpy_error(cupy_error,
                                            numpy_error,
                                            accept_error=accept_error)
                    return
    
                # Check returned arrays
    
                if not isinstance(cupy_result, (tuple, list)):
                    cupy_result = cupy_result,
                if not isinstance(numpy_result, (tuple, list)):
                    numpy_result = numpy_result,
    
                assert len(cupy_result) == len(numpy_result)
    
                # Check types
                cupy_numpy_result_ndarrays = [
                    _convert_output_to_ndarray(
                        cupy_r, numpy_r, sp_name, check_sparse_format)
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result)]
    
                # Check dtypes
                if type_check:
                    for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                        if cupy_r.dtype != numpy_r.dtype:
                            raise AssertionError(
                                '''ndarrays of different dtypes are returned.
    cupy: {}
    numpy: {}'''.format(cupy_r.dtype, numpy_r.dtype))
    
                # Check contiguities
                if contiguous_check:
                    for cupy_r, numpy_r in zip(cupy_result, numpy_result):
                        if isinstance(numpy_r, numpy.ndarray):
                            if (numpy_r.flags.c_contiguous
                                    and not cupy_r.flags.c_contiguous):
                                raise AssertionError(
                                    'The state of c_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.c_contiguous,
                                        numpy_r.flags.c_contiguous))
                            if (numpy_r.flags.f_contiguous
                                    and not cupy_r.flags.f_contiguous):
                                raise AssertionError(
                                    'The state of f_contiguous flag is false. '
                                    '(cupy_result:{} numpy_result:{})'.format(
                                        cupy_r.flags.f_contiguous,
                                        numpy_r.flags.f_contiguous))
    
                # Check shapes
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    assert cupy_r.shape == numpy_r.shape
    
                # Check item values
                for cupy_r, numpy_r in cupy_numpy_result_ndarrays:
                    # Behavior of assigning a negative value to an unsigned integer
                    # variable is undefined.
                    # nVidia GPUs and Intel CPUs behave differently.
                    # To avoid this difference, we need to ignore dimensions whose
                    # values are negative.
    
                    skip = False
                    if (_contains_signed_and_unsigned(kw)
                            and cupy_r.dtype in _unsigned_dtypes):
                        mask = _make_positive_mask(
                            self, impl, args, kw, name, sp_name, scipy_name)
                        if cupy_r.shape == ():
                            skip = (mask == 0).all()
                        else:
                            cupy_r = cupy_r[mask].get()
                            numpy_r = numpy_r[mask]
    
                    if not skip:
>                       check_func(cupy_r, numpy_r)

cupy/testing/_helper.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[ 5., 10., 10.,  3.,  9.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
desired = array([[ 0., 10., 10.,  1.,  8.],
       [ 7.,  6.,  2.,  2.,  2.],
       [ 1., 10., 10.,  2.,  9.],
       [ 4.,  5.,  9.,  1.,  6.]])
rtol = 1e-05, atol = 1e-05, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=1e-05, atol=1e-05
E       
E       Mismatched elements: 18 / 20 (90%)
E       Max absolute difference: 10.
E       Max relative difference: 2.
E        x: array([[ 5., 10., 10.,  3.,  9.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.],
E              [ 0.,  0.,  0.,  0.,  0.]])
E        y: array([[ 0., 10., 10.,  1.,  8.],
E              [ 7.,  6.,  2.,  2.,  2.],
E              [ 1., 10., 10.,  2.,  9.],
E              [ 4.,  5.,  9.,  1.,  6.]])

cupy/testing/_array.py:24: AssertionError
_ TestFFTConvolve_param_44_{mode='valid', size1=(3, 4, 10), size2=3}.test_correlate_fft _
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[[1836.3824  , 1981.7997  , 1112.9481  ,  861.6453  ,
         1575.4672  ,  823.7325  , 1739.3561  ,  615.5848....2325  ,  880.2326  ,  941.1824  ,
          -36.487854, 1309.2075  , 2305.796   ,  420.20593 ]]],
      dtype=float32)
desired = array([[[769.3882 , 870.2518 , 690.45746, 663.33234, 616.8311 ,
         616.80804, 813.8273 , 745.6074 ],
        [869.8811 , 916.32166, 682.1935 , 597.21564, 541.7311 ,
         733.96045, 800.44995, 863.62555]]], dtype=float32)
rtol = 0.001, atol = 0.001, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.001, atol=0.001
E       
E       Mismatched elements: 16 / 16 (100%)
E       Max absolute difference: 1505.346
E       Max relative difference: 1.8806247
E        x: array([[[1836.3824  , 1981.7997  , 1112.9481  ,  861.6453  ,
E                1575.4672  ,  823.7325  , 1739.3561  ,  615.5848  ],
E               [ 519.9864  , 1004.2325  ,  880.2326  ,  941.1824  ,...
E        y: array([[[769.3882 , 870.2518 , 690.45746, 663.33234, 616.8311 ,
E                616.80804, 813.8273 , 745.6074 ],
E               [869.8811 , 916.32166, 682.1935 , 597.21564, 541.7311 ,
E                733.96045, 800.44995, 863.62555]]], dtype=float32)

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float32'>
_ TestFFTConvolve_param_44_{mode='valid', size1=(3, 4, 10), size2=3}.test_fftconvolve _
cupy/testing/_helper.py:825: in test_func
    impl(self, *args, **kw)
cupy/testing/_helper.py:343: in test_func
    check_func(cupy_r, numpy_r)
cupy/testing/_helper.py:495: in check_func
    _array.assert_allclose(c, n, rtol1, atol1, err_msg, verbose)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actual = array([[[1859.4985 , 1641.933  , -251.86272,  394.3544 , 1795.8148 ,
         1930.7524 , 1313.7769 ,  692.71796],
   ...9.51495, 1250.4918 , 1028.6729 , 1570.8129 , 1373.747  ,
         1294.2032 , 2302.3933 ,  263.9164 ]]], dtype=float32)
desired = array([[[800.5107 , 862.97485, 683.19934, 644.7456 , 573.72375,
         714.88525, 728.84973, 808.5652 ],
        [879.7415 , 920.5145 , 785.2407 , 688.98376, 587.2645 ,
         719.43756, 815.77496, 851.23706]]], dtype=float32)
rtol = 0.001, atol = 0.001, err_msg = '', verbose = True

    def assert_allclose(actual, desired, rtol=1e-7, atol=0, err_msg='',
                        verbose=True):
        """Raises an AssertionError if objects are not equal up to desired tolerance.
    
        Args:
             actual(numpy.ndarray or cupy.ndarray): The actual object to check.
             desired(numpy.ndarray or cupy.ndarray): The desired, expected object.
             rtol(float): Relative tolerance.
             atol(float): Absolute tolerance.
             err_msg(str): The error message to be printed in case of failure.
             verbose(bool): If ``True``, the conflicting
                 values are appended to the error message.
    
        .. seealso:: :func:`numpy.testing.assert_allclose`
    
        """  # NOQA
>       numpy.testing.assert_allclose(
            cupy.asnumpy(actual), cupy.asnumpy(desired),
            rtol=rtol, atol=atol, err_msg=err_msg, verbose=verbose)
E       AssertionError: 
E       Not equal to tolerance rtol=0.001, atol=0.001
E       
E       Mismatched elements: 16 / 16 (100%)
E       Max absolute difference: 1486.6184
E       Max relative difference: 2.1301036
E        x: array([[[1859.4985 , 1641.933  , -251.86272,  394.3544 , 1795.8148 ,
E                1930.7524 , 1313.7769 ,  692.71796],
E               [ 959.51495, 1250.4918 , 1028.6729 , 1570.8129 , 1373.747  ,
E                1294.2032 , 2302.3933 ,  263.9164 ]]], dtype=float32)
E        y: array([[[800.5107 , 862.97485, 683.19934, 644.7456 , 573.72375,
E                714.88525, 728.84973, 808.5652 ],
E               [879.7415 , 920.5145 , 785.2407 , 688.98376, 587.2645 ,
E                719.43756, 815.77496, 851.23706]]], dtype=float32)

cupy/testing/_array.py:24: AssertionError
----------------------------- Captured stdout call -----------------------------
dtype is <class 'numpy.float32'>
____________________ TestCustomStruct.test_builtin_vectors _____________________

self = <example_tests.test_custom_struct.TestCustomStruct testMethod=test_builtin_vectors>

    def test_builtin_vectors(self):
>       output = example_test.run_example('custom_struct/builtin_vectors.py')

tests/example_tests/test_custom_struct.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/example_tests/example_test.py:12: in run_example
    return subprocess.check_output(
/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:411: in check_output
    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/builtin_vectors.py'),)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7f47322f4f70>
stdout = b'Traceback (most recent call last):\n  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/te...e. Here we allow only arrays of size one so that users do not\nTypeError: Unsupported type <class \'numpy.ndarray\'>\n'
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/builtin_vectors.py')' returned non-zero exit status 1.

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:512: CalledProcessError
----------------------------- Captured stdout call -----------------------------
Original error message:
Traceback (most recent call last):
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/builtin_vectors.py", line 48, in <module>
    sys.exit(main())
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/builtin_vectors.py", line 40, in main
    kernel((1,), (N,), args)
  File "cupy/_core/raw.pyx", line 89, in cupy._core.raw.RawKernel.__call__
    self.kernel(
  File "cupy/cuda/function.pyx", line 201, in cupy.cuda.function.Function.__call__
    format(grid0, grid1, grid2, max_grid_size))
  File "cupy/cuda/function.pyx", line 155, in cupy.cuda.function._launch
    if itemsize == 8:
  File "cupy/cuda/function.pyx", line 123, in cupy.cuda.function._pointer
    # value. Here we allow only arrays of size one so that users do not
TypeError: Unsupported type <class 'numpy.ndarray'>

_____________________ TestCustomStruct.test_complex_struct _____________________

self = <example_tests.test_custom_struct.TestCustomStruct testMethod=test_complex_struct>

    def test_complex_struct(self):
>       output = example_test.run_example('custom_struct/complex_struct.py')

tests/example_tests/test_custom_struct.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/example_tests/example_test.py:12: in run_example
    return subprocess.check_output(
/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:411: in check_output
    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/complex_struct.py'),)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7f47322ef370>
stdout = b'Overall structure itemsize: 80 bytes\nStructure members itemsize: [16  1 16  2 24]\nStructure members offsets: [ 0 1...e. Here we allow only arrays of size one so that users do not\nTypeError: Unsupported type <class \'numpy.ndarray\'>\n'
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/complex_struct.py')' returned non-zero exit status 1.

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:512: CalledProcessError
----------------------------- Captured stdout call -----------------------------
Original error message:
Overall structure itemsize: 80 bytes
Structure members itemsize: [16  1 16  2 24]
Structure members offsets: [ 0 16 24 40 48]
Complex structure value:
  [((0, 1, 2, 3), (4,), (5., 6.), (7,), (8, 9, 10))]
Traceback (most recent call last):
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/complex_struct.py", line 132, in <module>
    sys.exit(main())
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/complex_struct.py", line 122, in main
    kernel((1,), (N,), (s, out))
  File "cupy/_core/raw.pyx", line 89, in cupy._core.raw.RawKernel.__call__
    self.kernel(
  File "cupy/cuda/function.pyx", line 201, in cupy.cuda.function.Function.__call__
    format(grid0, grid1, grid2, max_grid_size))
  File "cupy/cuda/function.pyx", line 155, in cupy.cuda.function._launch
    if itemsize == 8:
  File "cupy/cuda/function.pyx", line 123, in cupy.cuda.function._pointer
    # value. Here we allow only arrays of size one so that users do not
TypeError: Unsupported type <class 'numpy.ndarray'>

_____________________ TestCustomStruct.test_packed_matrix ______________________

self = <example_tests.test_custom_struct.TestCustomStruct testMethod=test_packed_matrix>

    def test_packed_matrix(self):
>       output = example_test.run_example('custom_struct/packed_matrix.py')

tests/example_tests/test_custom_struct.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/example_tests/example_test.py:12: in run_example
    return subprocess.check_output(
/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:411: in check_output
    return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = None, check = True
popenargs = (('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/packed_matrix.py'),)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7f47322f4d90>
stdout = b'Traceback (most recent call last):\n  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/te...e. Here we allow only arrays of size one so that users do not\nTypeError: Unsupported type <class \'numpy.ndarray\'>\n'
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '('/home/kmaeh/.pyenv/versions/rocm-ci/bin/python', '/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/packed_matrix.py')' returned non-zero exit status 1.

/home/kmaeh/.pyenv/versions/3.8.7/lib/python3.8/subprocess.py:512: CalledProcessError
----------------------------- Captured stdout call -----------------------------
Original error message:
Traceback (most recent call last):
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/packed_matrix.py", line 91, in <module>
    sys.exit(main())
  File "/home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/example_tests/../../examples/custom_struct/packed_matrix.py", line 81, in main
    kernel((1,), (N,), args)
  File "cupy/_core/raw.pyx", line 89, in cupy._core.raw.RawKernel.__call__
    self.kernel(
  File "cupy/cuda/function.pyx", line 201, in cupy.cuda.function.Function.__call__
    format(grid0, grid1, grid2, max_grid_size))
  File "cupy/cuda/function.pyx", line 155, in cupy.cuda.function._launch
    if itemsize == 8:
  File "cupy/cuda/function.pyx", line 123, in cupy.cuda.function._pointer
    # value. Here we allow only arrays of size one so that users do not
TypeError: Unsupported type <class 'numpy.ndarray'>

=============================== warnings summary ===============================
tests/cupy_tests/core_tests/fusion_tests/test_array.py: 1 warning
tests/cupy_tests/math_tests/test_sumprod.py: 19 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: overflow encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/core_tests/fusion_tests/test_routines.py::TestFusionNumericalReduction_param_1_{func='prod'}::test_reduction
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: overflow encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_0_{type_l='poly1d', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_3_{type_l='ndarray', type_r='ndarray'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_array
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in multiply
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in half_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in byte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in short_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ubyte_scalars
    y = y * x + p[i]

tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_1_{type_l='poly1d', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyval_param_4_{type_l='ndarray', type_r='numpy_scalar'}::test_polyval
tests/cupy_tests/lib_tests/test_polynomial.py::TestPolyvalDtypesCombination::test_polyval_diff_types_array_scalar
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/polynomial.py:734: RuntimeWarning: overflow encountered in ushort_scalars
    y = y * x + p[i]

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in power
    absx **= ord

tests/cupy_tests/linalg_tests/test_norms.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/linalg/linalg.py:2568: RuntimeWarning: divide by zero encountered in reciprocal
    absx **= ord

tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf
tests/cupy_tests/math_tests/test_misc.py::TestMisc::test_nan_to_num_inf_nan
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/numeric.py:2276: RuntimeWarning: overflow encountered in absolute
    return less_equal(abs(x-y), atol + rtol * abs(y))

tests/cupy_tests/math_tests/test_sumprod.py: 15 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:51: RuntimeWarning: invalid value encountered in reduce
    return umr_prod(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_11_{axis=0, func='nanprod', keepdims=True, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_all
tests/cupy_tests/math_tests/test_sumprod.py::TestNansumNanprodLong_param_15_{axis=0, func='nanprod', keepdims=False, shape=(20, 30, 40), transpose_axes=False}::test_nansum_axis_transposed
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:87: RuntimeWarning: invalid value encountered in reduce
    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)

tests/cupy_tests/math_tests/test_sumprod.py: 32 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/cupy_tests/math_tests/test_sumprod.py:800: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_all_transposed2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes2
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axes4
tests/cupy_tests/math_tests/test_sumprod.py::TestSumprod::test_sum_axis_transposed2
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py::TestStats::test_only_input[_param_2_{op='variance'}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py::TestStats::test_only_input[_param_3_{op='standard_deviation'}]
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:47: RuntimeWarning: overflow encountered in reduce
    return umr_sum(a, axis, dtype, out, keepdims, initial, where)

tests/cupy_tests/statistics_tests/test_meanvar.py: 28 warnings
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/cupy_tests/statistics_tests/test_meanvar.py:114: RuntimeWarning: invalid value encountered in true_divide
    a = a / a

tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_4_{axis=0, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_5_{axis=0, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_6_{axis=0, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_7_{axis=0, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_8_{axis=1, keepdims=True, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_9_{axis=1, keepdims=True, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_10_{axis=1, keepdims=False, overwrite_input=True, shape=(3, 4, 5)}::test_nanmedian
tests/cupy_tests/statistics_tests/test_meanvar.py::TestNanMedian_param_11_{axis=1, keepdims=False, overwrite_input=False, shape=(3, 4, 5)}::test_nanmedian
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/lib/nanfunctions.py:1113: RuntimeWarning: All-NaN slice encountered
    r, k = function_base._ureduce(a, func=_nanmedian, axis=axis, out=out,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_3_{func='mean', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_5_{func='mean', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3372: RuntimeWarning: Mean of empty slice.
    return _methods._mean(a, axis=axis, dtype=dtype,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:170: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_1_{func='mean', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_2_{func='mean', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_4_{func='mean', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:168: RuntimeWarning: invalid value encountered in true_divide
    ret = arr.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_9_{func='std', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_11_{func='std', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:233: RuntimeWarning: Degrees of freedom <= 0 for slice
    ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:194: RuntimeWarning: invalid value encountered in true_divide
    arrmean = um.true_divide(

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in double_scalars
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_7_{func='std', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_8_{func='std', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_10_{func='std', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/_methods.py:226: RuntimeWarning: invalid value encountered in true_divide
    ret = ret.dtype.type(ret / rcount)

tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_13_{func='var', params=((0,), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_14_{func='var', params=((0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_15_{func='var', params=((0, 0), 1)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_16_{func='var', params=((0, 0, 0), None)}::test_external_mean_zero_len
tests/cupy_tests/statistics_tests/test_meanvar.py::TestProductZeroLength_param_17_{func='var', params=((0, 0, 0), (0, 2))}::test_external_mean_zero_len
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3621: RuntimeWarning: Degrees of freedom <= 0 for slice
    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,

tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_217_{cval=nan, mode='constant', order=0, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_220_{cval=nan, mode='constant', order=1, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_223_{cval=nan, mode='constant', order=3, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_226_{cval=inf, mode='constant', order=0, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_229_{cval=inf, mode='constant', order=1, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_232_{cval=inf, mode='constant', order=3, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_235_{cval=-inf, mode='constant', order=0, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_238_{cval=-inf, mode='constant', order=1, output=float64, prefilter=True, shift=0.1}]
tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py::TestShift::test_shift_int[_param_241_{cval=-inf, mode='constant', order=3, output=float64, prefilter=True, shift=0.1}]
  /home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/tests/cupyx_tests/scipy_tests/ndimage_tests/test_interpolation.py:533: RuntimeWarning: invalid value encountered in remainder
    float_out = self._shift(xp, scp, a.astype(xp.float64)) % 1

tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py: 14 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/ndimage/measurements.py:684: RuntimeWarning: invalid value encountered in true_divide
    return sum / numpy.asanyarray(count).astype(numpy.float64)

tests/cupyx_tests/scipy_tests/ndimage_tests/test_measurements.py: 28 warnings
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/ndimage/measurements.py:736: RuntimeWarning: invalid value encountered in true_divide
    return sum_c_sq / np.asanyarray(count).astype(float)

tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_0_{im=(10,), mysize=3, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_1_{im=(10,), mysize=3, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_2_{im=(10,), mysize=4, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_3_{im=(10,), mysize=4, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_4_{im=(10,), mysize=(3, 4, 5), noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_5_{im=(10,), mysize=(3, 4, 5), noise=True}::test_wiener
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/signal/signaltools.py:1598: RuntimeWarning: divide by zero encountered in true_divide
    res *= (1 - noise / lVar)

tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_0_{im=(10,), mysize=3, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_1_{im=(10,), mysize=3, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_2_{im=(10,), mysize=4, noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_3_{im=(10,), mysize=4, noise=True}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_4_{im=(10,), mysize=(3, 4, 5), noise=False}::test_wiener
tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestWiener_param_5_{im=(10,), mysize=(3, 4, 5), noise=True}::test_wiener
  /home/kmaeh/.pyenv/versions/rocm-ci/lib/python3.8/site-packages/scipy/signal/signaltools.py:1598: RuntimeWarning: invalid value encountered in multiply
    res *= (1 - noise / lVar)

-- Docs: https://docs.pytest.org/en/stable/warnings.html
- generated html file: file:///home/kmaeh/Development/cupy-rocm-ci-report/tools/tmp.e5sHts9LIQ/cupy/_output/report.html -
=========================== short test summary info ============================
FAILED tests/cupy_tests/core_tests/test_ndarray.py::TestNdarrayCopy::test_copy_multi_device_with_stream
FAILED tests/cupy_tests/linalg_tests/test_product.py::TestMatrixPower::test_matrix_power_1
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_0_{dtype=float64, scale_shape=(), shape=(4, 3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_1_{dtype=float64, scale_shape=(), shape=(4, 3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_2_{dtype=float64, scale_shape=(), shape=(3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_3_{dtype=float64, scale_shape=(), shape=(3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_4_{dtype=float64, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_5_{dtype=float64, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_6_{dtype=float64, scale_shape=(3, 2), shape=(3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_7_{dtype=float64, scale_shape=(3, 2), shape=(3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_8_{dtype=float32, scale_shape=(), shape=(4, 3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_9_{dtype=float32, scale_shape=(), shape=(4, 3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_10_{dtype=float32, scale_shape=(), shape=(3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_11_{dtype=float32, scale_shape=(), shape=(3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_12_{dtype=float32, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_13_{dtype=float32, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_14_{dtype=float32, scale_shape=(3, 2), shape=(3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_15_{dtype=float32, scale_shape=(3, 2), shape=(3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_16_{dtype=float16, scale_shape=(), shape=(4, 3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_17_{dtype=float16, scale_shape=(), shape=(4, 3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_18_{dtype=float16, scale_shape=(), shape=(3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_19_{dtype=float16, scale_shape=(), shape=(3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_20_{dtype=float16, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_21_{dtype=float16, scale_shape=(3, 2), shape=(4, 3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_22_{dtype=float16, scale_shape=(3, 2), shape=(3, 2), shape_shape=()}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsGamma_param_23_{dtype=float16, scale_shape=(3, 2), shape=(3, 2), shape_shape=(3, 2)}::test_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsStandardGamma_param_0_{shape=(4, 3, 2), shape_shape=()}::test_standard_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsStandardGamma_param_1_{shape=(4, 3, 2), shape_shape=(3, 2)}::test_standard_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsStandardGamma_param_2_{shape=(3, 2), shape_shape=()}::test_standard_gamma_generator
FAILED tests/cupy_tests/random_tests/test_distributions.py::TestDistributionsStandardGamma_param_3_{shape=(3, 2), shape_shape=(3, 2)}::test_standard_gamma_generator
FAILED tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py::TestHfftn_param_20_{axes=None, norm=None, s=None, shape=(3, 3, 10)}::test_hfftn
FAILED tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py::TestHfftn_param_20_{axes=None, norm=None, s=None, shape=(3, 3, 10)}::test_hfftn_backend
FAILED tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py::TestHfftn_param_21_{axes=None, norm='backward', s=None, shape=(3, 3, 10)}::test_hfftn
FAILED tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py::TestHfftn_param_21_{axes=None, norm='backward', s=None, shape=(3, 3, 10)}::test_hfftn_backend
FAILED tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py::TestHfftn_param_22_{axes=None, norm='ortho', s=None, shape=(3, 3, 10)}::test_hfftn
FAILED tests/cupyx_tests/scipy_tests/fft_tests/test_fft.py::TestHfftn_param_22_{axes=None, norm='ortho', s=None, shape=(3, 3, 10)}::test_hfftn_backend
FAILED tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py::TestLUSolve_param_2_{shapes=((4, 4), (4,)), trans=2}::test_lu_solve
FAILED tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py::TestLUSolve_param_4_{shapes=((5, 5), (5, 2)), trans=1}::test_lu_solve
FAILED tests/cupyx_tests/scipy_tests/linalg_tests/test_decomp_lu.py::TestLUSolve_param_5_{shapes=((5, 5), (5, 2)), trans=2}::test_lu_solve
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_156_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_158_{dtype=uint8, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_160_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_162_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_324_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core._reduction.ReductionKernel object a...1c16f60>, <function lt_pyfunc at 0x7f4861ce2280>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_326_{dtype=float64, filter='generic_filter', footprint=False, func_or_kernel=(<cupy._core._reduction.ReductionKernel object a...1c16f60>, <function lt_pyfunc at 0x7f4861ce2280>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_484_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_486_{dtype=uint8, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_488_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_490_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core.raw.RawKernel object at 0x7f4861c54dc0>, <function rms_pyfunc at 0x7f4863043940>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_652_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core._reduction.ReductionKernel object a...1c16f60>, <function lt_pyfunc at 0x7f4861ce2280>), ksize=3, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/ndimage_tests/test_filters.py::TestGenericFilter::test_filter[_param_654_{dtype=float64, filter='generic_filter', footprint=True, func_or_kernel=(<cupy._core._reduction.ReductionKernel object a...1c16f60>, <function lt_pyfunc at 0x7f4861ce2280>), ksize=4, mode='mirror', shape=(4, 5)}]
FAILED tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestFFTConvolve_param_44_{mode='valid', size1=(3, 4, 10), size2=3}::test_correlate_fft
FAILED tests/cupyx_tests/scipy_tests/signal_tests/test_signaltools.py::TestFFTConvolve_param_44_{mode='valid', size1=(3, 4, 10), size2=3}::test_fftconvolve
FAILED tests/example_tests/test_custom_struct.py::TestCustomStruct::test_builtin_vectors
FAILED tests/example_tests/test_custom_struct.py::TestCustomStruct::test_complex_struct
FAILED tests/example_tests/test_custom_struct.py::TestCustomStruct::test_packed_matrix
= 56 failed, 64064 passed, 7381 skipped, 65 deselected, 517 xfailed, 272 warnings in 25956.70s (7:12:36) =
